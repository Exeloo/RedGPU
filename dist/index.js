var i=1e-6,m="undefined"!=typeof Float32Array?Float32Array:Array,g=Math.random;var x=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var i=0,m=arguments.length;m--;)i+=arguments[m]*arguments[m];return Math.sqrt(i)});var _=Object.freeze({__proto__:null,get ARRAY_TYPE(){return m},EPSILON:i,RANDOM:g,equals:function(m,g){return Math.abs(m-g)<=i*Math.max(1,Math.abs(m),Math.abs(g))},setMatrixArrayType:function(i){m=i},toRadian:function(i){return i*x}});function multiply$8(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=g[0],w=g[1],P=g[2],$=g[3];return i[0]=x*T+b*w,i[1]=_*T+y*w,i[2]=x*P+b*$,i[3]=_*P+y*$,i}function subtract$6(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i[3]=m[3]-g[3],i}var b=multiply$8,y=subtract$6,T=Object.freeze({__proto__:null,LDU:function(i,m,g,x){return i[2]=x[2]/x[0],g[0]=x[0],g[1]=x[1],g[3]=x[3]-i[2]*g[1],[i,m,g]},add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i},adjoint:function(i,m){var g=m[0];return i[0]=m[3],i[1]=-m[1],i[2]=-m[2],i[3]=g,i},clone:function(i){var g=new m(4);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g},copy:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i},create:function(){var i=new m(4);return m!=Float32Array&&(i[1]=0,i[2]=0),i[0]=1,i[3]=1,i},determinant:function(i){return i[0]*i[3]-i[2]*i[1]},equals:function(m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=g[0],w=g[1],P=g[2],$=g[3];return Math.abs(x-T)<=i*Math.max(1,Math.abs(x),Math.abs(T))&&Math.abs(_-w)<=i*Math.max(1,Math.abs(_),Math.abs(w))&&Math.abs(b-P)<=i*Math.max(1,Math.abs(b),Math.abs(P))&&Math.abs(y-$)<=i*Math.max(1,Math.abs(y),Math.abs($))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]},frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3])},fromRotation:function(i,m){var g=Math.sin(m),x=Math.cos(m);return i[0]=x,i[1]=g,i[2]=-g,i[3]=x,i},fromScaling:function(i,m){return i[0]=m[0],i[1]=0,i[2]=0,i[3]=m[1],i},fromValues:function(i,g,x,_){var b=new m(4);return b[0]=i,b[1]=g,b[2]=x,b[3]=_,b},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=1,i},invert:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=g*b-_*x;return y?(y=1/y,i[0]=b*y,i[1]=-x*y,i[2]=-_*y,i[3]=g*y,i):null},mul:b,multiply:multiply$8,multiplyScalar:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i},multiplyScalarAndAdd:function(i,m,g,x){return i[0]=m[0]+g[0]*x,i[1]=m[1]+g[1]*x,i[2]=m[2]+g[2]*x,i[3]=m[3]+g[3]*x,i},rotate:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=Math.sin(g),w=Math.cos(g);return i[0]=x*w+b*T,i[1]=_*w+y*T,i[2]=x*-T+b*w,i[3]=_*-T+y*w,i},scale:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=g[0],w=g[1];return i[0]=x*T,i[1]=_*T,i[2]=b*w,i[3]=y*w,i},set:function(i,m,g,x,_){return i[0]=m,i[1]=g,i[2]=x,i[3]=_,i},str:function(i){return"mat2("+i[0]+","+i[1]+","+i[2]+","+i[3]+")"},sub:y,subtract:subtract$6,transpose:function(i,m){if(i===m){var g=m[1];i[1]=m[2],i[2]=g}else i[0]=m[0],i[1]=m[2],i[2]=m[1],i[3]=m[3];return i}});function multiply$7(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=g[0],$=g[1],H=g[2],z=g[3],q=g[4],W=g[5];return i[0]=x*P+b*$,i[1]=_*P+y*$,i[2]=x*H+b*z,i[3]=_*H+y*z,i[4]=x*q+b*W+T,i[5]=_*q+y*W+w,i}function subtract$5(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i[3]=m[3]-g[3],i[4]=m[4]-g[4],i[5]=m[5]-g[5],i}var w=multiply$7,P=subtract$5,$=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i[4]=m[4]+g[4],i[5]=m[5]+g[5],i},clone:function(i){var g=new m(6);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g},copy:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i},create:function(){var i=new m(6);return m!=Float32Array&&(i[1]=0,i[2]=0,i[4]=0,i[5]=0),i[0]=1,i[3]=1,i},determinant:function(i){return i[0]*i[3]-i[1]*i[2]},equals:function(m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=g[0],$=g[1],H=g[2],z=g[3],q=g[4],W=g[5];return Math.abs(x-P)<=i*Math.max(1,Math.abs(x),Math.abs(P))&&Math.abs(_-$)<=i*Math.max(1,Math.abs(_),Math.abs($))&&Math.abs(b-H)<=i*Math.max(1,Math.abs(b),Math.abs(H))&&Math.abs(y-z)<=i*Math.max(1,Math.abs(y),Math.abs(z))&&Math.abs(T-q)<=i*Math.max(1,Math.abs(T),Math.abs(q))&&Math.abs(w-W)<=i*Math.max(1,Math.abs(w),Math.abs(W))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]&&i[4]===m[4]&&i[5]===m[5]},frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3],i[4],i[5],1)},fromRotation:function(i,m){var g=Math.sin(m),x=Math.cos(m);return i[0]=x,i[1]=g,i[2]=-g,i[3]=x,i[4]=0,i[5]=0,i},fromScaling:function(i,m){return i[0]=m[0],i[1]=0,i[2]=0,i[3]=m[1],i[4]=0,i[5]=0,i},fromTranslation:function(i,m){return i[0]=1,i[1]=0,i[2]=0,i[3]=1,i[4]=m[0],i[5]=m[1],i},fromValues:function(i,g,x,_,b,y){var T=new m(6);return T[0]=i,T[1]=g,T[2]=x,T[3]=_,T[4]=b,T[5]=y,T},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=1,i[4]=0,i[5]=0,i},invert:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=m[4],T=m[5],w=g*b-x*_;return w?(w=1/w,i[0]=b*w,i[1]=-x*w,i[2]=-_*w,i[3]=g*w,i[4]=(_*T-b*y)*w,i[5]=(x*y-g*T)*w,i):null},mul:w,multiply:multiply$7,multiplyScalar:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i[4]=m[4]*g,i[5]=m[5]*g,i},multiplyScalarAndAdd:function(i,m,g,x){return i[0]=m[0]+g[0]*x,i[1]=m[1]+g[1]*x,i[2]=m[2]+g[2]*x,i[3]=m[3]+g[3]*x,i[4]=m[4]+g[4]*x,i[5]=m[5]+g[5]*x,i},rotate:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=Math.sin(g),$=Math.cos(g);return i[0]=x*$+b*P,i[1]=_*$+y*P,i[2]=x*-P+b*$,i[3]=_*-P+y*$,i[4]=T,i[5]=w,i},scale:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=g[0],$=g[1];return i[0]=x*P,i[1]=_*P,i[2]=b*$,i[3]=y*$,i[4]=T,i[5]=w,i},set:function(i,m,g,x,_,b,y){return i[0]=m,i[1]=g,i[2]=x,i[3]=_,i[4]=b,i[5]=y,i},str:function(i){return"mat2d("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+")"},sub:P,subtract:subtract$5,translate:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=g[0],$=g[1];return i[0]=x,i[1]=_,i[2]=b,i[3]=y,i[4]=x*P+b*$+T,i[5]=_*P+y*$+w,i}});function create$6(){var i=new m(9);return m!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[5]=0,i[6]=0,i[7]=0),i[0]=1,i[4]=1,i[8]=1,i}function multiply$6(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=m[8],z=g[0],q=g[1],W=g[2],ye=g[3],Ge=g[4],Ke=g[5],Xe=g[6],je=g[7],Ye=g[8];return i[0]=z*x+q*y+W*P,i[1]=z*_+q*T+W*$,i[2]=z*b+q*w+W*H,i[3]=ye*x+Ge*y+Ke*P,i[4]=ye*_+Ge*T+Ke*$,i[5]=ye*b+Ge*w+Ke*H,i[6]=Xe*x+je*y+Ye*P,i[7]=Xe*_+je*T+Ye*$,i[8]=Xe*b+je*w+Ye*H,i}function subtract$4(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i[3]=m[3]-g[3],i[4]=m[4]-g[4],i[5]=m[5]-g[5],i[6]=m[6]-g[6],i[7]=m[7]-g[7],i[8]=m[8]-g[8],i}var H=multiply$6,z=subtract$4,q=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i[4]=m[4]+g[4],i[5]=m[5]+g[5],i[6]=m[6]+g[6],i[7]=m[7]+g[7],i[8]=m[8]+g[8],i},adjoint:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=m[4],T=m[5],w=m[6],P=m[7],$=m[8];return i[0]=y*$-T*P,i[1]=_*P-x*$,i[2]=x*T-_*y,i[3]=T*w-b*$,i[4]=g*$-_*w,i[5]=_*b-g*T,i[6]=b*P-y*w,i[7]=x*w-g*P,i[8]=g*y-x*b,i},clone:function(i){var g=new m(9);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g[8]=i[8],g},copy:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i},create:create$6,determinant:function(i){var m=i[0],g=i[1],x=i[2],_=i[3],b=i[4],y=i[5],T=i[6],w=i[7],P=i[8];return m*(P*b-y*w)+g*(-P*_+y*T)+x*(w*_-b*T)},equals:function(m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=m[8],z=g[0],q=g[1],W=g[2],ye=g[3],Ge=g[4],Ke=g[5],Xe=g[6],je=g[7],Ye=g[8];return Math.abs(x-z)<=i*Math.max(1,Math.abs(x),Math.abs(z))&&Math.abs(_-q)<=i*Math.max(1,Math.abs(_),Math.abs(q))&&Math.abs(b-W)<=i*Math.max(1,Math.abs(b),Math.abs(W))&&Math.abs(y-ye)<=i*Math.max(1,Math.abs(y),Math.abs(ye))&&Math.abs(T-Ge)<=i*Math.max(1,Math.abs(T),Math.abs(Ge))&&Math.abs(w-Ke)<=i*Math.max(1,Math.abs(w),Math.abs(Ke))&&Math.abs(P-Xe)<=i*Math.max(1,Math.abs(P),Math.abs(Xe))&&Math.abs($-je)<=i*Math.max(1,Math.abs($),Math.abs(je))&&Math.abs(H-Ye)<=i*Math.max(1,Math.abs(H),Math.abs(Ye))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]&&i[4]===m[4]&&i[5]===m[5]&&i[6]===m[6]&&i[7]===m[7]&&i[8]===m[8]},frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],i[8])},fromMat2d:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=0,i[3]=m[2],i[4]=m[3],i[5]=0,i[6]=m[4],i[7]=m[5],i[8]=1,i},fromMat4:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[4],i[4]=m[5],i[5]=m[6],i[6]=m[8],i[7]=m[9],i[8]=m[10],i},fromQuat:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=g+g,T=x+x,w=_+_,P=g*y,$=x*y,H=x*T,z=_*y,q=_*T,W=_*w,ye=b*y,Ge=b*T,Ke=b*w;return i[0]=1-H-W,i[3]=$-Ke,i[6]=z+Ge,i[1]=$+Ke,i[4]=1-P-W,i[7]=q-ye,i[2]=z-Ge,i[5]=q+ye,i[8]=1-P-H,i},fromRotation:function(i,m){var g=Math.sin(m),x=Math.cos(m);return i[0]=x,i[1]=g,i[2]=0,i[3]=-g,i[4]=x,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},fromScaling:function(i,m){return i[0]=m[0],i[1]=0,i[2]=0,i[3]=0,i[4]=m[1],i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},fromTranslation:function(i,m){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=m[0],i[7]=m[1],i[8]=1,i},fromValues:function(i,g,x,_,b,y,T,w,P){var $=new m(9);return $[0]=i,$[1]=g,$[2]=x,$[3]=_,$[4]=b,$[5]=y,$[6]=T,$[7]=w,$[8]=P,$},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},invert:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=m[4],T=m[5],w=m[6],P=m[7],$=m[8],H=$*y-T*P,z=-$*b+T*w,q=P*b-y*w,W=g*H+x*z+_*q;return W?(W=1/W,i[0]=H*W,i[1]=(-$*x+_*P)*W,i[2]=(T*x-_*y)*W,i[3]=z*W,i[4]=($*g-_*w)*W,i[5]=(-T*g+_*b)*W,i[6]=q*W,i[7]=(-P*g+x*w)*W,i[8]=(y*g-x*b)*W,i):null},mul:H,multiply:multiply$6,multiplyScalar:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i[4]=m[4]*g,i[5]=m[5]*g,i[6]=m[6]*g,i[7]=m[7]*g,i[8]=m[8]*g,i},multiplyScalarAndAdd:function(i,m,g,x){return i[0]=m[0]+g[0]*x,i[1]=m[1]+g[1]*x,i[2]=m[2]+g[2]*x,i[3]=m[3]+g[3]*x,i[4]=m[4]+g[4]*x,i[5]=m[5]+g[5]*x,i[6]=m[6]+g[6]*x,i[7]=m[7]+g[7]*x,i[8]=m[8]+g[8]*x,i},normalFromMat4:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=m[4],T=m[5],w=m[6],P=m[7],$=m[8],H=m[9],z=m[10],q=m[11],W=m[12],ye=m[13],Ge=m[14],Ke=m[15],Xe=g*T-x*y,je=g*w-_*y,Ye=g*P-b*y,Ze=x*w-_*T,Je=x*P-b*T,Qe=_*P-b*w,et=$*ye-H*W,at=$*Ge-z*W,ht=$*Ke-q*W,ft=H*Ge-z*ye,gt=H*Ke-q*ye,xt=z*Ke-q*Ge,vt=Xe*xt-je*gt+Ye*ft+Ze*ht-Je*at+Qe*et;return vt?(vt=1/vt,i[0]=(T*xt-w*gt+P*ft)*vt,i[1]=(w*ht-y*xt-P*at)*vt,i[2]=(y*gt-T*ht+P*et)*vt,i[3]=(_*gt-x*xt-b*ft)*vt,i[4]=(g*xt-_*ht+b*at)*vt,i[5]=(x*ht-g*gt-b*et)*vt,i[6]=(ye*Qe-Ge*Je+Ke*Ze)*vt,i[7]=(Ge*Ye-W*Qe-Ke*je)*vt,i[8]=(W*Je-ye*Ye+Ke*Xe)*vt,i):null},projection:function(i,m,g){return i[0]=2/m,i[1]=0,i[2]=0,i[3]=0,i[4]=-2/g,i[5]=0,i[6]=-1,i[7]=1,i[8]=1,i},rotate:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=m[8],z=Math.sin(g),q=Math.cos(g);return i[0]=q*x+z*y,i[1]=q*_+z*T,i[2]=q*b+z*w,i[3]=q*y-z*x,i[4]=q*T-z*_,i[5]=q*w-z*b,i[6]=P,i[7]=$,i[8]=H,i},scale:function(i,m,g){var x=g[0],_=g[1];return i[0]=x*m[0],i[1]=x*m[1],i[2]=x*m[2],i[3]=_*m[3],i[4]=_*m[4],i[5]=_*m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i},set:function(i,m,g,x,_,b,y,T,w,P){return i[0]=m,i[1]=g,i[2]=x,i[3]=_,i[4]=b,i[5]=y,i[6]=T,i[7]=w,i[8]=P,i},str:function(i){return"mat3("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+","+i[6]+","+i[7]+","+i[8]+")"},sub:z,subtract:subtract$4,translate:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=m[8],z=g[0],q=g[1];return i[0]=x,i[1]=_,i[2]=b,i[3]=y,i[4]=T,i[5]=w,i[6]=z*x+q*y+P,i[7]=z*_+q*T+$,i[8]=z*b+q*w+H,i},transpose:function(i,m){if(i===m){var g=m[1],x=m[2],_=m[5];i[1]=m[3],i[2]=m[6],i[3]=g,i[5]=m[7],i[6]=x,i[7]=_}else i[0]=m[0],i[1]=m[3],i[2]=m[6],i[3]=m[1],i[4]=m[4],i[5]=m[7],i[6]=m[2],i[7]=m[5],i[8]=m[8];return i}});function create$5(){var i=new m(16);return m!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0),i[0]=1,i[5]=1,i[10]=1,i[15]=1,i}function clone$5(i){var g=new m(16);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g[8]=i[8],g[9]=i[9],g[10]=i[10],g[11]=i[11],g[12]=i[12],g[13]=i[13],g[14]=i[14],g[15]=i[15],g}function copy$5(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15],i}function fromValues$5(i,g,x,_,b,y,T,w,P,$,H,z,q,W,ye,Ge){var Ke=new m(16);return Ke[0]=i,Ke[1]=g,Ke[2]=x,Ke[3]=_,Ke[4]=b,Ke[5]=y,Ke[6]=T,Ke[7]=w,Ke[8]=P,Ke[9]=$,Ke[10]=H,Ke[11]=z,Ke[12]=q,Ke[13]=W,Ke[14]=ye,Ke[15]=Ge,Ke}function identity$2(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function invert$2(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=m[4],T=m[5],w=m[6],P=m[7],$=m[8],H=m[9],z=m[10],q=m[11],W=m[12],ye=m[13],Ge=m[14],Ke=m[15],Xe=g*T-x*y,je=g*w-_*y,Ye=g*P-b*y,Ze=x*w-_*T,Je=x*P-b*T,Qe=_*P-b*w,et=$*ye-H*W,at=$*Ge-z*W,ht=$*Ke-q*W,ft=H*Ge-z*ye,gt=H*Ke-q*ye,xt=z*Ke-q*Ge,vt=Xe*xt-je*gt+Ye*ft+Ze*ht-Je*at+Qe*et;return vt?(vt=1/vt,i[0]=(T*xt-w*gt+P*ft)*vt,i[1]=(_*gt-x*xt-b*ft)*vt,i[2]=(ye*Qe-Ge*Je+Ke*Ze)*vt,i[3]=(z*Je-H*Qe-q*Ze)*vt,i[4]=(w*ht-y*xt-P*at)*vt,i[5]=(g*xt-_*ht+b*at)*vt,i[6]=(Ge*Ye-W*Qe-Ke*je)*vt,i[7]=($*Qe-z*Ye+q*je)*vt,i[8]=(y*gt-T*ht+P*et)*vt,i[9]=(x*ht-g*gt-b*et)*vt,i[10]=(W*Je-ye*Ye+Ke*Xe)*vt,i[11]=(H*Ye-$*Je-q*Xe)*vt,i[12]=(T*at-y*ft-w*et)*vt,i[13]=(g*ft-x*at+_*et)*vt,i[14]=(ye*je-W*Ze-Ge*Xe)*vt,i[15]=($*Ze-H*je+z*Xe)*vt,i):null}function multiply$5(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=m[8],z=m[9],q=m[10],W=m[11],ye=m[12],Ge=m[13],Ke=m[14],Xe=m[15],je=g[0],Ye=g[1],Ze=g[2],Je=g[3];return i[0]=je*x+Ye*T+Ze*H+Je*ye,i[1]=je*_+Ye*w+Ze*z+Je*Ge,i[2]=je*b+Ye*P+Ze*q+Je*Ke,i[3]=je*y+Ye*$+Ze*W+Je*Xe,je=g[4],Ye=g[5],Ze=g[6],Je=g[7],i[4]=je*x+Ye*T+Ze*H+Je*ye,i[5]=je*_+Ye*w+Ze*z+Je*Ge,i[6]=je*b+Ye*P+Ze*q+Je*Ke,i[7]=je*y+Ye*$+Ze*W+Je*Xe,je=g[8],Ye=g[9],Ze=g[10],Je=g[11],i[8]=je*x+Ye*T+Ze*H+Je*ye,i[9]=je*_+Ye*w+Ze*z+Je*Ge,i[10]=je*b+Ye*P+Ze*q+Je*Ke,i[11]=je*y+Ye*$+Ze*W+Je*Xe,je=g[12],Ye=g[13],Ze=g[14],Je=g[15],i[12]=je*x+Ye*T+Ze*H+Je*ye,i[13]=je*_+Ye*w+Ze*z+Je*Ge,i[14]=je*b+Ye*P+Ze*q+Je*Ke,i[15]=je*y+Ye*$+Ze*W+Je*Xe,i}function translate$1(i,m,g){var x,_,b,y,T,w,P,$,H,z,q,W,ye=g[0],Ge=g[1],Ke=g[2];return m===i?(i[12]=m[0]*ye+m[4]*Ge+m[8]*Ke+m[12],i[13]=m[1]*ye+m[5]*Ge+m[9]*Ke+m[13],i[14]=m[2]*ye+m[6]*Ge+m[10]*Ke+m[14],i[15]=m[3]*ye+m[7]*Ge+m[11]*Ke+m[15]):(x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=m[8],z=m[9],q=m[10],W=m[11],i[0]=x,i[1]=_,i[2]=b,i[3]=y,i[4]=T,i[5]=w,i[6]=P,i[7]=$,i[8]=H,i[9]=z,i[10]=q,i[11]=W,i[12]=x*ye+T*Ge+H*Ke+m[12],i[13]=_*ye+w*Ge+z*Ke+m[13],i[14]=b*ye+P*Ge+q*Ke+m[14],i[15]=y*ye+$*Ge+W*Ke+m[15]),i}function scale$5(i,m,g){var x=g[0],_=g[1],b=g[2];return i[0]=m[0]*x,i[1]=m[1]*x,i[2]=m[2]*x,i[3]=m[3]*x,i[4]=m[4]*_,i[5]=m[5]*_,i[6]=m[6]*_,i[7]=m[7]*_,i[8]=m[8]*b,i[9]=m[9]*b,i[10]=m[10]*b,i[11]=m[11]*b,i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15],i}function rotateX$3(i,m,g){var x=Math.sin(g),_=Math.cos(g),b=m[4],y=m[5],T=m[6],w=m[7],P=m[8],$=m[9],H=m[10],z=m[11];return m!==i&&(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]),i[4]=b*_+P*x,i[5]=y*_+$*x,i[6]=T*_+H*x,i[7]=w*_+z*x,i[8]=P*_-b*x,i[9]=$*_-y*x,i[10]=H*_-T*x,i[11]=z*_-w*x,i}function rotateY$3(i,m,g){var x=Math.sin(g),_=Math.cos(g),b=m[0],y=m[1],T=m[2],w=m[3],P=m[8],$=m[9],H=m[10],z=m[11];return m!==i&&(i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]),i[0]=b*_-P*x,i[1]=y*_-$*x,i[2]=T*_-H*x,i[3]=w*_-z*x,i[8]=b*x+P*_,i[9]=y*x+$*_,i[10]=T*x+H*_,i[11]=w*x+z*_,i}function rotateZ$3(i,m,g){var x=Math.sin(g),_=Math.cos(g),b=m[0],y=m[1],T=m[2],w=m[3],P=m[4],$=m[5],H=m[6],z=m[7];return m!==i&&(i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]),i[0]=b*_+P*x,i[1]=y*_+$*x,i[2]=T*_+H*x,i[3]=w*_+z*x,i[4]=P*_-b*x,i[5]=$*_-y*x,i[6]=H*_-T*x,i[7]=z*_-w*x,i}function fromRotationTranslation$1(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=x+x,w=_+_,P=b+b,$=x*T,H=x*w,z=x*P,q=_*w,W=_*P,ye=b*P,Ge=y*T,Ke=y*w,Xe=y*P;return i[0]=1-(q+ye),i[1]=H+Xe,i[2]=z-Ke,i[3]=0,i[4]=H-Xe,i[5]=1-($+ye),i[6]=W+Ge,i[7]=0,i[8]=z+Ke,i[9]=W-Ge,i[10]=1-($+q),i[11]=0,i[12]=g[0],i[13]=g[1],i[14]=g[2],i[15]=1,i}function getTranslation$1(i,m){return i[0]=m[12],i[1]=m[13],i[2]=m[14],i}function getScaling(i,m){var g=m[0],x=m[1],_=m[2],b=m[4],y=m[5],T=m[6],w=m[8],P=m[9],$=m[10];return i[0]=Math.hypot(g,x,_),i[1]=Math.hypot(b,y,T),i[2]=Math.hypot(w,P,$),i}function getRotation(i,g){var x=new m(3);getScaling(x,g);var _=1/x[0],b=1/x[1],y=1/x[2],T=g[0]*_,w=g[1]*b,P=g[2]*y,$=g[4]*_,H=g[5]*b,z=g[6]*y,q=g[8]*_,W=g[9]*b,ye=g[10]*y,Ge=T+H+ye,Ke=0;return Ge>0?(Ke=2*Math.sqrt(Ge+1),i[3]=.25*Ke,i[0]=(z-W)/Ke,i[1]=(q-P)/Ke,i[2]=(w-$)/Ke):T>H&&T>ye?(Ke=2*Math.sqrt(1+T-H-ye),i[3]=(z-W)/Ke,i[0]=.25*Ke,i[1]=(w+$)/Ke,i[2]=(q+P)/Ke):H>ye?(Ke=2*Math.sqrt(1+H-T-ye),i[3]=(q-P)/Ke,i[0]=(w+$)/Ke,i[1]=.25*Ke,i[2]=(z+W)/Ke):(Ke=2*Math.sqrt(1+ye-T-H),i[3]=(w-$)/Ke,i[0]=(q+P)/Ke,i[1]=(z+W)/Ke,i[2]=.25*Ke),i}function perspectiveNO(i,m,g,x,_){var b,y=1/Math.tan(m/2);return i[0]=y/g,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=y,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=_&&_!==1/0?(b=1/(x-_),i[10]=(_+x)*b,i[14]=2*_*x*b):(i[10]=-1,i[14]=-2*x),i}var W=perspectiveNO;function orthoNO(i,m,g,x,_,b,y){var T=1/(m-g),w=1/(x-_),P=1/(b-y);return i[0]=-2*T,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*w,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=2*P,i[11]=0,i[12]=(m+g)*T,i[13]=(_+x)*w,i[14]=(y+b)*P,i[15]=1,i}var ye=orthoNO;function orthoZO(i,m,g,x,_,b,y){var T=1/(m-g),w=1/(x-_),P=1/(b-y);return i[0]=-2*T,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*w,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=P,i[11]=0,i[12]=(m+g)*T,i[13]=(_+x)*w,i[14]=b*P,i[15]=1,i}function lookAt(m,g,x,_){var b,y,T,w,P,$,H,z,q,W,ye=g[0],Ge=g[1],Ke=g[2],Xe=_[0],je=_[1],Ye=_[2],Ze=x[0],Je=x[1],Qe=x[2];return Math.abs(ye-Ze)<i&&Math.abs(Ge-Je)<i&&Math.abs(Ke-Qe)<i?identity$2(m):(H=ye-Ze,z=Ge-Je,q=Ke-Qe,b=je*(q*=W=1/Math.hypot(H,z,q))-Ye*(z*=W),y=Ye*(H*=W)-Xe*q,T=Xe*z-je*H,(W=Math.hypot(b,y,T))?(b*=W=1/W,y*=W,T*=W):(b=0,y=0,T=0),w=z*T-q*y,P=q*b-H*T,$=H*y-z*b,(W=Math.hypot(w,P,$))?(w*=W=1/W,P*=W,$*=W):(w=0,P=0,$=0),m[0]=b,m[1]=w,m[2]=H,m[3]=0,m[4]=y,m[5]=P,m[6]=z,m[7]=0,m[8]=T,m[9]=$,m[10]=q,m[11]=0,m[12]=-(b*ye+y*Ge+T*Ke),m[13]=-(w*ye+P*Ge+$*Ke),m[14]=-(H*ye+z*Ge+q*Ke),m[15]=1,m)}function targetTo(i,m,g,x){var _=m[0],b=m[1],y=m[2],T=x[0],w=x[1],P=x[2],$=_-g[0],H=b-g[1],z=y-g[2],q=$*$+H*H+z*z;q>0&&($*=q=1/Math.sqrt(q),H*=q,z*=q);var W=w*z-P*H,ye=P*$-T*z,Ge=T*H-w*$;return(q=W*W+ye*ye+Ge*Ge)>0&&(W*=q=1/Math.sqrt(q),ye*=q,Ge*=q),i[0]=W,i[1]=ye,i[2]=Ge,i[3]=0,i[4]=H*Ge-z*ye,i[5]=z*W-$*Ge,i[6]=$*ye-H*W,i[7]=0,i[8]=$,i[9]=H,i[10]=z,i[11]=0,i[12]=_,i[13]=b,i[14]=y,i[15]=1,i}function subtract$3(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i[3]=m[3]-g[3],i[4]=m[4]-g[4],i[5]=m[5]-g[5],i[6]=m[6]-g[6],i[7]=m[7]-g[7],i[8]=m[8]-g[8],i[9]=m[9]-g[9],i[10]=m[10]-g[10],i[11]=m[11]-g[11],i[12]=m[12]-g[12],i[13]=m[13]-g[13],i[14]=m[14]-g[14],i[15]=m[15]-g[15],i}var Ge=multiply$5,Ke=subtract$3,Xe=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i[4]=m[4]+g[4],i[5]=m[5]+g[5],i[6]=m[6]+g[6],i[7]=m[7]+g[7],i[8]=m[8]+g[8],i[9]=m[9]+g[9],i[10]=m[10]+g[10],i[11]=m[11]+g[11],i[12]=m[12]+g[12],i[13]=m[13]+g[13],i[14]=m[14]+g[14],i[15]=m[15]+g[15],i},adjoint:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=m[4],T=m[5],w=m[6],P=m[7],$=m[8],H=m[9],z=m[10],q=m[11],W=m[12],ye=m[13],Ge=m[14],Ke=m[15];return i[0]=T*(z*Ke-q*Ge)-H*(w*Ke-P*Ge)+ye*(w*q-P*z),i[1]=-(x*(z*Ke-q*Ge)-H*(_*Ke-b*Ge)+ye*(_*q-b*z)),i[2]=x*(w*Ke-P*Ge)-T*(_*Ke-b*Ge)+ye*(_*P-b*w),i[3]=-(x*(w*q-P*z)-T*(_*q-b*z)+H*(_*P-b*w)),i[4]=-(y*(z*Ke-q*Ge)-$*(w*Ke-P*Ge)+W*(w*q-P*z)),i[5]=g*(z*Ke-q*Ge)-$*(_*Ke-b*Ge)+W*(_*q-b*z),i[6]=-(g*(w*Ke-P*Ge)-y*(_*Ke-b*Ge)+W*(_*P-b*w)),i[7]=g*(w*q-P*z)-y*(_*q-b*z)+$*(_*P-b*w),i[8]=y*(H*Ke-q*ye)-$*(T*Ke-P*ye)+W*(T*q-P*H),i[9]=-(g*(H*Ke-q*ye)-$*(x*Ke-b*ye)+W*(x*q-b*H)),i[10]=g*(T*Ke-P*ye)-y*(x*Ke-b*ye)+W*(x*P-b*T),i[11]=-(g*(T*q-P*H)-y*(x*q-b*H)+$*(x*P-b*T)),i[12]=-(y*(H*Ge-z*ye)-$*(T*Ge-w*ye)+W*(T*z-w*H)),i[13]=g*(H*Ge-z*ye)-$*(x*Ge-_*ye)+W*(x*z-_*H),i[14]=-(g*(T*Ge-w*ye)-y*(x*Ge-_*ye)+W*(x*w-_*T)),i[15]=g*(T*z-w*H)-y*(x*z-_*H)+$*(x*w-_*T),i},clone:clone$5,copy:copy$5,create:create$5,determinant:function(i){var m=i[0],g=i[1],x=i[2],_=i[3],b=i[4],y=i[5],T=i[6],w=i[7],P=i[8],$=i[9],H=i[10],z=i[11],q=i[12],W=i[13],ye=i[14],Ge=i[15];return(m*y-g*b)*(H*Ge-z*ye)-(m*T-x*b)*($*Ge-z*W)+(m*w-_*b)*($*ye-H*W)+(g*T-x*y)*(P*Ge-z*q)-(g*w-_*y)*(P*ye-H*q)+(x*w-_*T)*(P*W-$*q)},equals:function(m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=m[8],z=m[9],q=m[10],W=m[11],ye=m[12],Ge=m[13],Ke=m[14],Xe=m[15],je=g[0],Ye=g[1],Ze=g[2],Je=g[3],Qe=g[4],et=g[5],at=g[6],ht=g[7],ft=g[8],gt=g[9],xt=g[10],vt=g[11],bt=g[12],yt=g[13],Tt=g[14],St=g[15];return Math.abs(x-je)<=i*Math.max(1,Math.abs(x),Math.abs(je))&&Math.abs(_-Ye)<=i*Math.max(1,Math.abs(_),Math.abs(Ye))&&Math.abs(b-Ze)<=i*Math.max(1,Math.abs(b),Math.abs(Ze))&&Math.abs(y-Je)<=i*Math.max(1,Math.abs(y),Math.abs(Je))&&Math.abs(T-Qe)<=i*Math.max(1,Math.abs(T),Math.abs(Qe))&&Math.abs(w-et)<=i*Math.max(1,Math.abs(w),Math.abs(et))&&Math.abs(P-at)<=i*Math.max(1,Math.abs(P),Math.abs(at))&&Math.abs($-ht)<=i*Math.max(1,Math.abs($),Math.abs(ht))&&Math.abs(H-ft)<=i*Math.max(1,Math.abs(H),Math.abs(ft))&&Math.abs(z-gt)<=i*Math.max(1,Math.abs(z),Math.abs(gt))&&Math.abs(q-xt)<=i*Math.max(1,Math.abs(q),Math.abs(xt))&&Math.abs(W-vt)<=i*Math.max(1,Math.abs(W),Math.abs(vt))&&Math.abs(ye-bt)<=i*Math.max(1,Math.abs(ye),Math.abs(bt))&&Math.abs(Ge-yt)<=i*Math.max(1,Math.abs(Ge),Math.abs(yt))&&Math.abs(Ke-Tt)<=i*Math.max(1,Math.abs(Ke),Math.abs(Tt))&&Math.abs(Xe-St)<=i*Math.max(1,Math.abs(Xe),Math.abs(St))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]&&i[4]===m[4]&&i[5]===m[5]&&i[6]===m[6]&&i[7]===m[7]&&i[8]===m[8]&&i[9]===m[9]&&i[10]===m[10]&&i[11]===m[11]&&i[12]===m[12]&&i[13]===m[13]&&i[14]===m[14]&&i[15]===m[15]},frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],i[8],i[9],i[10],i[11],i[12],i[13],i[14],i[15])},fromQuat:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=g+g,T=x+x,w=_+_,P=g*y,$=x*y,H=x*T,z=_*y,q=_*T,W=_*w,ye=b*y,Ge=b*T,Ke=b*w;return i[0]=1-H-W,i[1]=$+Ke,i[2]=z-Ge,i[3]=0,i[4]=$-Ke,i[5]=1-P-W,i[6]=q+ye,i[7]=0,i[8]=z+Ge,i[9]=q-ye,i[10]=1-P-H,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromQuat2:function(i,g){var x=new m(3),_=-g[0],b=-g[1],y=-g[2],T=g[3],w=g[4],P=g[5],$=g[6],H=g[7],z=_*_+b*b+y*y+T*T;return z>0?(x[0]=2*(w*T+H*_+P*y-$*b)/z,x[1]=2*(P*T+H*b+$*_-w*y)/z,x[2]=2*($*T+H*y+w*b-P*_)/z):(x[0]=2*(w*T+H*_+P*y-$*b),x[1]=2*(P*T+H*b+$*_-w*y),x[2]=2*($*T+H*y+w*b-P*_)),fromRotationTranslation$1(i,g,x),i},fromRotation:function(m,g,x){var _,b,y,T=x[0],w=x[1],P=x[2],$=Math.hypot(T,w,P);return $<i?null:(T*=$=1/$,w*=$,P*=$,_=Math.sin(g),y=1-(b=Math.cos(g)),m[0]=T*T*y+b,m[1]=w*T*y+P*_,m[2]=P*T*y-w*_,m[3]=0,m[4]=T*w*y-P*_,m[5]=w*w*y+b,m[6]=P*w*y+T*_,m[7]=0,m[8]=T*P*y+w*_,m[9]=w*P*y-T*_,m[10]=P*P*y+b,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,m)},fromRotationTranslation:fromRotationTranslation$1,fromRotationTranslationScale:function(i,m,g,x){var _=m[0],b=m[1],y=m[2],T=m[3],w=_+_,P=b+b,$=y+y,H=_*w,z=_*P,q=_*$,W=b*P,ye=b*$,Ge=y*$,Ke=T*w,Xe=T*P,je=T*$,Ye=x[0],Ze=x[1],Je=x[2];return i[0]=(1-(W+Ge))*Ye,i[1]=(z+je)*Ye,i[2]=(q-Xe)*Ye,i[3]=0,i[4]=(z-je)*Ze,i[5]=(1-(H+Ge))*Ze,i[6]=(ye+Ke)*Ze,i[7]=0,i[8]=(q+Xe)*Je,i[9]=(ye-Ke)*Je,i[10]=(1-(H+W))*Je,i[11]=0,i[12]=g[0],i[13]=g[1],i[14]=g[2],i[15]=1,i},fromRotationTranslationScaleOrigin:function(i,m,g,x,_){var b=m[0],y=m[1],T=m[2],w=m[3],P=b+b,$=y+y,H=T+T,z=b*P,q=b*$,W=b*H,ye=y*$,Ge=y*H,Ke=T*H,Xe=w*P,je=w*$,Ye=w*H,Ze=x[0],Je=x[1],Qe=x[2],et=_[0],at=_[1],ht=_[2],ft=(1-(ye+Ke))*Ze,gt=(q+Ye)*Ze,xt=(W-je)*Ze,vt=(q-Ye)*Je,bt=(1-(z+Ke))*Je,yt=(Ge+Xe)*Je,Tt=(W+je)*Qe,St=(Ge-Xe)*Qe,wt=(1-(z+ye))*Qe;return i[0]=ft,i[1]=gt,i[2]=xt,i[3]=0,i[4]=vt,i[5]=bt,i[6]=yt,i[7]=0,i[8]=Tt,i[9]=St,i[10]=wt,i[11]=0,i[12]=g[0]+et-(ft*et+vt*at+Tt*ht),i[13]=g[1]+at-(gt*et+bt*at+St*ht),i[14]=g[2]+ht-(xt*et+yt*at+wt*ht),i[15]=1,i},fromScaling:function(i,m){return i[0]=m[0],i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=m[1],i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=m[2],i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromTranslation:function(i,m){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=m[0],i[13]=m[1],i[14]=m[2],i[15]=1,i},fromValues:fromValues$5,fromXRotation:function(i,m){var g=Math.sin(m),x=Math.cos(m);return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=x,i[6]=g,i[7]=0,i[8]=0,i[9]=-g,i[10]=x,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromYRotation:function(i,m){var g=Math.sin(m),x=Math.cos(m);return i[0]=x,i[1]=0,i[2]=-g,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=g,i[9]=0,i[10]=x,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromZRotation:function(i,m){var g=Math.sin(m),x=Math.cos(m);return i[0]=x,i[1]=g,i[2]=0,i[3]=0,i[4]=-g,i[5]=x,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},frustum:function(i,m,g,x,_,b,y){var T=1/(g-m),w=1/(_-x),P=1/(b-y);return i[0]=2*b*T,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2*b*w,i[6]=0,i[7]=0,i[8]=(g+m)*T,i[9]=(_+x)*w,i[10]=(y+b)*P,i[11]=-1,i[12]=0,i[13]=0,i[14]=y*b*2*P,i[15]=0,i},getRotation:getRotation,getScaling:getScaling,getTranslation:getTranslation$1,identity:identity$2,invert:invert$2,lookAt:lookAt,mul:Ge,multiply:multiply$5,multiplyScalar:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i[4]=m[4]*g,i[5]=m[5]*g,i[6]=m[6]*g,i[7]=m[7]*g,i[8]=m[8]*g,i[9]=m[9]*g,i[10]=m[10]*g,i[11]=m[11]*g,i[12]=m[12]*g,i[13]=m[13]*g,i[14]=m[14]*g,i[15]=m[15]*g,i},multiplyScalarAndAdd:function(i,m,g,x){return i[0]=m[0]+g[0]*x,i[1]=m[1]+g[1]*x,i[2]=m[2]+g[2]*x,i[3]=m[3]+g[3]*x,i[4]=m[4]+g[4]*x,i[5]=m[5]+g[5]*x,i[6]=m[6]+g[6]*x,i[7]=m[7]+g[7]*x,i[8]=m[8]+g[8]*x,i[9]=m[9]+g[9]*x,i[10]=m[10]+g[10]*x,i[11]=m[11]+g[11]*x,i[12]=m[12]+g[12]*x,i[13]=m[13]+g[13]*x,i[14]=m[14]+g[14]*x,i[15]=m[15]+g[15]*x,i},ortho:ye,orthoNO:orthoNO,orthoZO:orthoZO,perspective:W,perspectiveFromFieldOfView:function(i,m,g,x){var _=Math.tan(m.upDegrees*Math.PI/180),b=Math.tan(m.downDegrees*Math.PI/180),y=Math.tan(m.leftDegrees*Math.PI/180),T=Math.tan(m.rightDegrees*Math.PI/180),w=2/(y+T),P=2/(_+b);return i[0]=w,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=P,i[6]=0,i[7]=0,i[8]=-(y-T)*w*.5,i[9]=(_-b)*P*.5,i[10]=x/(g-x),i[11]=-1,i[12]=0,i[13]=0,i[14]=x*g/(g-x),i[15]=0,i},perspectiveNO:perspectiveNO,perspectiveZO:function(i,m,g,x,_){var b,y=1/Math.tan(m/2);return i[0]=y/g,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=y,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=_&&_!==1/0?(b=1/(x-_),i[10]=_*b,i[14]=_*x*b):(i[10]=-1,i[14]=-x),i},rotate:function(m,g,x,_){var b,y,T,w,P,$,H,z,q,W,ye,Ge,Ke,Xe,je,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt=_[0],vt=_[1],bt=_[2],yt=Math.hypot(xt,vt,bt);return yt<i?null:(xt*=yt=1/yt,vt*=yt,bt*=yt,b=Math.sin(x),T=1-(y=Math.cos(x)),w=g[0],P=g[1],$=g[2],H=g[3],z=g[4],q=g[5],W=g[6],ye=g[7],Ge=g[8],Ke=g[9],Xe=g[10],je=g[11],Ye=xt*xt*T+y,Ze=vt*xt*T+bt*b,Je=bt*xt*T-vt*b,Qe=xt*vt*T-bt*b,et=vt*vt*T+y,at=bt*vt*T+xt*b,ht=xt*bt*T+vt*b,ft=vt*bt*T-xt*b,gt=bt*bt*T+y,m[0]=w*Ye+z*Ze+Ge*Je,m[1]=P*Ye+q*Ze+Ke*Je,m[2]=$*Ye+W*Ze+Xe*Je,m[3]=H*Ye+ye*Ze+je*Je,m[4]=w*Qe+z*et+Ge*at,m[5]=P*Qe+q*et+Ke*at,m[6]=$*Qe+W*et+Xe*at,m[7]=H*Qe+ye*et+je*at,m[8]=w*ht+z*ft+Ge*gt,m[9]=P*ht+q*ft+Ke*gt,m[10]=$*ht+W*ft+Xe*gt,m[11]=H*ht+ye*ft+je*gt,g!==m&&(m[12]=g[12],m[13]=g[13],m[14]=g[14],m[15]=g[15]),m)},rotateX:rotateX$3,rotateY:rotateY$3,rotateZ:rotateZ$3,scale:scale$5,set:function(i,m,g,x,_,b,y,T,w,P,$,H,z,q,W,ye,Ge){return i[0]=m,i[1]=g,i[2]=x,i[3]=_,i[4]=b,i[5]=y,i[6]=T,i[7]=w,i[8]=P,i[9]=$,i[10]=H,i[11]=z,i[12]=q,i[13]=W,i[14]=ye,i[15]=Ge,i},str:function(i){return"mat4("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+","+i[6]+","+i[7]+","+i[8]+","+i[9]+","+i[10]+","+i[11]+","+i[12]+","+i[13]+","+i[14]+","+i[15]+")"},sub:Ke,subtract:subtract$3,targetTo:targetTo,translate:translate$1,transpose:function(i,m){if(i===m){var g=m[1],x=m[2],_=m[3],b=m[6],y=m[7],T=m[11];i[1]=m[4],i[2]=m[8],i[3]=m[12],i[4]=g,i[6]=m[9],i[7]=m[13],i[8]=x,i[9]=b,i[11]=m[14],i[12]=_,i[13]=y,i[14]=T}else i[0]=m[0],i[1]=m[4],i[2]=m[8],i[3]=m[12],i[4]=m[1],i[5]=m[5],i[6]=m[9],i[7]=m[13],i[8]=m[2],i[9]=m[6],i[10]=m[10],i[11]=m[14],i[12]=m[3],i[13]=m[7],i[14]=m[11],i[15]=m[15];return i}});function create$4(){var i=new m(3);return m!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i}function length$4(i){var m=i[0],g=i[1],x=i[2];return Math.hypot(m,g,x)}function fromValues$4(i,g,x){var _=new m(3);return _[0]=i,_[1]=g,_[2]=x,_}function set$4(i,m,g,x){return i[0]=m,i[1]=g,i[2]=x,i}function subtract$2(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i}function multiply$4(i,m,g){return i[0]=m[0]*g[0],i[1]=m[1]*g[1],i[2]=m[2]*g[2],i}function divide$2(i,m,g){return i[0]=m[0]/g[0],i[1]=m[1]/g[1],i[2]=m[2]/g[2],i}function distance$2(i,m){var g=m[0]-i[0],x=m[1]-i[1],_=m[2]-i[2];return Math.hypot(g,x,_)}function squaredDistance$2(i,m){var g=m[0]-i[0],x=m[1]-i[1],_=m[2]-i[2];return g*g+x*x+_*_}function squaredLength$4(i){var m=i[0],g=i[1],x=i[2];return m*m+g*g+x*x}function normalize$4(i,m){var g=m[0],x=m[1],_=m[2],b=g*g+x*x+_*_;return b>0&&(b=1/Math.sqrt(b)),i[0]=m[0]*b,i[1]=m[1]*b,i[2]=m[2]*b,i}function dot$4(i,m){return i[0]*m[0]+i[1]*m[1]+i[2]*m[2]}function cross$2(i,m,g){var x=m[0],_=m[1],b=m[2],y=g[0],T=g[1],w=g[2];return i[0]=_*w-b*T,i[1]=b*y-x*w,i[2]=x*T-_*y,i}function lerp$4(i,m,g,x){var _=m[0],b=m[1],y=m[2];return i[0]=_+x*(g[0]-_),i[1]=b+x*(g[1]-b),i[2]=y+x*(g[2]-y),i}function transformMat4$2(i,m,g){var x=m[0],_=m[1],b=m[2],y=g[3]*x+g[7]*_+g[11]*b+g[15];return y=y||1,i[0]=(g[0]*x+g[4]*_+g[8]*b+g[12])/y,i[1]=(g[1]*x+g[5]*_+g[9]*b+g[13])/y,i[2]=(g[2]*x+g[6]*_+g[10]*b+g[14])/y,i}var je,Ye=subtract$2,Ze=multiply$4,Je=divide$2,Qe=distance$2,et=squaredDistance$2,at=length$4,ht=squaredLength$4,ft=(je=create$4(),function(i,m,g,x,_,b){var y,T;for(m||(m=3),g||(g=0),T=x?Math.min(x*m+g,i.length):i.length,y=g;y<T;y+=m)je[0]=i[y],je[1]=i[y+1],je[2]=i[y+2],_(je,je,b),i[y]=je[0],i[y+1]=je[1],i[y+2]=je[2];return i}),gt=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i},angle:function(i,m){var g=i[0],x=i[1],_=i[2],b=m[0],y=m[1],T=m[2],w=Math.sqrt(g*g+x*x+_*_)*Math.sqrt(b*b+y*y+T*T),P=w&&dot$4(i,m)/w;return Math.acos(Math.min(Math.max(P,-1),1))},bezier:function(i,m,g,x,_,b){var y=1-b,T=y*y,w=b*b,P=T*y,$=3*b*T,H=3*w*y,z=w*b;return i[0]=m[0]*P+g[0]*$+x[0]*H+_[0]*z,i[1]=m[1]*P+g[1]*$+x[1]*H+_[1]*z,i[2]=m[2]*P+g[2]*$+x[2]*H+_[2]*z,i},ceil:function(i,m){return i[0]=Math.ceil(m[0]),i[1]=Math.ceil(m[1]),i[2]=Math.ceil(m[2]),i},clone:function(i){var g=new m(3);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g},copy:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i},create:create$4,cross:cross$2,dist:Qe,distance:distance$2,div:Je,divide:divide$2,dot:dot$4,equals:function(m,g){var x=m[0],_=m[1],b=m[2],y=g[0],T=g[1],w=g[2];return Math.abs(x-y)<=i*Math.max(1,Math.abs(x),Math.abs(y))&&Math.abs(_-T)<=i*Math.max(1,Math.abs(_),Math.abs(T))&&Math.abs(b-w)<=i*Math.max(1,Math.abs(b),Math.abs(w))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]},floor:function(i,m){return i[0]=Math.floor(m[0]),i[1]=Math.floor(m[1]),i[2]=Math.floor(m[2]),i},forEach:ft,fromValues:fromValues$4,hermite:function(i,m,g,x,_,b){var y=b*b,T=y*(2*b-3)+1,w=y*(b-2)+b,P=y*(b-1),$=y*(3-2*b);return i[0]=m[0]*T+g[0]*w+x[0]*P+_[0]*$,i[1]=m[1]*T+g[1]*w+x[1]*P+_[1]*$,i[2]=m[2]*T+g[2]*w+x[2]*P+_[2]*$,i},inverse:function(i,m){return i[0]=1/m[0],i[1]=1/m[1],i[2]=1/m[2],i},len:at,length:length$4,lerp:lerp$4,max:function(i,m,g){return i[0]=Math.max(m[0],g[0]),i[1]=Math.max(m[1],g[1]),i[2]=Math.max(m[2],g[2]),i},min:function(i,m,g){return i[0]=Math.min(m[0],g[0]),i[1]=Math.min(m[1],g[1]),i[2]=Math.min(m[2],g[2]),i},mul:Ze,multiply:multiply$4,negate:function(i,m){return i[0]=-m[0],i[1]=-m[1],i[2]=-m[2],i},normalize:normalize$4,random:function(i,m){m=m||1;var x=2*g()*Math.PI,_=2*g()-1,b=Math.sqrt(1-_*_)*m;return i[0]=Math.cos(x)*b,i[1]=Math.sin(x)*b,i[2]=_*m,i},rotateX:function(i,m,g,x){var _=[],b=[];return _[0]=m[0]-g[0],_[1]=m[1]-g[1],_[2]=m[2]-g[2],b[0]=_[0],b[1]=_[1]*Math.cos(x)-_[2]*Math.sin(x),b[2]=_[1]*Math.sin(x)+_[2]*Math.cos(x),i[0]=b[0]+g[0],i[1]=b[1]+g[1],i[2]=b[2]+g[2],i},rotateY:function(i,m,g,x){var _=[],b=[];return _[0]=m[0]-g[0],_[1]=m[1]-g[1],_[2]=m[2]-g[2],b[0]=_[2]*Math.sin(x)+_[0]*Math.cos(x),b[1]=_[1],b[2]=_[2]*Math.cos(x)-_[0]*Math.sin(x),i[0]=b[0]+g[0],i[1]=b[1]+g[1],i[2]=b[2]+g[2],i},rotateZ:function(i,m,g,x){var _=[],b=[];return _[0]=m[0]-g[0],_[1]=m[1]-g[1],_[2]=m[2]-g[2],b[0]=_[0]*Math.cos(x)-_[1]*Math.sin(x),b[1]=_[0]*Math.sin(x)+_[1]*Math.cos(x),b[2]=_[2],i[0]=b[0]+g[0],i[1]=b[1]+g[1],i[2]=b[2]+g[2],i},round:function(i,m){return i[0]=Math.round(m[0]),i[1]=Math.round(m[1]),i[2]=Math.round(m[2]),i},scale:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i},scaleAndAdd:function(i,m,g,x){return i[0]=m[0]+g[0]*x,i[1]=m[1]+g[1]*x,i[2]=m[2]+g[2]*x,i},set:set$4,sqrDist:et,sqrLen:ht,squaredDistance:squaredDistance$2,squaredLength:squaredLength$4,str:function(i){return"vec3("+i[0]+","+i[1]+","+i[2]+")"},sub:Ye,subtract:subtract$2,transformMat3:function(i,m,g){var x=m[0],_=m[1],b=m[2];return i[0]=x*g[0]+_*g[3]+b*g[6],i[1]=x*g[1]+_*g[4]+b*g[7],i[2]=x*g[2]+_*g[5]+b*g[8],i},transformMat4:transformMat4$2,transformQuat:function(i,m,g){var x=g[0],_=g[1],b=g[2],y=g[3],T=m[0],w=m[1],P=m[2],$=_*P-b*w,H=b*T-x*P,z=x*w-_*T,q=_*z-b*H,W=b*$-x*z,ye=x*H-_*$,Ge=2*y;return $*=Ge,H*=Ge,z*=Ge,q*=2,W*=2,ye*=2,i[0]=T+$+q,i[1]=w+H+W,i[2]=P+z+ye,i},zero:function(i){return i[0]=0,i[1]=0,i[2]=0,i}});function create$3(){var i=new m(4);return m!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0),i}function clone$3(i){var g=new m(4);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g}function fromValues$3(i,g,x,_){var b=new m(4);return b[0]=i,b[1]=g,b[2]=x,b[3]=_,b}function copy$3(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i}function set$3(i,m,g,x,_){return i[0]=m,i[1]=g,i[2]=x,i[3]=_,i}function add$3(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i}function subtract$1(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i[3]=m[3]-g[3],i}function multiply$3(i,m,g){return i[0]=m[0]*g[0],i[1]=m[1]*g[1],i[2]=m[2]*g[2],i[3]=m[3]*g[3],i}function divide$1(i,m,g){return i[0]=m[0]/g[0],i[1]=m[1]/g[1],i[2]=m[2]/g[2],i[3]=m[3]/g[3],i}function scale$3(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i}function distance$1(i,m){var g=m[0]-i[0],x=m[1]-i[1],_=m[2]-i[2],b=m[3]-i[3];return Math.hypot(g,x,_,b)}function squaredDistance$1(i,m){var g=m[0]-i[0],x=m[1]-i[1],_=m[2]-i[2],b=m[3]-i[3];return g*g+x*x+_*_+b*b}function length$3(i){var m=i[0],g=i[1],x=i[2],_=i[3];return Math.hypot(m,g,x,_)}function squaredLength$3(i){var m=i[0],g=i[1],x=i[2],_=i[3];return m*m+g*g+x*x+_*_}function normalize$3(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=g*g+x*x+_*_+b*b;return y>0&&(y=1/Math.sqrt(y)),i[0]=g*y,i[1]=x*y,i[2]=_*y,i[3]=b*y,i}function dot$3(i,m){return i[0]*m[0]+i[1]*m[1]+i[2]*m[2]+i[3]*m[3]}function lerp$3(i,m,g,x){var _=m[0],b=m[1],y=m[2],T=m[3];return i[0]=_+x*(g[0]-_),i[1]=b+x*(g[1]-b),i[2]=y+x*(g[2]-y),i[3]=T+x*(g[3]-T),i}function exactEquals$3(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]}function equals$3(m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=g[0],w=g[1],P=g[2],$=g[3];return Math.abs(x-T)<=i*Math.max(1,Math.abs(x),Math.abs(T))&&Math.abs(_-w)<=i*Math.max(1,Math.abs(_),Math.abs(w))&&Math.abs(b-P)<=i*Math.max(1,Math.abs(b),Math.abs(P))&&Math.abs(y-$)<=i*Math.max(1,Math.abs(y),Math.abs($))}var xt=subtract$1,vt=multiply$3,bt=divide$1,yt=distance$1,Tt=squaredDistance$1,St=length$3,wt=squaredLength$3,Mt=function(){var i=create$3();return function(m,g,x,_,b,y){var T,w;for(g||(g=4),x||(x=0),w=_?Math.min(_*g+x,m.length):m.length,T=x;T<w;T+=g)i[0]=m[T],i[1]=m[T+1],i[2]=m[T+2],i[3]=m[T+3],b(i,i,y),m[T]=i[0],m[T+1]=i[1],m[T+2]=i[2],m[T+3]=i[3];return m}}(),Rt=Object.freeze({__proto__:null,add:add$3,ceil:function(i,m){return i[0]=Math.ceil(m[0]),i[1]=Math.ceil(m[1]),i[2]=Math.ceil(m[2]),i[3]=Math.ceil(m[3]),i},clone:clone$3,copy:copy$3,create:create$3,cross:function(i,m,g,x){var _=g[0]*x[1]-g[1]*x[0],b=g[0]*x[2]-g[2]*x[0],y=g[0]*x[3]-g[3]*x[0],T=g[1]*x[2]-g[2]*x[1],w=g[1]*x[3]-g[3]*x[1],P=g[2]*x[3]-g[3]*x[2],$=m[0],H=m[1],z=m[2],q=m[3];return i[0]=H*P-z*w+q*T,i[1]=-$*P+z*y-q*b,i[2]=$*w-H*y+q*_,i[3]=-$*T+H*b-z*_,i},dist:yt,distance:distance$1,div:bt,divide:divide$1,dot:dot$3,equals:equals$3,exactEquals:exactEquals$3,floor:function(i,m){return i[0]=Math.floor(m[0]),i[1]=Math.floor(m[1]),i[2]=Math.floor(m[2]),i[3]=Math.floor(m[3]),i},forEach:Mt,fromValues:fromValues$3,inverse:function(i,m){return i[0]=1/m[0],i[1]=1/m[1],i[2]=1/m[2],i[3]=1/m[3],i},len:St,length:length$3,lerp:lerp$3,max:function(i,m,g){return i[0]=Math.max(m[0],g[0]),i[1]=Math.max(m[1],g[1]),i[2]=Math.max(m[2],g[2]),i[3]=Math.max(m[3],g[3]),i},min:function(i,m,g){return i[0]=Math.min(m[0],g[0]),i[1]=Math.min(m[1],g[1]),i[2]=Math.min(m[2],g[2]),i[3]=Math.min(m[3],g[3]),i},mul:vt,multiply:multiply$3,negate:function(i,m){return i[0]=-m[0],i[1]=-m[1],i[2]=-m[2],i[3]=-m[3],i},normalize:normalize$3,random:function(i,m){var x,_,b,y,T,w;m=m||1;do{T=(x=2*g()-1)*x+(_=2*g()-1)*_}while(T>=1);do{w=(b=2*g()-1)*b+(y=2*g()-1)*y}while(w>=1);var P=Math.sqrt((1-T)/w);return i[0]=m*x,i[1]=m*_,i[2]=m*b*P,i[3]=m*y*P,i},round:function(i,m){return i[0]=Math.round(m[0]),i[1]=Math.round(m[1]),i[2]=Math.round(m[2]),i[3]=Math.round(m[3]),i},scale:scale$3,scaleAndAdd:function(i,m,g,x){return i[0]=m[0]+g[0]*x,i[1]=m[1]+g[1]*x,i[2]=m[2]+g[2]*x,i[3]=m[3]+g[3]*x,i},set:set$3,sqrDist:Tt,sqrLen:wt,squaredDistance:squaredDistance$1,squaredLength:squaredLength$3,str:function(i){return"vec4("+i[0]+","+i[1]+","+i[2]+","+i[3]+")"},sub:xt,subtract:subtract$1,transformMat4:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3];return i[0]=g[0]*x+g[4]*_+g[8]*b+g[12]*y,i[1]=g[1]*x+g[5]*_+g[9]*b+g[13]*y,i[2]=g[2]*x+g[6]*_+g[10]*b+g[14]*y,i[3]=g[3]*x+g[7]*_+g[11]*b+g[15]*y,i},transformQuat:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=g[0],T=g[1],w=g[2],P=g[3],$=P*x+T*b-w*_,H=P*_+w*x-y*b,z=P*b+y*_-T*x,q=-y*x-T*_-w*b;return i[0]=$*P+q*-y+H*-w-z*-T,i[1]=H*P+q*-T+z*-y-$*-w,i[2]=z*P+q*-w+$*-T-H*-y,i[3]=m[3],i},zero:function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=0,i}});function create$2(){var i=new m(4);return m!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i[3]=1,i}function setAxisAngle(i,m,g){g*=.5;var x=Math.sin(g);return i[0]=x*m[0],i[1]=x*m[1],i[2]=x*m[2],i[3]=Math.cos(g),i}function multiply$2(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=g[0],w=g[1],P=g[2],$=g[3];return i[0]=x*$+y*T+_*P-b*w,i[1]=_*$+y*w+b*T-x*P,i[2]=b*$+y*P+x*w-_*T,i[3]=y*$-x*T-_*w-b*P,i}function rotateX$1(i,m,g){g*=.5;var x=m[0],_=m[1],b=m[2],y=m[3],T=Math.sin(g),w=Math.cos(g);return i[0]=x*w+y*T,i[1]=_*w+b*T,i[2]=b*w-_*T,i[3]=y*w-x*T,i}function rotateY$1(i,m,g){g*=.5;var x=m[0],_=m[1],b=m[2],y=m[3],T=Math.sin(g),w=Math.cos(g);return i[0]=x*w-b*T,i[1]=_*w+y*T,i[2]=b*w+x*T,i[3]=y*w-_*T,i}function rotateZ$1(i,m,g){g*=.5;var x=m[0],_=m[1],b=m[2],y=m[3],T=Math.sin(g),w=Math.cos(g);return i[0]=x*w+_*T,i[1]=_*w-x*T,i[2]=b*w+y*T,i[3]=y*w-b*T,i}function exp(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=Math.sqrt(g*g+x*x+_*_),T=Math.exp(b),w=y>0?T*Math.sin(y)/y:0;return i[0]=g*w,i[1]=x*w,i[2]=_*w,i[3]=T*Math.cos(y),i}function ln(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=Math.sqrt(g*g+x*x+_*_),T=y>0?Math.atan2(y,b)/y:0;return i[0]=g*T,i[1]=x*T,i[2]=_*T,i[3]=.5*Math.log(g*g+x*x+_*_+b*b),i}function slerp(m,g,x,_){var b,y,T,w,P,$=g[0],H=g[1],z=g[2],q=g[3],W=x[0],ye=x[1],Ge=x[2],Ke=x[3];return(y=$*W+H*ye+z*Ge+q*Ke)<0&&(y=-y,W=-W,ye=-ye,Ge=-Ge,Ke=-Ke),1-y>i?(b=Math.acos(y),T=Math.sin(b),w=Math.sin((1-_)*b)/T,P=Math.sin(_*b)/T):(w=1-_,P=_),m[0]=w*$+P*W,m[1]=w*H+P*ye,m[2]=w*z+P*Ge,m[3]=w*q+P*Ke,m}function fromMat3(i,m){var g,x=m[0]+m[4]+m[8];if(x>0)g=Math.sqrt(x+1),i[3]=.5*g,g=.5/g,i[0]=(m[5]-m[7])*g,i[1]=(m[6]-m[2])*g,i[2]=(m[1]-m[3])*g;else{var _=0;m[4]>m[0]&&(_=1),m[8]>m[3*_+_]&&(_=2);var b=(_+1)%3,y=(_+2)%3;g=Math.sqrt(m[3*_+_]-m[3*b+b]-m[3*y+y]+1),i[_]=.5*g,g=.5/g,i[3]=(m[3*b+y]-m[3*y+b])*g,i[b]=(m[3*b+_]+m[3*_+b])*g,i[y]=(m[3*y+_]+m[3*_+y])*g}return i}var Pt,Ct,It,Et,Lt=clone$3,Bt=fromValues$3,Dt=copy$3,Ut=set$3,At=add$3,kt=multiply$2,Ot=scale$3,Nt=dot$3,Ft=lerp$3,Gt=length$3,Vt=Gt,$t=squaredLength$3,Ht=$t,zt=normalize$3,qt=exactEquals$3,Kt=equals$3,Wt=(Pt=create$4(),Ct=fromValues$4(1,0,0),It=fromValues$4(0,1,0),function(i,m,g){var x=dot$4(m,g);return x<-.999999?(cross$2(Pt,Ct,m),at(Pt)<1e-6&&cross$2(Pt,It,m),normalize$4(Pt,Pt),setAxisAngle(i,Pt,Math.PI),i):x>.999999?(i[0]=0,i[1]=0,i[2]=0,i[3]=1,i):(cross$2(Pt,m,g),i[0]=Pt[0],i[1]=Pt[1],i[2]=Pt[2],i[3]=1+x,zt(i,i))}),Xt=function(){var i=create$2(),m=create$2();return function(g,x,_,b,y,T){return slerp(i,x,y,T),slerp(m,_,b,T),slerp(g,i,m,2*T*(1-T)),g}}(),jt=(Et=create$6(),function(i,m,g,x){return Et[0]=g[0],Et[3]=g[1],Et[6]=g[2],Et[1]=x[0],Et[4]=x[1],Et[7]=x[2],Et[2]=-m[0],Et[5]=-m[1],Et[8]=-m[2],zt(i,fromMat3(i,Et))}),Yt=Object.freeze({__proto__:null,add:At,calculateW:function(i,m){var g=m[0],x=m[1],_=m[2];return i[0]=g,i[1]=x,i[2]=_,i[3]=Math.sqrt(Math.abs(1-g*g-x*x-_*_)),i},clone:Lt,conjugate:function(i,m){return i[0]=-m[0],i[1]=-m[1],i[2]=-m[2],i[3]=m[3],i},copy:Dt,create:create$2,dot:Nt,equals:Kt,exactEquals:qt,exp:exp,fromEuler:function(i,m,g,x){var _=.5*Math.PI/180;m*=_,g*=_,x*=_;var b=Math.sin(m),y=Math.cos(m),T=Math.sin(g),w=Math.cos(g),P=Math.sin(x),$=Math.cos(x);return i[0]=b*w*$-y*T*P,i[1]=y*T*$+b*w*P,i[2]=y*w*P-b*T*$,i[3]=y*w*$+b*T*P,i},fromMat3:fromMat3,fromValues:Bt,getAngle:function(i,m){var g=Nt(i,m);return Math.acos(2*g*g-1)},getAxisAngle:function(m,g){var x=2*Math.acos(g[3]),_=Math.sin(x/2);return _>i?(m[0]=g[0]/_,m[1]=g[1]/_,m[2]=g[2]/_):(m[0]=1,m[1]=0,m[2]=0),x},identity:function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i},invert:function(i,m){var g=m[0],x=m[1],_=m[2],b=m[3],y=g*g+x*x+_*_+b*b,T=y?1/y:0;return i[0]=-g*T,i[1]=-x*T,i[2]=-_*T,i[3]=b*T,i},len:Vt,length:Gt,lerp:Ft,ln:ln,mul:kt,multiply:multiply$2,normalize:zt,pow:function(i,m,g){return ln(i,m),Ot(i,i,g),exp(i,i),i},random:function(i){var m=g(),x=g(),_=g(),b=Math.sqrt(1-m),y=Math.sqrt(m);return i[0]=b*Math.sin(2*Math.PI*x),i[1]=b*Math.cos(2*Math.PI*x),i[2]=y*Math.sin(2*Math.PI*_),i[3]=y*Math.cos(2*Math.PI*_),i},rotateX:rotateX$1,rotateY:rotateY$1,rotateZ:rotateZ$1,rotationTo:Wt,scale:Ot,set:Ut,setAxes:jt,setAxisAngle:setAxisAngle,slerp:slerp,sqlerp:Xt,sqrLen:Ht,squaredLength:$t,str:function(i){return"quat("+i[0]+","+i[1]+","+i[2]+","+i[3]+")"}});function fromRotationTranslation(i,m,g){var x=.5*g[0],_=.5*g[1],b=.5*g[2],y=m[0],T=m[1],w=m[2],P=m[3];return i[0]=y,i[1]=T,i[2]=w,i[3]=P,i[4]=x*P+_*w-b*T,i[5]=_*P+b*y-x*w,i[6]=b*P+x*T-_*y,i[7]=-x*y-_*T-b*w,i}function copy$1(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i}var Zt=Dt;var Jt=Dt;function multiply$1(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=g[4],w=g[5],P=g[6],$=g[7],H=m[4],z=m[5],q=m[6],W=m[7],ye=g[0],Ge=g[1],Ke=g[2],Xe=g[3];return i[0]=x*Xe+y*ye+_*Ke-b*Ge,i[1]=_*Xe+y*Ge+b*ye-x*Ke,i[2]=b*Xe+y*Ke+x*Ge-_*ye,i[3]=y*Xe-x*ye-_*Ge-b*Ke,i[4]=x*$+y*T+_*P-b*w+H*Xe+W*ye+z*Ke-q*Ge,i[5]=_*$+y*w+b*T-x*P+z*Xe+W*Ge+q*ye-H*Ke,i[6]=b*$+y*P+x*w-_*T+q*Xe+W*Ke+H*Ge-z*ye,i[7]=y*$-x*T-_*w-b*P+W*Xe-H*ye-z*Ge-q*Ke,i}var Qt=multiply$1;var er=Nt;var tr=Gt,rr=tr,nr=$t,ir=nr;var ar=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i[4]=m[4]+g[4],i[5]=m[5]+g[5],i[6]=m[6]+g[6],i[7]=m[7]+g[7],i},clone:function(i){var g=new m(8);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g},conjugate:function(i,m){return i[0]=-m[0],i[1]=-m[1],i[2]=-m[2],i[3]=m[3],i[4]=-m[4],i[5]=-m[5],i[6]=-m[6],i[7]=m[7],i},copy:copy$1,create:function(){var i=new m(8);return m!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[4]=0,i[5]=0,i[6]=0,i[7]=0),i[3]=1,i},dot:er,equals:function(m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=g[0],z=g[1],q=g[2],W=g[3],ye=g[4],Ge=g[5],Ke=g[6],Xe=g[7];return Math.abs(x-H)<=i*Math.max(1,Math.abs(x),Math.abs(H))&&Math.abs(_-z)<=i*Math.max(1,Math.abs(_),Math.abs(z))&&Math.abs(b-q)<=i*Math.max(1,Math.abs(b),Math.abs(q))&&Math.abs(y-W)<=i*Math.max(1,Math.abs(y),Math.abs(W))&&Math.abs(T-ye)<=i*Math.max(1,Math.abs(T),Math.abs(ye))&&Math.abs(w-Ge)<=i*Math.max(1,Math.abs(w),Math.abs(Ge))&&Math.abs(P-Ke)<=i*Math.max(1,Math.abs(P),Math.abs(Ke))&&Math.abs($-Xe)<=i*Math.max(1,Math.abs($),Math.abs(Xe))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]&&i[4]===m[4]&&i[5]===m[5]&&i[6]===m[6]&&i[7]===m[7]},fromMat4:function(i,g){var x=create$2();getRotation(x,g);var _=new m(3);return getTranslation$1(_,g),fromRotationTranslation(i,x,_),i},fromRotation:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=0,i[5]=0,i[6]=0,i[7]=0,i},fromRotationTranslation:fromRotationTranslation,fromRotationTranslationValues:function(i,g,x,_,b,y,T){var w=new m(8);w[0]=i,w[1]=g,w[2]=x,w[3]=_;var P=.5*b,$=.5*y,H=.5*T;return w[4]=P*_+$*x-H*g,w[5]=$*_+H*i-P*x,w[6]=H*_+P*g-$*i,w[7]=-P*i-$*g-H*x,w},fromTranslation:function(i,m){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i[4]=.5*m[0],i[5]=.5*m[1],i[6]=.5*m[2],i[7]=0,i},fromValues:function(i,g,x,_,b,y,T,w){var P=new m(8);return P[0]=i,P[1]=g,P[2]=x,P[3]=_,P[4]=b,P[5]=y,P[6]=T,P[7]=w,P},getDual:function(i,m){return i[0]=m[4],i[1]=m[5],i[2]=m[6],i[3]=m[7],i},getReal:Zt,getTranslation:function(i,m){var g=m[4],x=m[5],_=m[6],b=m[7],y=-m[0],T=-m[1],w=-m[2],P=m[3];return i[0]=2*(g*P+b*y+x*w-_*T),i[1]=2*(x*P+b*T+_*y-g*w),i[2]=2*(_*P+b*w+g*T-x*y),i},identity:function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i[4]=0,i[5]=0,i[6]=0,i[7]=0,i},invert:function(i,m){var g=nr(m);return i[0]=-m[0]/g,i[1]=-m[1]/g,i[2]=-m[2]/g,i[3]=m[3]/g,i[4]=-m[4]/g,i[5]=-m[5]/g,i[6]=-m[6]/g,i[7]=m[7]/g,i},len:rr,length:tr,lerp:function(i,m,g,x){var _=1-x;return er(m,g)<0&&(x=-x),i[0]=m[0]*_+g[0]*x,i[1]=m[1]*_+g[1]*x,i[2]=m[2]*_+g[2]*x,i[3]=m[3]*_+g[3]*x,i[4]=m[4]*_+g[4]*x,i[5]=m[5]*_+g[5]*x,i[6]=m[6]*_+g[6]*x,i[7]=m[7]*_+g[7]*x,i},mul:Qt,multiply:multiply$1,normalize:function(i,m){var g=nr(m);if(g>0){g=Math.sqrt(g);var x=m[0]/g,_=m[1]/g,b=m[2]/g,y=m[3]/g,T=m[4],w=m[5],P=m[6],$=m[7],H=x*T+_*w+b*P+y*$;i[0]=x,i[1]=_,i[2]=b,i[3]=y,i[4]=(T-x*H)/g,i[5]=(w-_*H)/g,i[6]=(P-b*H)/g,i[7]=($-y*H)/g}return i},rotateAroundAxis:function(m,g,x,_){if(Math.abs(_)<i)return copy$1(m,g);var b=Math.hypot(x[0],x[1],x[2]);_*=.5;var y=Math.sin(_),T=y*x[0]/b,w=y*x[1]/b,P=y*x[2]/b,$=Math.cos(_),H=g[0],z=g[1],q=g[2],W=g[3];m[0]=H*$+W*T+z*P-q*w,m[1]=z*$+W*w+q*T-H*P,m[2]=q*$+W*P+H*w-z*T,m[3]=W*$-H*T-z*w-q*P;var ye=g[4],Ge=g[5],Ke=g[6],Xe=g[7];return m[4]=ye*$+Xe*T+Ge*P-Ke*w,m[5]=Ge*$+Xe*w+Ke*T-ye*P,m[6]=Ke*$+Xe*P+ye*w-Ge*T,m[7]=Xe*$-ye*T-Ge*w-Ke*P,m},rotateByQuatAppend:function(i,m,g){var x=g[0],_=g[1],b=g[2],y=g[3],T=m[0],w=m[1],P=m[2],$=m[3];return i[0]=T*y+$*x+w*b-P*_,i[1]=w*y+$*_+P*x-T*b,i[2]=P*y+$*b+T*_-w*x,i[3]=$*y-T*x-w*_-P*b,T=m[4],w=m[5],P=m[6],$=m[7],i[4]=T*y+$*x+w*b-P*_,i[5]=w*y+$*_+P*x-T*b,i[6]=P*y+$*b+T*_-w*x,i[7]=$*y-T*x-w*_-P*b,i},rotateByQuatPrepend:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=g[0],w=g[1],P=g[2],$=g[3];return i[0]=x*$+y*T+_*P-b*w,i[1]=_*$+y*w+b*T-x*P,i[2]=b*$+y*P+x*w-_*T,i[3]=y*$-x*T-_*w-b*P,T=g[4],w=g[5],P=g[6],$=g[7],i[4]=x*$+y*T+_*P-b*w,i[5]=_*$+y*w+b*T-x*P,i[6]=b*$+y*P+x*w-_*T,i[7]=y*$-x*T-_*w-b*P,i},rotateX:function(i,m,g){var x=-m[0],_=-m[1],b=-m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=T*y+$*x+w*b-P*_,z=w*y+$*_+P*x-T*b,q=P*y+$*b+T*_-w*x,W=$*y-T*x-w*_-P*b;return rotateX$1(i,m,g),x=i[0],_=i[1],b=i[2],y=i[3],i[4]=H*y+W*x+z*b-q*_,i[5]=z*y+W*_+q*x-H*b,i[6]=q*y+W*b+H*_-z*x,i[7]=W*y-H*x-z*_-q*b,i},rotateY:function(i,m,g){var x=-m[0],_=-m[1],b=-m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=T*y+$*x+w*b-P*_,z=w*y+$*_+P*x-T*b,q=P*y+$*b+T*_-w*x,W=$*y-T*x-w*_-P*b;return rotateY$1(i,m,g),x=i[0],_=i[1],b=i[2],y=i[3],i[4]=H*y+W*x+z*b-q*_,i[5]=z*y+W*_+q*x-H*b,i[6]=q*y+W*b+H*_-z*x,i[7]=W*y-H*x-z*_-q*b,i},rotateZ:function(i,m,g){var x=-m[0],_=-m[1],b=-m[2],y=m[3],T=m[4],w=m[5],P=m[6],$=m[7],H=T*y+$*x+w*b-P*_,z=w*y+$*_+P*x-T*b,q=P*y+$*b+T*_-w*x,W=$*y-T*x-w*_-P*b;return rotateZ$1(i,m,g),x=i[0],_=i[1],b=i[2],y=i[3],i[4]=H*y+W*x+z*b-q*_,i[5]=z*y+W*_+q*x-H*b,i[6]=q*y+W*b+H*_-z*x,i[7]=W*y-H*x-z*_-q*b,i},scale:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i[4]=m[4]*g,i[5]=m[5]*g,i[6]=m[6]*g,i[7]=m[7]*g,i},set:function(i,m,g,x,_,b,y,T,w){return i[0]=m,i[1]=g,i[2]=x,i[3]=_,i[4]=b,i[5]=y,i[6]=T,i[7]=w,i},setDual:function(i,m){return i[4]=m[0],i[5]=m[1],i[6]=m[2],i[7]=m[3],i},setReal:Jt,sqrLen:ir,squaredLength:nr,str:function(i){return"quat2("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+","+i[6]+","+i[7]+")"},translate:function(i,m,g){var x=m[0],_=m[1],b=m[2],y=m[3],T=.5*g[0],w=.5*g[1],P=.5*g[2],$=m[4],H=m[5],z=m[6],q=m[7];return i[0]=x,i[1]=_,i[2]=b,i[3]=y,i[4]=y*T+_*P-b*w+$,i[5]=y*w+b*T-x*P+H,i[6]=y*P+x*w-_*T+z,i[7]=-x*T-_*w-b*P+q,i}});function create(){var i=new m(2);return m!=Float32Array&&(i[0]=0,i[1]=0),i}function subtract(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i}function multiply(i,m,g){return i[0]=m[0]*g[0],i[1]=m[1]*g[1],i}function divide(i,m,g){return i[0]=m[0]/g[0],i[1]=m[1]/g[1],i}function distance(i,m){var g=m[0]-i[0],x=m[1]-i[1];return Math.hypot(g,x)}function squaredDistance(i,m){var g=m[0]-i[0],x=m[1]-i[1];return g*g+x*x}function length(i){var m=i[0],g=i[1];return Math.hypot(m,g)}function squaredLength(i){var m=i[0],g=i[1];return m*m+g*g}function lerp(i,m,g,x){var _=m[0],b=m[1];return i[0]=_+x*(g[0]-_),i[1]=b+x*(g[1]-b),i}var sr=length,or=subtract,ur=multiply,lr=divide,cr=distance,hr=squaredDistance,fr=squaredLength,dr=function(){var i=create();return function(m,g,x,_,b,y){var T,w;for(g||(g=2),x||(x=0),w=_?Math.min(_*g+x,m.length):m.length,T=x;T<w;T+=g)i[0]=m[T],i[1]=m[T+1],b(i,i,y),m[T]=i[0],m[T+1]=i[1];return m}}(),mr=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i},angle:function(i,m){var g=i[0],x=i[1],_=m[0],b=m[1],y=Math.sqrt(g*g+x*x)*Math.sqrt(_*_+b*b),T=y&&(g*_+x*b)/y;return Math.acos(Math.min(Math.max(T,-1),1))},ceil:function(i,m){return i[0]=Math.ceil(m[0]),i[1]=Math.ceil(m[1]),i},clone:function(i){var g=new m(2);return g[0]=i[0],g[1]=i[1],g},copy:function(i,m){return i[0]=m[0],i[1]=m[1],i},create:create,cross:function(i,m,g){var x=m[0]*g[1]-m[1]*g[0];return i[0]=i[1]=0,i[2]=x,i},dist:cr,distance:distance,div:lr,divide:divide,dot:function(i,m){return i[0]*m[0]+i[1]*m[1]},equals:function(m,g){var x=m[0],_=m[1],b=g[0],y=g[1];return Math.abs(x-b)<=i*Math.max(1,Math.abs(x),Math.abs(b))&&Math.abs(_-y)<=i*Math.max(1,Math.abs(_),Math.abs(y))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]},floor:function(i,m){return i[0]=Math.floor(m[0]),i[1]=Math.floor(m[1]),i},forEach:dr,fromValues:function(i,g){var x=new m(2);return x[0]=i,x[1]=g,x},inverse:function(i,m){return i[0]=1/m[0],i[1]=1/m[1],i},len:sr,length:length,lerp:lerp,max:function(i,m,g){return i[0]=Math.max(m[0],g[0]),i[1]=Math.max(m[1],g[1]),i},min:function(i,m,g){return i[0]=Math.min(m[0],g[0]),i[1]=Math.min(m[1],g[1]),i},mul:ur,multiply:multiply,negate:function(i,m){return i[0]=-m[0],i[1]=-m[1],i},normalize:function(i,m){var g=m[0],x=m[1],_=g*g+x*x;return _>0&&(_=1/Math.sqrt(_)),i[0]=m[0]*_,i[1]=m[1]*_,i},random:function(i,m){m=m||1;var x=2*g()*Math.PI;return i[0]=Math.cos(x)*m,i[1]=Math.sin(x)*m,i},rotate:function(i,m,g,x){var _=m[0]-g[0],b=m[1]-g[1],y=Math.sin(x),T=Math.cos(x);return i[0]=_*T-b*y+g[0],i[1]=_*y+b*T+g[1],i},round:function(i,m){return i[0]=Math.round(m[0]),i[1]=Math.round(m[1]),i},scale:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i},scaleAndAdd:function(i,m,g,x){return i[0]=m[0]+g[0]*x,i[1]=m[1]+g[1]*x,i},set:function(i,m,g){return i[0]=m,i[1]=g,i},sqrDist:hr,sqrLen:fr,squaredDistance:squaredDistance,squaredLength:squaredLength,str:function(i){return"vec2("+i[0]+","+i[1]+")"},sub:or,subtract:subtract,transformMat2:function(i,m,g){var x=m[0],_=m[1];return i[0]=g[0]*x+g[2]*_,i[1]=g[1]*x+g[3]*_,i},transformMat2d:function(i,m,g){var x=m[0],_=m[1];return i[0]=g[0]*x+g[2]*_+g[4],i[1]=g[1]*x+g[3]*_+g[5],i},transformMat3:function(i,m,g){var x=m[0],_=m[1];return i[0]=g[0]*x+g[3]*_+g[6],i[1]=g[1]*x+g[4]*_+g[7],i},transformMat4:function(i,m,g){var x=m[0],_=m[1];return i[0]=g[0]*x+g[4]*_+g[12],i[1]=g[1]*x+g[5]*_+g[13],i},zero:function(i){return i[0]=0,i[1]=0,i}}),pr=Object.freeze({__proto__:null,glMatrix:_,mat2:T,mat2d:$,mat3:q,mat4:Xe,quat:Yt,quat2:ar,vec2:mr,vec3:gt,vec4:Rt});class InstanceIdGenerator{static idMaps=new Map;static getNextId(i){let m=this.idMaps.get(i)||0;return this.idMaps.set(i,m+1),m}}Object.freeze(InstanceIdGenerator);class Camera2D{#e;#t=create$5();#r=0;#n=0;#i=0;#a;constructor(){}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get modelMatrix(){return this.#t}get z(){return this.#i}get x(){return this.#r}set x(i){this.#r=i,this.#t[12]=i}get y(){return this.#n}set y(i){this.#n=i,this.#t[13]=i}get position(){return[this.#r,this.#n]}setPosition(i,m){Array.isArray(i)?[this.#r,this.#n]=i:(this.#r=i,this.#n=m),[this.#t[12],this.#t[13],this.#t[14]]=[this.#r,this.#n,0]}}const consoleAndThrowError=(...i)=>{const m=Array.prototype.slice.call(i).join(" ");throw new Error(m)},validateNumber=i=>"number"==typeof i||(consoleAndThrowError("Only numbers allowed."),!1);class PerspectiveCamera{#e;#s=new Float32Array([0,1,0]);#t=create$5();#r=0;#i=0;#n=0;#o=0;#u=0;#l=0;#c=60;#h=.01;#f=1e4;#a;constructor(){}get rotationX(){return this.#o}set rotationX(i){this.#o=i}get rotationY(){return this.#u}set rotationY(i){this.#u=i}get rotationZ(){return this.#l}set rotationZ(i){this.#l=i}get fieldOfView(){return this.#c}set fieldOfView(i){validateNumber(i),this.#c=i}get nearClipping(){return this.#h}set nearClipping(i){validateNumber(i),this.#h=i}get farClipping(){return this.#f}set farClipping(i){validateNumber(i),this.#f=i}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get modelMatrix(){return this.#t}get x(){return this.#r}set x(i){this.#r=i,this.#t[12]=i}get y(){return this.#n}set y(i){this.#n=i,this.#t[13]=i}get z(){return this.#i}set z(i){this.#i=i,this.#t[14]=i}get position(){return[this.#r,this.#n,this.#i]}setPosition(i,m,g){Array.isArray(i)?[this.#r,this.#n,this.#i]=i:(this.#r=i,this.#n=m,this.#i=g),[this.#t[12],this.#t[13],this.#t[14]]=[this.#r,this.#n,this.#i]}lookAt(i,m,g){lookAt(this.#t,[this.#r,this.#n,this.#i],[i,m,g],this.#s)}}class OrthographicCamera extends PerspectiveCamera{#e;#a;#d=1;#m=-1;#p=-1;#g=1;constructor(){super(),this.nearClipping=.01,this.farClipping=2e3}get top(){return this.#d}set top(i){validateNumber(i),this.#d=i}get bottom(){return this.#m}set bottom(i){validateNumber(i),this.#m=i}get left(){return this.#p}set left(i){validateNumber(i),this.#p=i}get right(){return this.#g}set right(i){validateNumber(i),this.#g=i}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}}const gltfAnimationLooper_rotation=(m,g,x,_,b,y,T,w,P,$,H)=>{let z,q,W,ye,Ge,Ke,Xe,je,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt,vt,bt,yt,Tt,St,wt,Mt,Rt,Pt=!0;if("CUBICSPLINE"==m)y!=_-1?(Rt=12*y,yt=x[Rt+4],Tt=x[Rt+5],St=x[Rt+6],wt=x[Rt+7],Mt=yt*yt+Tt*Tt+St*St+wt*wt,Mt>0&&(Mt=1/Math.sqrt(Mt)),Ye=yt*Mt,Ze=Tt*Mt,Je=St*Mt,Qe=wt*Mt,yt=x[Rt+8],Tt=x[Rt+9],St=x[Rt+10],wt=x[Rt+11],Mt=yt*yt+Tt*Tt+St*St+wt*wt,Mt>0&&(Mt=1/Math.sqrt(Mt)),et=yt*Mt,at=Tt*Mt,ht=St*Mt,ft=wt*Mt,yt=x[Rt],Tt=x[Rt+1],St=x[Rt+2],wt=x[Rt+3],Mt=yt*yt+Tt*Tt+St*St+wt*wt,Mt>0&&(Mt=1/Math.sqrt(Mt)),Ge=yt*Mt,Ke=Tt*Mt,Xe=St*Mt,je=wt*Mt,Rt=12*T,yt=x[Rt+4],Tt=x[Rt+5],St=x[Rt+6],wt=x[Rt+7],Mt=yt*yt+Tt*Tt+St*St+wt*wt,Mt>0&&(Mt=1/Math.sqrt(Mt)),z=yt*Mt,q=Tt*Mt,W=St*Mt,ye=wt*Mt,gt=Ye,xt=et*b,vt=z,bt=Ge*b,yt=w*gt+P*xt+$*vt+H*bt,gt=Ze,xt=at*b,vt=q,bt=Ke*b,Tt=w*gt+P*xt+$*vt+H*bt,gt=Je,xt=ht*b,vt=W,bt=Xe*b,St=w*gt+P*xt+$*vt+H*bt,gt=Qe,xt=ft*b,vt=ye,bt=je*b,wt=w*gt+P*xt+$*vt+H*bt):Pt=!1;else{let m,g,_,w,P;Rt=4*y,yt=x[Rt],Tt=x[Rt+1],St=x[Rt+2],wt=x[Rt+3],Mt=yt*yt+Tt*Tt+St*St+wt*wt,Mt>0&&(Mt=1/Math.sqrt(Mt)),Ye=yt*Mt,Ze=Tt*Mt,Je=St*Mt,Qe=wt*Mt,Rt=4*T,yt=x[Rt],Tt=x[Rt+1],St=x[Rt+2],wt=x[Rt+3],Mt=yt*yt+Tt*Tt+St*St+wt*wt,Mt>0&&(Mt=1/Math.sqrt(Mt)),z=yt*Mt,q=Tt*Mt,W=St*Mt,ye=wt*Mt,g=Ye*z+Ze*q+Je*W+Qe*ye,g<0&&(g=-g,z=-z,q=-q,W=-W,ye=-ye),1-g>i?(m=Math.acos(g),_=Math.sin(m),w=Math.sin((1-b)*m)/_,P=Math.sin(b*m)/_):(w=1-b,P=b),yt=w*Ye+P*z,Tt=w*Ze+P*q,St=w*Je+P*W,wt=w*Qe+P*ye}if(Pt){let i=[],m=[0,0,0],x=yt+yt,_=Tt+Tt,b=St+St,y=yt*x,T=yt*_,w=yt*b,P=Tt*_,$=Tt*b,H=St*b,z=wt*x,q=wt*_,W=wt*b;i[0]=1-(P+H),i[4]=T-W,i[8]=w+q,i[1]=T+W,i[5]=1-(y+H),i[9]=$-z,i[2]=w-q,i[6]=$+z,i[10]=1-(y+P),i[3]=0,i[7]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1;let ye=i[0],Ge=i[4],Ke=i[8],Xe=i[5],je=i[9],Ye=i[6],Ze=i[10];m[1]=Math.asin(Math.max(-1,Math.min(1,Ke))),Math.abs(Ke)<.99999?(m[0]=Math.atan2(-je,Ze),m[2]=Math.atan2(-Ge,ye)):(m[0]=Math.atan2(Ye,Xe),m[2]=0),m[0]=-180*m[0]/Math.PI,m[1]=-180*m[1]/Math.PI,m[2]=-180*m[2]/Math.PI,g.rotationX=m[0],g.rotationY=m[1],g.rotationZ=m[2]}},gltfAnimationLooper_scale=(i,m,g,x,_,b,y,T,w,P,$)=>{let H,z,q,W,ye,Ge,Ke,Xe,je,Ye,Ze,Je,Qe,et,at,ht,ft;"CUBICSPLINE"==i?b!=x-1&&(ft=9*b,H=g[ft+3],z=g[ft+4],q=g[ft+5],Ye=g[ft+6],Ze=g[ft+7],Je=g[ft+8],ft=9*y,W=g[ft+0],ye=g[ft+1],Ge=g[ft+2],Ke=g[ft+3],Xe=g[ft+4],je=g[ft+5],Qe=Ke,et=Ye*_,at=H,ht=W*_,m.scaleX=T*Qe+w*et+P*at+$*ht,Qe=Xe,et=Ze*_,at=z,ht=ye*_,m.scaleY=T*Qe+w*et+P*at+$*ht,Qe=je,et=Je*_,at=q,ht=Ge*_,m.scaleZ=T*Qe+w*et+P*at+$*ht):(ft=3*y,H=g[ft],z=g[ft+1],q=g[ft+2],ft=3*b,Ke=g[ft],Xe=g[ft+1],je=g[ft+2],m.scaleX=Ke+_*(H-Ke),m.scaleY=Xe+_*(z-Xe),m.scaleZ=je+_*(q-je))},gltfAnimationLooper_transition=(i,m,g,x,_,b,y,T,w,P,$)=>{let H,z,q,W,ye,Ge,Ke,Xe,je,Ye,Ze,Je,Qe,et,at,ht,ft;"CUBICSPLINE"==i?b!=x-1&&(ft=9*b,H=g[ft+3],z=g[ft+4],q=g[ft+5],Ye=g[ft+6],Ze=g[ft+7],Je=g[ft+8],ft=9*y,W=g[ft+0],ye=g[ft+1],Ge=g[ft+2],Ke=g[ft+3],Xe=g[ft+4],je=g[ft+5],Qe=Ke,et=Ye*_,at=H,ht=W*_,m.x=T*Qe+w*et+P*at+$*ht,Qe=Xe,et=Ze*_,at=z,ht=ye*_,m.y=T*Qe+w*et+P*at+$*ht,Qe=je,et=Je*_,at=q,ht=Ge*_,m.z=T*Qe+w*et+P*at+$*ht):(ft=3*y,H=g[ft],z=g[ft+1],q=g[ft+2],ft=3*b,Ke=g[ft],Xe=g[ft+1],je=g[ft+2],m.x=Ke+_*(H-Ke),m.y=Xe+_*(z-Xe),m.z=je+_*(q-je))},gltfAnimationLooper_weight=(i,m,g,x,_)=>{let b,y,T,w,P,$,H,z,q,W,ye,Ge,Ke,Xe,je,Ye,Ze,Je,Qe,et,at,ht;const ft=9999991;for(b=i.length;b--;){let gt;for(y=i[b],T=y.geometry.vertexBuffer.data,P=y.geometry.vertexBuffer.stride,H=T.length/P,Ye=y.animationInfo.morphInfo,w=Ye.origin,Ze=Ye.morphInfoDataList,je=Ze.length,$=0;$<H;$++){Xe=$*P;let i=Xe*ft+x*ft+_;if(ht=Ye.cacheData[i],ht)[z,q,W,ye,Ge,Ke]=ht;else{for(z=w[Xe],q=w[Xe],W=w[Xe+1],ye=w[Xe+1],Ge=w[Xe+2],Ke=w[Xe+2],Je=je;Je--;)Qe=m[x*je+Je],et=m[_*je+Je],at=Ze[Je].interleaveData,gt=at[Xe],z+=Qe*gt,q+=et*gt,gt=at[Xe+1],W+=Qe*gt,ye+=et*gt,gt=at[Xe+2],Ge+=Qe*gt,Ke+=et*gt;Ye.cacheData[i]=[z,q,W,ye,Ge,Ke]}T[Xe]=z+g*(q-z),T[Xe+1]=W+g*(ye-W),T[Xe+2]=Ge+g*(Ke-Ge)}y.geometry.vertexBuffer.updateAllData(T)}};class VertexGPURenderInfo{vertexShaderModule;vertexStructInfo;vertexUniformInfo;vertexBindGroupLayout;vertexUniformBindGroup;vertexUniformBuffer;pipeline;shadowPipeline;pickingPipeline;constructor(i,m,g,x,_,b,y,T){this.vertexShaderModule=i,this.vertexUniformInfo=m,this.vertexBindGroupLayout=g,this.vertexUniformBindGroup=_,this.vertexUniformBuffer=x,this.pipeline=b,this.shadowPipeline=y,this.pickingPipeline=T}}Object.freeze(VertexGPURenderInfo);const defineProperty=(i,m,g,x,..._)=>{Object.defineProperty(i.prototype,m,g(m,x,..._))},defineProperties=i=>(m,g)=>{g.forEach(g=>{if(Array.isArray(g)){const[x,_,...b]=g;defineProperty(m,x,i,_,...b)}else defineProperty(m,g,i)})},createDefineByPreset=i=>{const m={};return Object.keys(i).forEach(g=>{const[x,_]=i[g];Object.assign(m,(i=>m=>m.reduce((m,g)=>({...m,[g]:i}),{}))(x)(Object.values(_)))}),{defineByPreset:(i,g)=>((i,m,g)=>{m.forEach(m=>{if(Array.isArray(m)){const[x,_,...b]=m,y=g[x];y||consoleAndThrowError(x,"is a key not defined in Define Preset."),defineProperty(i,x,y,_,...b)}else{const x=g[m];x||consoleAndThrowError(m,"is a key not defined in Define Preset."),defineProperty(i,m,x)}})})(i,g,m)}},gr={enumerable:!0,configurable:!1};function createSetter$5(i,m,g){return function(x){this[m]=x;const{gpuRenderInfo:_}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=_;g.writeBuffer(m.members[i],x?1:0)}else if(_){const{vertexUniformInfo:m,vertexUniformBuffer:g}=_;g.writeBuffer(m.members[i],x?1:0)}}}function defineBoolean(i,m=!1,g=!0){const x=Symbol(i);return{get:function(){return void 0===this[x]&&(this[x]=m),this[x]},set:createSetter$5(i,x,g),...gr}}Object.freeze(gr),Object.freeze(defineBoolean);const validatePositiveNumberRange=(i,m=0,g=Number.MAX_VALUE)=>("number"!=typeof i&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof m&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof g&&consoleAndThrowError("Only numbers allowed."),(m<0||i<0||i<m||i>g)&&consoleAndThrowError(`Only numbers within the range of [${m},${g}] are allowed.`),!0);function createSetter$4(i,m,g,x=0,_){return function(b){void 0!==x&&b<x&&(console.warn(`Value for ${i} is below the minimum (${x}). Received:${b}. Adjusted to ${x}.`),b=x),void 0!==_&&b>_&&(console.warn(`Value for ${i} exceeds the maximum (${_}). Received:${b}. Adjusted to ${_}.`),b=_),validatePositiveNumberRange(b),this[m]=b;const{gpuRenderInfo:y}=this;if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=y;x.writeBuffer(g.members[i],this[m])}else if(y){const{vertexUniformInfo:g,vertexUniformBuffer:x}=y;x.writeBuffer(g.members[i],this[m])}}}function definePositiveNumberRange(i,m=1,g=!0,x=0,_){const b=Symbol(i);return{get:function(){return void 0===this[b]&&(this[b]=m),this[b]},set:createSetter$4(i,b,g,x,_),...gr}}Object.freeze(definePositiveNumberRange);const isUint=i=>Number.isInteger(i)&&i>=0,validateUintRange=(i,m=0,g=4503599627370496)=>{const x=isUint(i),_=isUint(m),b=isUint(g),y="is not Uint!/value:",T=`(check range:${m}u ~ ${g}u)`;return x||consoleAndThrowError(`value ${y}${i}/${T}`),_||consoleAndThrowError(`min ${y}${m}/${T}`),b||consoleAndThrowError(`max ${y}${g}/${T}`),m>=g&&consoleAndThrowError(`maximum value is bigger than minimum value./${T}`),m>i&&consoleAndThrowError(`value is smaller than minimum value./value:${i}/${T}`),g<i&&consoleAndThrowError(`value is bigger than maximum value./value:${i}/${T}`),!0};function createSetter$3(i,m,g,x=0,_){return function(b){validateUintRange(b),void 0!==x&&b<x&&(console.warn(`Value for ${i} is below the minimum (${x}). Received:${b}. Adjusted to ${x}.`),b=x),void 0!==_&&b>_&&(console.warn(`Value for ${i} exceeds the maximum (${_}). Received:${b}. Adjusted to ${_}.`),b=_),this[m]=b;const{gpuRenderInfo:y}=this;if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=y;x.writeBuffer(g.members[i],this[m])}else if(y){const{vertexUniformInfo:g,vertexUniformBuffer:x}=y;x.writeBuffer(g.members[i],this[m])}}}function defineUintRange(i,m=0,g=!0,x=0,_){const b=Symbol(i);return{get:function(){return void 0===this[b]&&(this[b]=m),this[b]},set:createSetter$3(i,b,g,x,_),...gr}}function defineProperty_boolean(i,m=!1){return defineBoolean(i,m,!1)}function defineProperty_uintRange(i,m=0,g,x){return defineUintRange(i,m,!1,g,x)}function defineProperty_PositiveNumberRange(i,m=0,g,x){return definePositiveNumberRange(i,m,!1,g,x)}Object.freeze(defineUintRange);const xr={USE_BILLBOARD_PERSPECTIVE:"useBillboardPerspective",USE_BILLBOARD:"useBillboard",RECEIVE_SHADOW:"receiveShadow"},_r={BILLBOARD_FIXED_SCALE:"billboardFixedScale"},vr={},br={...createDefineByPreset({defineBoolean:[defineProperty_boolean,xr],defineUint:[defineProperty_uintRange,vr],definePositiveNumber:[defineProperty_PositiveNumberRange,_r]}),defineBoolean:defineProperties(defineProperty_boolean),defineUint:defineProperties(defineProperty_uintRange),definePositiveNumber:defineProperties(defineProperty_PositiveNumberRange),PRESET_BOOLEAN:xr,PRESET_POSITIVE_NUMBER:_r,PRESET_UINT:vr,PRESET_SAMPLER:{},PRESET_TEXTURE:{},PRESET_CUBE_TEXTURE:{},PRESET_VEC2:{},PRESET_VEC3:{},PRESET_VEC4:{},PRESET_COLOR_RGB:{}};Object.freeze(br);const mat4ToEuler=(i,m,g)=>{m=m||[0,0,0],g=g||"XYZ";let x=i[0],_=i[4],b=i[8],y=i[1],T=i[5],w=i[9],P=i[2],$=i[6],H=i[10];return"XYZ"===g?(m[1]=Math.asin(clamp(b,-1,1)),Math.abs(b)<.99999?(m[0]=Math.atan2(-w,H),m[2]=Math.atan2(-_,x)):(m[0]=Math.atan2($,T),m[2]=0)):"YXZ"===g?(m[0]=Math.asin(-clamp(w,-1,1)),Math.abs(w)<.99999?(m[1]=Math.atan2(b,H),m[2]=Math.atan2(y,T)):(m[1]=Math.atan2(-P,x),m[2]=0)):"ZXY"===g?(m[0]=Math.asin(clamp($,-1,1)),Math.abs($)<.99999?(m[1]=Math.atan2(-P,H),m[2]=Math.atan2(-_,T)):(m[1]=0,m[2]=Math.atan2(y,x))):"ZYX"===g?(m[1]=Math.asin(-clamp(P,-1,1)),Math.abs(P)<.99999?(m[0]=Math.atan2($,H),m[2]=Math.atan2(y,x)):(m[0]=0,m[2]=Math.atan2(-_,T))):"YZX"===g?(m[2]=Math.asin(clamp(y,-1,1)),Math.abs(y)<.99999?(m[0]=Math.atan2(-w,T),m[1]=Math.atan2(-P,x)):(m[0]=0,m[1]=Math.atan2(b,H))):"XZY"===g&&(m[2]=Math.asin(-clamp(_,-1,1)),Math.abs(_)<.99999?(m[0]=Math.atan2($,T),m[1]=Math.atan2(b,x)):(m[0]=Math.atan2(-w,H),m[1]=0)),m};let clamp=function(i,m,g){return Math.max(m,Math.min(g,i))};const calculateMeshAABB=i=>{const m=i._geometry.volume;if(!m)return null;const{minX:g,maxX:x,minY:_,maxY:b,minZ:y,maxZ:T}=m;let w=1/0,P=1/0,$=1/0,H=-1/0,z=-1/0,q=-1/0;[[g,_,y],[x,_,y],[x,b,y],[g,b,y],[g,_,T],[x,_,T],[x,b,T],[g,b,T]].forEach(m=>{const g=fromValues$4(m[0],m[1],m[2]),x=create$4();transformMat4$2(x,g,i.modelMatrix),w=Math.min(w,x[0]),P=Math.min(P,x[1]),$=Math.min($,x[2]),H=Math.max(H,x[0]),z=Math.max(z,x[1]),q=Math.max(q,x[2])});const W=(H+w)/2,ye=(z+P)/2,Ge=(q+$)/2,Ke=H-w,Xe=z-P,je=q-$,Ye=Math.sqrt((Ke/2)**2+(Xe/2)**2+(je/2)**2);return{minX:w,maxX:H,minY:P,maxY:z,minZ:$,maxZ:q,centerX:W,centerY:ye,centerZ:Ge,xSize:Ke,ySize:Xe,zSize:je,geometryRadius:Ye}},calculateMeshOBB=i=>{const m=i._geometry.volume;if(!m)return null;const g=[m.centerX,m.centerY,m.centerZ],x=[(m.maxX-m.minX)/2,(m.maxY-m.minY)/2,(m.maxZ-m.minZ)/2],_=create$4();transformMat4$2(_,g,i.modelMatrix);const b=create$5();copy$5(b,i.modelMatrix),b[12]=0,b[13]=0,b[14]=0;const y=[create$4(),create$4(),create$4()],T=[0,0,0];for(let i=0;i<3;i++){const m=[0,0,0];m[i]=x[i],transformMat4$2(y[i],m,b),T[i]=length$4(y[i]),normalize$4(y[i],y[i])}const w=create$5();return w[0]=y[0][0],w[1]=y[0][1],w[2]=y[0][2],w[3]=0,w[4]=y[1][0],w[5]=y[1][1],w[6]=y[1][2],w[7]=0,w[8]=y[2][0],w[9]=y[2][1],w[10]=y[2][2],w[11]=0,w[12]=0,w[13]=0,w[14]=0,w[15]=1,{center:[_[0],_[1],_[2]],halfExtents:T,orientation:w}},uuidToUint=i=>{const m=i.replace(/-/g,"").substring(0,8);return parseInt(m,16)};class GeometryGPURenderInfo{buffers;constructor(i){this.buffers=i}}Object.freeze(GeometryGPURenderInfo);const validateRedGPUContext=i=>{if("RedGPUContext"!==i?.constructor?.name){return consoleAndThrowError(`from ${i?.constructor?.name}:requires a RedGPUContext instance,but received:${i}`),!1}return!0},createUUID=()=>{const i="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");let m,g=0,x=["","","","","-","","","","-","4","","","-","","","","-","","","","","","-","","","","","","","","","","","",""];for(;g<36;)""===x[g]&&(m=16*Math.random()|0,x[g]=i[19===g?3&m|8:15&m]),g++;return x.join("")};class ResourceBase{#x=createUUID();#_;#v;#a="";#e;#b=[];constructor(i){validateRedGPUContext(i),this.#_=i,this.#v=i.gpuDevice}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get uuid(){return this.#x}get gpuDevice(){return this.#v}get redGPUContext(){return this.#_}__addDirtyPipelineListener(i){this.#y(!0),this.#b.push(i)}__removeDirtyPipelineListener(i){const m=this.#b.indexOf(i);m>-1&&(this.#b.splice(m,1),this.#y(!1))}__fireListenerList(i=!1){for(const i of this.#b)i(this);i&&(this.#b.length=0)}#y(i){const{resourceManager:m}=this.#_;if(m){const g=m[`managed${this.constructor.name}State`]?.table?.[this.#x];g&&(i?g.useNum++:g.useNum--)}}}const calculateGeometryAABB=i=>{const m=i.stride,g=i.data;let x=i.vertexCount,_=1/0,b=1/0,y=1/0,T=-1/0,w=-1/0,P=-1/0,$=0;for(;$<=x-4;$+=4){let i=$*m;const x=g[i],H=g[i+1],z=g[i+2];i=($+1)*m;const q=g[i],W=g[i+1],ye=g[i+2];i=($+2)*m;const Ge=g[i],Ke=g[i+1],Xe=g[i+2];i=($+3)*m;const je=g[i],Ye=g[i+1],Ze=g[i+2];_=Math.min(x,q,Ge,je,_),b=Math.min(H,W,Ke,Ye,b),y=Math.min(z,ye,Xe,Ze,y),T=Math.max(x,q,Ge,je,T),w=Math.max(H,W,Ke,Ye,w),P=Math.max(z,ye,Xe,Ze,P)}for(;$<x;$++){let i=$*m;const x=g[i],H=g[i+1],z=g[i+2];_=Math.min(x,_),b=Math.min(H,b),y=Math.min(z,y),T=Math.max(x,T),w=Math.max(H,w),P=Math.max(z,P)}const H=(T+_)/2,z=(w+b)/2,q=(P+y)/2,W=Math.max(Math.abs(_),Math.abs(T)),ye=Math.max(Math.abs(b),Math.abs(w)),Ge=Math.max(Math.abs(y),Math.abs(P));return{minX:_,maxX:T,minY:b,maxY:w,minZ:y,maxZ:P,centerX:H,centerY:z,centerZ:q,xSize:W,ySize:ye,zSize:Ge,geometryRadius:Math.max(W,ye,Ge)}};class Geometry extends ResourceBase{gpuRenderInfo;#T;#S;#w;constructor(i,m,g){super(i),this.#M(m),this.#R(g);const{interleavedStruct:x}=this.#T;this.gpuRenderInfo=new GeometryGPURenderInfo([{arrayStride:x.arrayStride,attributes:x.attributes}])}get vertexBuffer(){return this.#T}get indexBuffer(){return this.#S}get volume(){return this.#w||(this.#w=calculateGeometryAABB(this.#T)),this.#w}#M(i){const m=this.#T;this.#T=i,m&&m.__removeDirtyPipelineListener(this.#P),i&&i.__addDirtyPipelineListener(this.#P),this.#w=null}#R(i){const m=this.#S;this.#S=i,m&&m.__removeDirtyPipelineListener(this.#C),i&&i.__addDirtyPipelineListener(this.#C)}#P(){this.__fireListenerList()}#C(){this.__fireListenerList()}}Object.freeze(Geometry);const yr={POINT_LIST:"point-list",LINE_LIST:"line-list",LINE_STRIP:"line-strip",TRIANGLE_LIST:"triangle-list",TRIANGLE_STRIP:"triangle-strip"};Object.freeze(yr);const isHexColor=i=>{const m=/^([A-Fa-f0-9]{3}){1,2}$/;return i.startsWith("#")?m.test(i.substring(1)):!!i.startsWith("0x")&&m.test(i.substring(2))},convertHexToRgb=(i,m=!1)=>{if("number"==typeof i&&(i=`#${i.toString(16)}`),isHexColor(i)){"#"===i.charAt(0)&&(i=i.substring(1)),3===i.length&&(i=i.charAt(0)+i.charAt(0)+i.charAt(1)+i.charAt(1)+i.charAt(2)+i.charAt(2));const g=parseInt("0x"+i),x=g>>16&255,_=g>>8&255,b=255&g;return m?[x,_,b]:{r:x,g:_,b:b}}throw Error(`from ${convertHexToRgb.constructor.name}:input value - ${i}/Only hex string allowed`)},convertRgbToHex=(i,m,g)=>{validateUintRange(i,0,255),validateUintRange(m,0,255),validateUintRange(g,0,255);return`#${i.toString(16).padStart(2,"0").toUpperCase()}${m.toString(16).padStart(2,"0").toUpperCase()}${g.toString(16).padStart(2,"0").toUpperCase()}`};class ColorRGB{#I;#E;#L;#B;constructor(i=255,m=255,g=255,x=void 0){this.#D(i,m,g),this.#U(i,m,g),x&&(this.#B=x)}get r(){return this.#I}set r(i){validateUintRange(i,0,255),this.#I=i,this.#B?.()}get g(){return this.#E}set g(i){validateUintRange(i,0,255),this.#E=i,this.#B?.()}get b(){return this.#L}set b(i){validateUintRange(i,0,255),this.#L=i,this.#B?.()}get rgb(){return[this.#I,this.#E,this.#L]}get rgbNormal(){return[this.#I/255,this.#E/255,this.#L/255]}get hex(){return convertRgbToHex(this.#I,this.#E,this.#L)}setColorByRGB(i,m,g){this.#D(i,m,g),this.#U(i,m,g)}setColorByHEX(i){const{r:m,g:g,b:x}=convertHexToRgb(i);this.#U(m,g,x)}setColorByRGBString(i){const m=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(i);m||consoleAndThrowError(`Invalid rgb color value:${i}`);const[,g,x,_]=m.map(Number);this.#D(g,x,_),this.#U(g,x,_)}#U(i,m,g){this.#I=i,this.#E=m,this.#L=g,this.#B?.()}#D(i,m,g){validateUintRange(i,0,255),validateUintRange(m,0,255),validateUintRange(g,0,255)}}function defineColorRGB(i,m="#fff",g=!0){const x=Symbol(i);return{get:function(){if(void 0===this[x]){let _=255,b=255,y=255;if(isHexColor(m)){const i=convertHexToRgb(m);_=i.r,b=i.g,y=i.b}this[x]=new ColorRGB(_,b,y,()=>{const{gpuRenderInfo:m}=this;if(m)if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:_}=m;_.writeBuffer(g.members[i],this[x].rgbNormal)}else{const{vertexUniformInfo:g,vertexUniformBuffer:_}=m;_.writeBuffer(g.members[i],this[x].rgbNormal)}})}return this[x]},...gr}}Object.freeze(defineColorRGB);class ColorRGBA extends ColorRGB{#A;#B;constructor(i=255,m=255,g=255,x=1,_=void 0){super(i,m,g,_),validatePositiveNumberRange(x,0,1),this.#A=x,_&&(this.#B=_)}get a(){return this.#A}set a(i){validatePositiveNumberRange(i,0,1),this.#A=i,this.#B?.()}get rgba(){return[this.r,this.g,this.b,this.#A]}get rgbaNormal(){return[this.r/255,this.g/255,this.b/255,this.#A]}setColorByRGBA(i,m,g,x){this.#k(i,m,g,x),this.r=i,this.g=m,this.b=g,this.#A=x,this.#B?.()}setColorByRGBAString(i){const m=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d*(?:\.\d+)?)\s*\)/.exec(i);if(!m)throw new Error(`Invalid rgba color value:${i}`);const[,g,x,_,b]=m.map(Number);this.#k(g,x,_,b),this.r=g,this.g=x,this.b=_,this.#A=b,this.#B?.()}#k(i,m,g,x){validateUintRange(i,0,255),validateUintRange(m,0,255),validateUintRange(g,0,255),validatePositiveNumberRange(x,0,1)}}function defineColorRGBA(i,m="#fff",g=!0){const x=Symbol(i);return{get:function(){if(void 0===this[x]){let _=255,b=255,y=255,T=1;if(isHexColor(m)){const i=convertHexToRgb(m);_=i.r,b=i.g,y=i.b}this[x]=new ColorRGBA(_,b,y,T,()=>{const{gpuRenderInfo:m}=this;if(m)if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:_}=m;_.writeBuffer(g.members[i],this[x].rgbaNormal)}else{const{vertexUniformInfo:g,vertexUniformBuffer:_}=m;_.writeBuffer(g.members[i],this[x].rgbaNormal)}})}return this[x]},...gr}}function createSetter$2(i,m,g){const x=`use${i.charAt(0).toUpperCase()}${i.substring(1)}`;return function(i){const _=this[m];this[m]=i,this.updateTexture(_,i);const{gpuRenderInfo:b}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=b;m.members[x]&&g.writeBuffer(m.members[x],i?1:0)}else if(b){const{vertexUniformInfo:m,vertexUniformBuffer:g}=b;m.members[x]&&g.writeBuffer(g.members[x],i?1:0)}}}function defineCubeTexture(i,m=!0){const g=Symbol(i);return{get:function(){return this[g]},set:createSetter$2(i,g,m),...gr}}function defineSampler(i){const m=Symbol(i);return{get:function(){return this[m]},set:function(i){const g=this[m];this[m]=i,this.updateSampler(g,i)},...gr}}function createSetter$1(i,m,g){const x=`use${i.charAt(0).toUpperCase()}${i.substring(1)}`,_=`premultiply${i.charAt(0).toUpperCase()}${i.substring(1)}`;return function(i){const b=this[m];this[m]=i,this.updateTexture(b,i);const{gpuRenderInfo:y}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=y;m.members[x]&&g.writeBuffer(m.members[x],i?1:0),m.members[_]&&g.writeBuffer(m.members[_],i?.usePremultiplyAlpha?1:0)}else if(y){const{vertexUniformInfo:m,vertexUniformBuffer:g}=y;m.members[x]&&g.writeBuffer(g.members[x],i?1:0)}}}function defineTexture$1(i,m=!0){const g=Symbol(i);return{get:function(){return this[g]},set:createSetter$1(i,g,m),...gr}}function createSetter(i,m,g){return function(x){this[m]=x;const{gpuRenderInfo:_}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=_;g.writeBuffer(m.members[i],x)}else if(_){const{vertexUniformInfo:m,vertexUniformBuffer:g}=_;g.writeBuffer(m.members[i],x)}}}function defineVector(i,m,g=!0){const x=Symbol(i);return{get:function(){return void 0===this[x]&&(this[x]=m),this[x]},set:createSetter(i,x,g),...gr}}function defineProperty_vec4(i,m=[0,0,0,0]){return defineVector(i,m)}function defineProperty_vec3(i,m=[0,0,0]){return defineVector(i,m)}function defineProperty_vec2(i,m=[0,0]){return defineVector(i,m)}Object.freeze(defineColorRGBA),Object.freeze(defineCubeTexture),Object.freeze(defineSampler),Object.freeze(defineTexture$1),Object.freeze(defineVector);const Tr={},Sr={AO_STRENGTH:"aoStrength",SPECULAR_STRENGTH:"specularStrength",EMISSIVE_STRENGTH:"emissiveStrength",OPACITY:"opacity",SHININESS:"shininess",NORMAL_SCALE:"normalScale"},wr={},Mr={ALPHA_TEXTURE_SAMPLER:"alphaTextureSampler",AO_TEXTURE_SAMPLER:"aoTextureSampler",DIFFUSE_TEXTURE_SAMPLER:"diffuseTextureSampler",EMISSIVE_TEXTURE_SAMPLER:"emissiveTextureSampler",ENVIRONMENT_TEXTURE_SAMPLER:"environmentTextureSampler",NORMAL_TEXTURE_SAMPLER:"normalTextureSampler",SPECULAR_TEXTURE_SAMPLER:"specularTextureSampler"},Rr={ENVIRONMENT_TEXTURE:"environmentTexture"},Pr={},Cr={},Ir={},Er={ALPHA_TEXTURE:"alphaTexture",AO_TEXTURE:"aoTexture",DIFFUSE_TEXTURE:"diffuseTexture",EMISSIVE_TEXTURE:"emissiveTexture",NORMAL_TEXTURE:"normalTexture",SPECULAR_TEXTURE:"specularTexture"},Lr={COLOR:"color",EMISSIVE_COLOR:"emissiveColor",SPECULAR_COLOR:"specularColor"},Br={...createDefineByPreset({defineBoolean:[defineBoolean,Tr],definePositiveNumber:[definePositiveNumberRange,Sr],defineUint:[defineUintRange,wr],defineVec2:[defineProperty_vec2,Pr],defineVec3:[defineProperty_vec3,Cr],defineVec4:[defineProperty_vec4,Ir],defineColorRGB:[defineColorRGB,Lr],defineSampler:[defineSampler,Mr],defineTexture:[defineTexture$1,Er],defineCubeTexture:[defineCubeTexture,Rr]}),defineBoolean:defineProperties(defineBoolean),definePositiveNumber:defineProperties(definePositiveNumberRange),defineUint:defineProperties(defineUintRange),defineVec2:defineProperties(defineProperty_vec2),defineVec3:defineProperties(defineProperty_vec3),defineVec4:defineProperties(defineProperty_vec4),defineColorRGB:defineProperties(defineColorRGB),defineColorRGBA:defineProperties(defineColorRGBA),defineSampler:defineProperties(defineSampler),defineTexture:defineProperties(defineTexture$1),defineCubeTexture:defineProperties(defineCubeTexture),PRESET_BOOLEAN:Tr,PRESET_POSITIVE_NUMBER:Sr,PRESET_UINT:wr,PRESET_SAMPLER:Mr,PRESET_TEXTURE:Er,PRESET_CUBE_TEXTURE:Rr,PRESET_VEC2:Pr,PRESET_VEC3:Cr,PRESET_VEC4:Ir,PRESET_COLOR_RGB:Lr};Object.freeze(Br);class e{constructor(i,m){this.name=i,this.attributes=m,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}get isPointer(){return!1}getTypeName(){return this.name}}class t{constructor(i,m,g){this.name=i,this.type=m,this.attributes=g,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class n extends e{constructor(i,m){super(i,m),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}}class s extends e{constructor(i,m){super(i,m),this.count=0,this.stride=0}get isArray(){return!0}getTypeName(){return`array<${this.format.getTypeName()},${this.count}>`}}class r extends e{constructor(i,m,g){super(i,g),this.format=m}get isPointer(){return!0}getTypeName(){return`&${this.format.getTypeName()}`}}class a extends e{constructor(i,m,g,x){super(i,g),this.format=m,this.access=x}get isTemplate(){return!0}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}}var Dr;(i=>{i[i.Uniform=0]="Uniform",i[i.Storage=1]="Storage",i[i.Texture=2]="Texture",i[i.Sampler=3]="Sampler",i[i.StorageTexture=4]="StorageTexture"})(Dr||(Dr={}));class o{constructor(i,m,g,x,_,b,y){this.name=i,this.type=m,this.group=g,this.binding=x,this.attributes=_,this.resourceType=b,this.access=y}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class l{constructor(i,m){this.name=i,this.type=m}}class c{constructor(i,m,g,x){this.name=i,this.type=m,this.locationType=g,this.location=x,this.interpolation=null}}class u{constructor(i,m,g,x){this.name=i,this.type=m,this.locationType=g,this.location=x}}class h{constructor(i,m,g,x){this.name=i,this.type=m,this.attributes=g,this.id=x}}class f{constructor(i,m,g){this.name=i,this.type=m,this.attributes=g}}class p{constructor(i,m=null,g){this.stage=null,this.inputs=[],this.outputs=[],this.arguments=[],this.returnType=null,this.resources=[],this.overrides=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=i,this.stage=m,this.attributes=g}}class d{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}const Ur=new Float32Array(1),Ar=new Int32Array(Ur.buffer),kr=new Uint16Array(1);function x$1(i){Ur[0]=i;const m=Ar[0],g=m>>31&1;let x=m>>23&255,_=8388607&m;if(255===x)return kr[0]=g<<15|31744|(0!==_?512:0),kr[0];if(0===x){if(0===_)return kr[0]=g<<15,kr[0];_|=8388608;let i=113;for(;!(8388608&_);)_<<=1,i--;return x=127-i,_&=8388607,x>0?(_=(_>>126-x)+(_>>127-x&1),kr[0]=g<<15|x<<10|_>>13,kr[0]):(kr[0]=g<<15,kr[0])}return x=x-127+15,x>=31?(kr[0]=g<<15|31744,kr[0]):x<=0?x<-10?(kr[0]=g<<15,kr[0]):(_=(8388608|_)>>1-x,kr[0]=g<<15|_>>13,kr[0]):(_>>=13,kr[0]=g<<15|x<<10|_,kr[0])}const Or=new Uint32Array(1),Nr=new Float32Array(Or.buffer,0,1);function v(i){const m=112+(i>>6&31)<<23|(63&i)<<17;return Or[0]=m,Nr[0]}function k(i,m,g,x){const _=[0,0,0,0];for(let P=0;P<x;++P)switch(g){case"8unorm":_[P]=i[m]/255,m++;break;case"8snorm":_[P]=i[m]/255*2-1,m++;break;case"8uint":_[P]=i[m],m++;break;case"8sint":_[P]=i[m]-127,m++;break;case"16uint":_[P]=i[m]|i[m+1]<<8,m+=2;break;case"16sint":_[P]=(i[m]|i[m+1]<<8)-32768,m+=2;break;case"16float":_[P]=(void 0,void 0,void 0,y=(32768&(b=i[m]|i[m+1]<<8))>>15,w=1023&b,0==(T=(31744&b)>>10)?(y?-1:1)*Math.pow(2,-14)*(w/Math.pow(2,10)):31==T?w?NaN:1/0*(y?-1:1):(y?-1:1)*Math.pow(2,T-15)*(1+w/Math.pow(2,10))),m+=2;break;case"32uint":case"32sint":_[P]=i[m]|i[m+1]<<8|i[m+2]<<16|i[m+3]<<24,m+=4;break;case"32float":_[P]=new Float32Array(i.buffer,m,1)[0],m+=4}var b,y,T,w;return _}function I(i,m,g,x,_){for(let b=0;b<x;++b)switch(g){case"8unorm":i[m]=255*_[b],m++;break;case"8snorm":i[m]=.5*(_[b]+1)*255,m++;break;case"8uint":i[m]=_[b],m++;break;case"8sint":i[m]=_[b]+127,m++;break;case"16uint":new Uint16Array(i.buffer,m,1)[0]=_[b],m+=2;break;case"16sint":new Int16Array(i.buffer,m,1)[0]=_[b],m+=2;break;case"16float":{const g=x$1(_[b]);new Uint16Array(i.buffer,m,1)[0]=g,m+=2;break}case"32uint":new Uint32Array(i.buffer,m,1)[0]=_[b],m+=4;break;case"32sint":new Int32Array(i.buffer,m,1)[0]=_[b],m+=4;break;case"32float":new Float32Array(i.buffer,m,1)[0]=_[b],m+=4}return _}const Fr={r8unorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8snorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8uint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8sint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg8unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8snorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"rgba8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8snorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},bgra8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bgra8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r16uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16float:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg16uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba16uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r32uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg32uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba32uint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32sint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32float:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rg11b10ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},stencil8:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!1,hasStencil:!0,channels:1},depth16unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},depth24plus:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,depthOnlyFormat:"depth32float",channels:1},"depth24plus-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,depthOnlyFormat:"depth32float",channels:1},depth32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},"depth32float-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,stencilOnlyFormat:"depth32float",channels:1},rgb9e5ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bc1-rgba-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc1-rgba-unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc4-r-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc4-r-snorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc5-rg-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc5-rg-snorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc6h-rgb-ufloat":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc6h-rgb-float":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"eac-r11unorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-r11snorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-rg11unorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"eac-rg11snorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"astc-4x4-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-4x4-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x5-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-5x5-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x6-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-6x6-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-8x5-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x5-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x6-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x6-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x8-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-8x8-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-10x5-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x5-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x6-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x6-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x8-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x8-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x10-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-10x10-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x12-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4},"astc-12x12-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4}};class S{constructor(){this.id=S._id++,this.line=0}get isAstNode(){return!0}get astNodeType(){return""}search(i){i(this)}searchBlock(i,m){if(i){m(A.instance);for(const g of i)g instanceof Array?this.searchBlock(g,m):g.search(m);m(E.instance)}}constEvaluate(i,m){throw new Error("Cannot evaluate node")}constEvaluateString(i){return this.constEvaluate(i).toString()}}S._id=0;class A extends S{}A.instance=new A;class E extends S{}E.instance=new E;const Gr=new Set(["all","all","any","select","arrayLength","abs","acos","acosh","asin","asinh","atan","atanh","atan2","ceil","clamp","cos","cosh","countLeadingZeros","countOneBits","countTrailingZeros","cross","degrees","determinant","distance","dot","dot4U8Packed","dot4I8Packed","exp","exp2","extractBits","faceForward","firstLeadingBit","firstTrailingBit","floor","fma","fract","frexp","insertBits","inverseSqrt","ldexp","length","log","log2","max","min","mix","modf","normalize","pow","quantizeToF16","radians","reflect","refract","reverseBits","round","saturate","sign","sin","sinh","smoothStep","sqrt","step","tan","tanh","transpose","trunc","dpdx","dpdxCoarse","dpdxFine","dpdy","dpdyCoarse","dpdyFine","fwidth","fwidthCoarse","fwidthFine","textureDimensions","textureGather","textureGatherCompare","textureLoad","textureNumLayers","textureNumLevels","textureNumSamples","textureSample","textureSampleBias","textureSampleCompare","textureSampleCompareLevel","textureSampleGrad","textureSampleLevel","textureSampleBaseClampToEdge","textureStore","atomicLoad","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","atomicExchange","atomicCompareExchangeWeak","pack4x8snorm","pack4x8unorm","pack4xI8","pack4xU8","pack4x8Clamp","pack4xU8Clamp","pack2x16snorm","pack2x16unorm","pack2x16float","unpack4x8snorm","unpack4x8unorm","unpack4xI8","unpack4xU8","unpack2x16snorm","unpack2x16unorm","unpack2x16float","storageBarrier","textureBarrier","workgroupBarrier","workgroupUniformLoad","subgroupAdd","subgroupExclusiveAdd","subgroupInclusiveAdd","subgroupAll","subgroupAnd","subgroupAny","subgroupBallot","subgroupBroadcast","subgroupBroadcastFirst","subgroupElect","subgroupMax","subgroupMin","subgroupMul","subgroupExclusiveMul","subgroupInclusiveMul","subgroupOr","subgroupShuffle","subgroupShuffleDown","subgroupShuffleUp","subgroupShuffleXor","subgroupXor","quadBroadcast","quadSwapDiagonal","quadSwapX","quadSwapY"]);class L extends S{constructor(){super()}}class C extends L{constructor(i,m,g,x,_,b){super(),this.calls=new Set,this.name=i,this.args=m,this.returnType=g,this.body=x,this.startLine=_,this.endLine=b}get astNodeType(){return"function"}search(i){if(this.attributes)for(const m of this.attributes)i(m);i(this);for(const m of this.args)i(m);this.searchBlock(this.body,i)}}class D extends L{constructor(i){super(),this.expression=i}get astNodeType(){return"staticAssert"}search(i){this.expression.search(i)}}class N extends L{constructor(i,m){super(),this.condition=i,this.body=m}get astNodeType(){return"while"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}}class V extends L{constructor(i,m){super(),this.body=i,this.loopId=m}get astNodeType(){return"continuing"}search(i){this.searchBlock(this.body,i)}}class O extends L{constructor(i,m,g,x){super(),this.init=i,this.condition=m,this.increment=g,this.body=x}get astNodeType(){return"for"}search(i){var m,g,x;null===(m=this.init)||void 0===m||m.search(i),null===(g=this.condition)||void 0===g||g.search(i),null===(x=this.increment)||void 0===x||x.search(i),this.searchBlock(this.body,i)}}class B extends L{constructor(i,m,g,x,_){super(),this.attributes=null,this.name=i,this.type=m,this.storage=g,this.access=x,this.value=_}get astNodeType(){return"var"}search(i){var m;i(this),null===(m=this.value)||void 0===m||m.search(i)}}class F extends L{constructor(i,m,g){super(),this.attributes=null,this.name=i,this.type=m,this.value=g}get astNodeType(){return"override"}search(i){var m;null===(m=this.value)||void 0===m||m.search(i)}}class M extends L{constructor(i,m,g,x,_){super(),this.attributes=null,this.name=i,this.type=m,this.storage=g,this.access=x,this.value=_}get astNodeType(){return"let"}search(i){var m;i(this),null===(m=this.value)||void 0===m||m.search(i)}}class U extends L{constructor(i,m,g,x,_){super(),this.attributes=null,this.name=i,this.type=m,this.storage=g,this.access=x,this.value=_}get astNodeType(){return"const"}constEvaluate(i,m){return this.value.constEvaluate(i,m)}search(i){var m;i(this),null===(m=this.value)||void 0===m||m.search(i)}}var Vr,$r,Hr,zr;(i=>{i.increment="++",i.decrement="--"})(Vr||(Vr={})),(i=>{i.parse=function(m){const g=m;if("parse"==g)throw new Error("Invalid value for IncrementOperator");return i[g]}})(Vr||(Vr={}));let qr=class extends L{constructor(i,m){super(),this.operator=i,this.variable=m}get astNodeType(){return"increment"}search(i){this.variable.search(i)}};(i=>{i.assign="=",i.addAssign="+=",i.subtractAssin="-=",i.multiplyAssign="*=",i.divideAssign="/=",i.moduloAssign="%=",i.andAssign="&=",i.orAssign="|=",i.xorAssign="^=",i.shiftLeftAssign="<<=",i.shiftRightAssign=">>="})($r||($r={})),($r||($r={})).parse=function(i){const m=i;if("parse"==m)throw new Error("Invalid value for AssignOperator");return m};class R extends L{constructor(i,m,g){super(),this.operator=i,this.variable=m,this.value=g}get astNodeType(){return"assign"}search(i){this.variable.search(i),this.value.search(i)}}class G extends L{constructor(i,m){super(),this.name=i,this.args=m}get astNodeType(){return"call"}isBuiltin(){return Gr.has(this.name)}search(i){for(const m of this.args)m.search(i);i(this)}}class X extends L{constructor(i,m){super(),this.body=i,this.continuing=m}get astNodeType(){return"loop"}}class j extends L{constructor(i,m){super(),this.condition=i,this.cases=m}get astNodeType(){return"switch"}search(i){i(this);for(const m of this.cases)m.search(i)}}class Z extends L{constructor(i,m,g,x){super(),this.condition=i,this.body=m,this.elseif=g,this.else=x}get astNodeType(){return"if"}search(i){this.condition.search(i),this.searchBlock(this.body,i),this.searchBlock(this.elseif,i),this.searchBlock(this.else,i)}}class Q extends L{constructor(i){super(),this.value=i}get astNodeType(){return"return"}search(i){var m;null===(m=this.value)||void 0===m||m.search(i)}}class Y extends L{constructor(i){super(),this.name=i}get astNodeType(){return"enable"}}class K extends L{constructor(i){super(),this.extensions=i}get astNodeType(){return"requires"}}class J extends L{constructor(i,m){super(),this.severity=i,this.rule=m}get astNodeType(){return"diagnostic"}}class ee extends L{constructor(i,m){super(),this.name=i,this.type=m}get astNodeType(){return"alias"}}class te extends L{constructor(){super()}get astNodeType(){return"discard"}}class ne extends L{constructor(){super(),this.condition=null,this.loopId=-1}get astNodeType(){return"break"}}class se extends L{constructor(){super(),this.loopId=-1}get astNodeType(){return"continue"}}class re extends L{constructor(i){super(),this.attributes=null,this.name=i}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}static maxFormatType(i){let m=i[0];if("f32"===m.name)return m;for(let g=1;g<i.length;++g){const x=re._priority.get(m.name);re._priority.get(i[g].name)<x&&(m=i[g])}return"x32"===m.name?re.i32:m}getTypeName(){return this.name}}re.x32=new re("x32"),re.f32=new re("f32"),re.i32=new re("i32"),re.u32=new re("u32"),re.f16=new re("f16"),re.bool=new re("bool"),re.void=new re("void"),re._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class ae extends re{constructor(i){super(i)}}class ie extends re{constructor(i,m,g,x){super(i),this.members=m,this.startLine=g,this.endLine=x}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(i){for(let m=0;m<this.members.length;m++)if(this.members[m].name==i)return m;return-1}search(i){for(const m of this.members)i(m)}}class oe extends re{constructor(i,m,g){super(i),this.format=m,this.access=g}get astNodeType(){return"template"}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}}oe.vec2f=new oe("vec2",re.f32,null),oe.vec3f=new oe("vec3",re.f32,null),oe.vec4f=new oe("vec4",re.f32,null),oe.vec2i=new oe("vec2",re.i32,null),oe.vec3i=new oe("vec3",re.i32,null),oe.vec4i=new oe("vec4",re.i32,null),oe.vec2u=new oe("vec2",re.u32,null),oe.vec3u=new oe("vec3",re.u32,null),oe.vec4u=new oe("vec4",re.u32,null),oe.vec2h=new oe("vec2",re.f16,null),oe.vec3h=new oe("vec3",re.f16,null),oe.vec4h=new oe("vec4",re.f16,null),oe.vec2b=new oe("vec2",re.bool,null),oe.vec3b=new oe("vec3",re.bool,null),oe.vec4b=new oe("vec4",re.bool,null),oe.mat2x2f=new oe("mat2x2",re.f32,null),oe.mat2x3f=new oe("mat2x3",re.f32,null),oe.mat2x4f=new oe("mat2x4",re.f32,null),oe.mat3x2f=new oe("mat3x2",re.f32,null),oe.mat3x3f=new oe("mat3x3",re.f32,null),oe.mat3x4f=new oe("mat3x4",re.f32,null),oe.mat4x2f=new oe("mat4x2",re.f32,null),oe.mat4x3f=new oe("mat4x3",re.f32,null),oe.mat4x4f=new oe("mat4x4",re.f32,null),oe.mat2x2h=new oe("mat2x2",re.f16,null),oe.mat2x3h=new oe("mat2x3",re.f16,null),oe.mat2x4h=new oe("mat2x4",re.f16,null),oe.mat3x2h=new oe("mat3x2",re.f16,null),oe.mat3x3h=new oe("mat3x3",re.f16,null),oe.mat3x4h=new oe("mat3x4",re.f16,null),oe.mat4x2h=new oe("mat4x2",re.f16,null),oe.mat4x3h=new oe("mat4x3",re.f16,null),oe.mat4x4h=new oe("mat4x4",re.f16,null),oe.mat2x2i=new oe("mat2x2",re.i32,null),oe.mat2x3i=new oe("mat2x3",re.i32,null),oe.mat2x4i=new oe("mat2x4",re.i32,null),oe.mat3x2i=new oe("mat3x2",re.i32,null),oe.mat3x3i=new oe("mat3x3",re.i32,null),oe.mat3x4i=new oe("mat3x4",re.i32,null),oe.mat4x2i=new oe("mat4x2",re.i32,null),oe.mat4x3i=new oe("mat4x3",re.i32,null),oe.mat4x4i=new oe("mat4x4",re.i32,null),oe.mat2x2u=new oe("mat2x2",re.u32,null),oe.mat2x3u=new oe("mat2x3",re.u32,null),oe.mat2x4u=new oe("mat2x4",re.u32,null),oe.mat3x2u=new oe("mat3x2",re.u32,null),oe.mat3x3u=new oe("mat3x3",re.u32,null),oe.mat3x4u=new oe("mat3x4",re.u32,null),oe.mat4x2u=new oe("mat4x2",re.u32,null),oe.mat4x3u=new oe("mat4x3",re.u32,null),oe.mat4x4u=new oe("mat4x4",re.u32,null);class le extends re{constructor(i,m,g,x){super(i),this.storage=m,this.type=g,this.access=x}get astNodeType(){return"pointer"}}class ce extends re{constructor(i,m,g,x){super(i),this.attributes=m,this.format=g,this.count=x}get astNodeType(){return"array"}get isArray(){return!0}}class ue extends re{constructor(i,m,g){super(i),this.format=m,this.access=g}get astNodeType(){return"sampler"}}class he extends S{constructor(){super(),this.postfix=null}}class fe extends he{constructor(i){super(),this.value=i}get astNodeType(){return"stringExpr"}toString(){return this.value}constEvaluateString(){return this.value}}class pe extends he{constructor(i,m){super(),this.type=i,this.args=m}get astNodeType(){return"createExpr"}search(i){if(i(this),this.args)for(const m of this.args)m.search(i)}constEvaluate(i,m){return m&&(m[0]=this.type),i.evalExpression(this,i.context)}}class de extends he{constructor(i,m){super(),this.cachedReturnValue=null,this.name=i,this.args=m}get astNodeType(){return"callExpr"}setCachedReturnValue(i){this.cachedReturnValue=i}get isBuiltin(){return Gr.has(this.name)}constEvaluate(i,m){return i.evalExpression(this,i.context)}search(i){for(const m of this.args)m.search(i);i(this)}}class me extends he{constructor(i){super(),this.name=i}get astNodeType(){return"varExpr"}search(i){i(this),this.postfix&&this.postfix.search(i)}constEvaluate(i,m){return i.evalExpression(this,i.context)}}class _e extends he{constructor(i,m){super(),this.name=i,this.initializer=m}get astNodeType(){return"constExpr"}constEvaluate(i,m){if(this.initializer){const m=i.evalExpression(this.initializer,i.context);return null!==m&&this.postfix?m.getSubData(i,this.postfix,i.context):m}return null}search(i){this.initializer.search(i)}}class ge extends he{constructor(i,m){super(),this.value=i,this.type=m}get astNodeType(){return"literalExpr"}constEvaluate(i,m){return void 0!==m&&(m[0]=this.type),this.value}get isScalar(){return this.value instanceof Oe}get isVector(){return this.value instanceof Fe||this.value instanceof Me}get scalarValue(){return this.value instanceof Oe?this.value.value:(console.error("Value is not scalar."),0)}get vectorValue(){return this.value instanceof Fe||this.value instanceof Me?this.value.data:(console.error("Value is not a vector or matrix."),new Float32Array(0))}}class xe extends he{constructor(i,m){super(),this.type=i,this.value=m}get astNodeType(){return"bitcastExpr"}search(i){this.value.search(i)}}class be extends he{constructor(i){super(),this.index=i}search(i){this.index.search(i)}}class ve extends he{constructor(){super()}}class we extends ve{constructor(i,m){super(),this.operator=i,this.right=m}get astNodeType(){return"unaryOp"}constEvaluate(i,m){return i.evalExpression(this,i.context)}search(i){this.right.search(i)}}class ke extends ve{constructor(i,m,g){super(),this.operator=i,this.left=m,this.right=g}get astNodeType(){return"binaryOp"}_getPromotedType(i,m){return i.name===m.name?i:"f32"===i.name||"f32"===m.name?re.f32:"u32"===i.name||"u32"===m.name?re.u32:re.i32}constEvaluate(i,m){return i.evalExpression(this,i.context)}search(i){this.left.search(i),this.right.search(i)}}class Ie extends S{constructor(i){super(),this.body=i}search(i){i(this),this.searchBlock(this.body,i)}}class Te extends he{constructor(){super()}get astNodeType(){return"default"}}class Se extends Ie{constructor(i,m){super(m),this.selectors=i}get astNodeType(){return"case"}search(i){this.searchBlock(this.body,i)}}class Ae extends Ie{constructor(i){super(i)}get astNodeType(){return"default"}search(i){this.searchBlock(this.body,i)}}class Ee extends S{constructor(i,m,g){super(),this.name=i,this.type=m,this.attributes=g}get astNodeType(){return"argument"}}class $e extends S{constructor(i,m){super(),this.condition=i,this.body=m}get astNodeType(){return"elseif"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}}class Le extends S{constructor(i,m,g){super(),this.name=i,this.type=m,this.attributes=g}get astNodeType(){return"member"}}class Ce extends S{constructor(i,m){super(),this.name=i,this.value=m}get astNodeType(){return"attribute"}}class De{constructor(i,m){this.parent=null,this.typeInfo=i,this.parent=m,this.id=De._id++}clone(){throw`Clone:Not implemented for ${this.constructor.name}`}setDataValue(i,m,g,x){console.error(`SetDataValue:Not implemented for ${this.constructor.name}`)}getSubData(i,m,g){return console.error(`GetDataValue:Not implemented for ${this.constructor.name}`),null}toString(){return`<${this.typeInfo.getTypeName()}>`}}De._id=0;class Ne extends De{constructor(){super(new e("void",null),null)}toString(){return"void"}}Ne.void=new Ne;class Ve extends De{constructor(i){super(new r("pointer",i.typeInfo,null),null),this.reference=i}clone(){return this}setDataValue(i,m,g,x){this.reference.setDataValue(i,m,g,x)}getSubData(i,m,g){return m?this.reference.getSubData(i,m,g):this}toString(){return`&${this.reference.toString()}`}}class Oe extends De{constructor(i,m,g=null){super(m,g),i instanceof Int32Array||i instanceof Uint32Array||i instanceof Float32Array?this.data=i:"x32"===this.typeInfo.name?i-Math.floor(i)!=0?this.data=new Float32Array([i]):this.data=i>=0?new Uint32Array([i]):new Int32Array([i]):"i32"===this.typeInfo.name||"bool"===this.typeInfo.name?this.data=new Int32Array([i]):"u32"===this.typeInfo.name?this.data=new Uint32Array([i]):"f32"===this.typeInfo.name||"f16"===this.typeInfo.name?this.data=new Float32Array([i]):console.error("ScalarData2:Invalid type",m)}clone(){if(this.data instanceof Float32Array)return new Oe(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Oe(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Oe(new Uint32Array(this.data),this.typeInfo,null);throw"ScalarData:Invalid data type"}get value(){return this.data[0]}set value(i){this.data[0]=i}setDataValue(i,m,g,x){if(g)return void console.error("SetDataValue:Scalar data does not support postfix",g);if(!(m instanceof Oe))return void console.error("SetDataValue:Invalid value",m);let _=m.data[0];"i32"===this.typeInfo.name||"u32"===this.typeInfo.name?_=Math.floor(_):"bool"===this.typeInfo.name&&(_=_?1:0),this.data[0]=_}getSubData(i,m,g){return m?(console.error("getSubData:Scalar data does not support postfix",m),null):this}toString(){return`${this.value}`}}function Be(i,m,g){const x=m.length;return 2===x?"f32"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec2f")):"i32"===g||"bool"===g?new Fe(new Int32Array(m),i.getTypeInfo("vec2i")):"u32"===g?new Fe(new Uint32Array(m),i.getTypeInfo("vec2u")):"f16"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec2h")):(console.error(`getSubData:Unknown format ${g}`),null):3===x?"f32"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec3f")):"i32"===g||"bool"===g?new Fe(new Int32Array(m),i.getTypeInfo("vec3i")):"u32"===g?new Fe(new Uint32Array(m),i.getTypeInfo("vec3u")):"f16"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec3h")):(console.error(`getSubData:Unknown format ${g}`),null):4===x?"f32"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec4f")):"i32"===g||"bool"===g?new Fe(new Int32Array(m),i.getTypeInfo("vec4i")):"u32"===g?new Fe(new Uint32Array(m),i.getTypeInfo("vec4u")):"f16"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec4h")):(console.error(`getSubData:Unknown format ${g}`),null):(console.error(`getSubData:Invalid vector size ${m.length}`),null)}class Fe extends De{constructor(i,m,g=null){if(super(m,g),i instanceof Float32Array||i instanceof Uint32Array||i instanceof Int32Array)this.data=i;else{const m=this.typeInfo.name;"vec2f"===m||"vec3f"===m||"vec4f"===m?this.data=new Float32Array(i):"vec2i"===m||"vec3i"===m||"vec4i"===m?this.data=new Int32Array(i):"vec2u"===m||"vec3u"===m||"vec4u"===m?this.data=new Uint32Array(i):"vec2h"===m||"vec3h"===m||"vec4h"===m?this.data=new Float32Array(i):"vec2b"===m||"vec3b"===m||"vec4b"===m?this.data=new Int32Array(i):"vec2"===m||"vec3"===m||"vec4"===m?this.data=new Float32Array(i):console.error(`VectorData:Invalid type ${m}`)}}clone(){if(this.data instanceof Float32Array)return new Fe(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Fe(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Fe(new Uint32Array(this.data),this.typeInfo,null);throw"VectorData:Invalid data type"}setDataValue(i,m,g,x){g instanceof fe?console.error("TODO:Set vector postfix"):m instanceof Fe?this.data=m.data:console.error("SetDataValue:Invalid value",m)}getSubData(i,m,g){if(null===m)return this;let x=i.getTypeInfo("f32");if(this.typeInfo instanceof a)x=this.typeInfo.format||x;else{const m=this.typeInfo.name;"vec2f"===m||"vec3f"===m||"vec4f"===m?x=i.getTypeInfo("f32"):"vec2i"===m||"vec3i"===m||"vec4i"===m?x=i.getTypeInfo("i32"):"vec2b"===m||"vec3b"===m||"vec4b"===m?x=i.getTypeInfo("bool"):"vec2u"===m||"vec3u"===m||"vec4u"===m?x=i.getTypeInfo("u32"):"vec2h"===m||"vec3h"===m||"vec4h"===m?x=i.getTypeInfo("f16"):console.error(`GetSubData:Unknown type ${m}`)}let _=this;for(;null!==m&&null!==_;){if(m instanceof be){const b=m.index;let y=-1;if(b instanceof ge){if(!(b.value instanceof Oe))return console.error(`GetSubData:Invalid array index ${b.value}`),null;y=b.value.value}else{const m=i.evalExpression(b,g);if(!(m instanceof Oe))return console.error("GetSubData:Unknown index type",b),null;y=m.value}if(y<0||y>=_.data.length)return console.error("GetSubData:Index out of range",y),null;if(_.data instanceof Float32Array){const i=new Float32Array(_.data.buffer,_.data.byteOffset+4*y,1);return new Oe(i,x)}if(_.data instanceof Int32Array){const i=new Int32Array(_.data.buffer,_.data.byteOffset+4*y,1);return new Oe(i,x)}if(_.data instanceof Uint32Array){const i=new Uint32Array(_.data.buffer,_.data.byteOffset+4*y,1);return new Oe(i,x)}throw"GetSubData:Invalid data type"}if(!(m instanceof fe))return console.error("GetSubData:Unknown postfix",m),null;{const g=m.value.toLowerCase();if(1===g.length){let i=0;if("x"===g||"r"===g)i=0;else if("y"===g||"g"===g)i=1;else if("z"===g||"b"===g)i=2;else{if("w"!==g&&"a"!==g)return console.error(`GetSubData:Unknown member ${g}`),null;i=3}if(this.data instanceof Float32Array){let m=new Float32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Oe(m,x,this)}if(this.data instanceof Int32Array){let m=new Int32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Oe(m,x,this)}if(this.data instanceof Uint32Array){let m=new Uint32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Oe(m,x,this)}}const b=[];for(const i of g)"x"===i||"r"===i?b.push(this.data[0]):"y"===i||"g"===i?b.push(this.data[1]):"z"===i||"b"===i?b.push(this.data[2]):"w"===i||"a"===i?b.push(this.data[3]):console.error(`GetDataValue:Unknown member ${i}`);_=Be(i,b,x.name)}m=m.postfix}return _}toString(){let i=`${this.data[0]}`;for(let m=1;m<this.data.length;++m)i+=`,${this.data[m]}`;return i}}class Me extends De{constructor(i,m,g=null){super(m,g),i instanceof Float32Array?this.data=i:this.data=new Float32Array(i)}clone(){return new Me(new Float32Array(this.data),this.typeInfo,null)}setDataValue(i,m,g,x){g instanceof fe?console.error("TODO:Set matrix postfix"):m instanceof Me?this.data=m.data:console.error("SetDataValue:Invalid value",m)}getSubData(i,m,g){if(null===m)return this;const x=this.typeInfo.name;if(i.getTypeInfo("f32"),this.typeInfo instanceof a)this.typeInfo.format;else if(x.endsWith("f"))i.getTypeInfo("f32");else if(x.endsWith("i"))i.getTypeInfo("i32");else if(x.endsWith("u"))i.getTypeInfo("u32");else{if(!x.endsWith("h"))return console.error(`GetDataValue:Unknown type ${x}`),null;i.getTypeInfo("f16")}if(m instanceof be){const _=m.index;let b=-1;if(_ instanceof ge){if(!(_.value instanceof Oe))return console.error(`GetDataValue:Invalid array index ${_.value}`),null;b=_.value.value}else{const m=i.evalExpression(_,g);if(!(m instanceof Oe))return console.error("GetDataValue:Unknown index type",_),null;b=m.value}if(b<0||b>=this.data.length)return console.error("GetDataValue:Index out of range",b),null;const y=x.endsWith("h")?"h":"f";let T;if("mat2x2"===x||"mat2x2f"===x||"mat2x2h"===x||"mat3x2"===x||"mat3x2f"===x||"mat3x2h"===x||"mat4x2"===x||"mat4x2f"===x||"mat4x2h"===x)T=new Fe(new Float32Array(this.data.buffer,this.data.byteOffset+2*b*4,2),i.getTypeInfo(`vec2${y}`));else if("mat2x3"===x||"mat2x3f"===x||"mat2x3h"===x||"mat3x3"===x||"mat3x3f"===x||"mat3x3h"===x||"mat4x3"===x||"mat4x3f"===x||"mat4x3h"===x)T=new Fe(new Float32Array(this.data.buffer,this.data.byteOffset+3*b*4,3),i.getTypeInfo(`vec3${y}`));else{if("mat2x4"!==x&&"mat2x4f"!==x&&"mat2x4h"!==x&&"mat3x4"!==x&&"mat3x4f"!==x&&"mat3x4h"!==x&&"mat4x4"!==x&&"mat4x4f"!==x&&"mat4x4h"!==x)return console.error(`GetDataValue:Unknown type ${x}`),null;T=new Fe(new Float32Array(this.data.buffer,this.data.byteOffset+4*b*4,4),i.getTypeInfo(`vec4${y}`))}return m.postfix?T.getSubData(i,m.postfix,g):T}return console.error("GetDataValue:Invalid postfix",m),null}toString(){let i=`${this.data[0]}`;for(let m=1;m<this.data.length;++m)i+=`,${this.data[m]}`;return i}}class Ue extends De{constructor(i,m,g=0,x=null){super(m,x),this.buffer=i instanceof ArrayBuffer?i:i.buffer,this.offset=g}clone(){const i=new Uint8Array(new Uint8Array(this.buffer,this.offset,this.typeInfo.size));return new Ue(i.buffer,this.typeInfo,0,null)}setDataValue(i,m,g,x){if(null===m)return void console.log("setDataValue:NULL data.");let _=this.offset,b=this.typeInfo;for(;g;){if(g instanceof be)if(b instanceof s){const m=g.index;if(m instanceof ge){if(!(m.value instanceof Oe))return void console.error(`SetDataValue:Invalid index type ${m.value}`);_+=m.value.value*b.stride}else{const g=i.evalExpression(m,x);if(!(g instanceof Oe))return void console.error("SetDataValue:Unknown index type",m);_+=g.value*b.stride}b=b.format}else console.error(`SetDataValue:Type ${b.getTypeName()} is not an array`);else{if(!(g instanceof fe))return void console.error("SetDataValue:Unknown postfix type",g);{const i=g.value;if(b instanceof n){let m=!1;for(const g of b.members)if(g.name===i){_+=g.offset,b=g.type,m=!0;break}if(!m)return void console.error(`SetDataValue:Member ${i} not found`)}else if(b instanceof e){const g=b.getTypeName();let x=0;if("x"===i||"r"===i)x=0;else if("y"===i||"g"===i)x=1;else if("z"===i||"b"===i)x=2;else{if("w"!==i&&"a"!==i)return void console.error(`SetDataValue:Unknown member ${i}`);x=3}if(!(m instanceof Oe))return void console.error("SetDataValue:Invalid value",m);const y=m.value;return"vec2f"===g?void(new Float32Array(this.buffer,_,2)[x]=y):"vec3f"===g?void(new Float32Array(this.buffer,_,3)[x]=y):"vec4f"===g?void(new Float32Array(this.buffer,_,4)[x]=y):"vec2i"===g?void(new Int32Array(this.buffer,_,2)[x]=y):"vec3i"===g?void(new Int32Array(this.buffer,_,3)[x]=y):"vec4i"===g?void(new Int32Array(this.buffer,_,4)[x]=y):"vec2u"===g?void(new Uint32Array(this.buffer,_,2)[x]=y):"vec3u"===g?void(new Uint32Array(this.buffer,_,3)[x]=y):"vec4u"===g?void(new Uint32Array(this.buffer,_,4)[x]=y):void console.error(`SetDataValue:Type ${g} is not a struct`)}}}g=g.postfix}this.setData(i,m,b,_,x)}setData(i,m,g,x,_){const b=g.getTypeName();if("f32"!==b&&"f16"!==b)if("i32"!==b&&"atomic<i32>"!==b&&"x32"!==b)if("u32"!==b&&"atomic<u32>"!==b)if("bool"!==b)if("vec2f"!==b&&"vec2h"!==b)if("vec3f"!==b&&"vec3h"!==b)if("vec4f"!==b&&"vec4h"!==b)if("vec2i"!==b)if("vec3i"!==b)if("vec4i"!==b)if("vec2u"!==b)if("vec3u"!==b)if("vec4u"!==b)if("vec2b"!==b)if("vec3b"!==b)if("vec4b"!==b)if("mat2x2f"!==b&&"mat2x2h"!==b)if("mat2x3f"!==b&&"mat2x3h"!==b)if("mat2x4f"!==b&&"mat2x4h"!==b)if("mat3x2f"!==b&&"mat3x2h"!==b)if("mat3x3f"!==b&&"mat3x3h"!==b)if("mat3x4f"!==b&&"mat3x4h"!==b)if("mat4x2f"!==b&&"mat4x2h"!==b)if("mat4x3f"!==b&&"mat4x3h"!==b)if("mat4x4f"!==b&&"mat4x4h"!==b)if(m instanceof Ue){if(g===m.typeInfo)return void new Uint8Array(this.buffer,x,m.buffer.byteLength).set(new Uint8Array(m.buffer));console.error("SetDataValue:Type mismatch",b,m.typeInfo.getTypeName())}else console.error(`SetData:Unknown type ${b}`);else{const i=new Float32Array(this.buffer,x,16);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8],i[9]=m.data[9],i[10]=m.data[10],i[11]=m.data[11],i[12]=m.data[12],i[13]=m.data[13],i[14]=m.data[14],i[15]=m.data[15]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15])}else{const i=new Float32Array(this.buffer,x,12);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8],i[9]=m.data[9],i[10]=m.data[10],i[11]=m.data[11]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11])}else{const i=new Float32Array(this.buffer,x,8);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7])}else{const i=new Float32Array(this.buffer,x,12);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8],i[9]=m.data[9],i[10]=m.data[10],i[11]=m.data[11]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11])}else{const i=new Float32Array(this.buffer,x,9);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8])}else{const i=new Float32Array(this.buffer,x,6);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5])}else{const i=new Float32Array(this.buffer,x,8);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7])}else{const i=new Float32Array(this.buffer,x,6);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5])}else{const i=new Float32Array(this.buffer,x,4);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Uint32Array(this.buffer,x,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Uint32Array(this.buffer,x,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Uint32Array(this.buffer,x,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else{const i=new Uint32Array(this.buffer,x,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Uint32Array(this.buffer,x,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Uint32Array(this.buffer,x,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else{const i=new Int32Array(this.buffer,x,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Int32Array(this.buffer,x,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Int32Array(this.buffer,x,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else{const i=new Float32Array(this.buffer,x,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Float32Array(this.buffer,x,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Float32Array(this.buffer,x,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else m instanceof Oe&&(new Int32Array(this.buffer,x,1)[0]=m.value);else m instanceof Oe&&(new Uint32Array(this.buffer,x,1)[0]=m.value);else m instanceof Oe&&(new Int32Array(this.buffer,x,1)[0]=m.value);else m instanceof Oe&&(new Float32Array(this.buffer,x,1)[0]=m.value)}getSubData(i,m,g){var x,_,b;if(null===m)return this;let y=this.offset,T=this.typeInfo;for(;m;){if(m instanceof be){const x=m.index,_=x instanceof he?i.evalExpression(x,g):x;let b=0;if(_ instanceof Oe?b=_.value:"number"==typeof _?b=_:console.error("GetDataValue:Invalid index type",x),T instanceof s)y+=b*T.stride,T=T.format;else{const m=T.getTypeName();"mat4x4"===m||"mat4x4f"===m||"mat4x4h"===m?(y+=16*b,T=i.getTypeInfo("vec4f")):console.error(`getDataValue:Type ${T.getTypeName()} is not an array`)}}else{if(!(m instanceof fe))return console.error("GetDataValue:Unknown postfix type",m),null;{const g=m.value;if(T instanceof n){let i=!1;for(const m of T.members)if(m.name===g){y+=m.offset,T=m.type,i=!0;break}if(!i)return console.error(`GetDataValue:Member ${g} not found`),null}else if(T instanceof e){const m=T.getTypeName();if("vec2f"===m||"vec3f"===m||"vec4f"===m||"vec2i"===m||"vec3i"===m||"vec4i"===m||"vec2u"===m||"vec3u"===m||"vec4u"===m||"vec2b"===m||"vec3b"===m||"vec4b"===m||"vec2h"===m||"vec3h"===m||"vec4h"===m||"vec2"===m||"vec3"===m||"vec4"===m){if(g.length>0&&g.length<5){let x="f";const _=[];for(let b=0;b<g.length;++b){const T=g[b].toLowerCase();let w=0;if("x"===T||"r"===T)w=0;else if("y"===T||"g"===T)w=1;else if("z"===T||"b"===T)w=2;else{if("w"!==T&&"a"!==T)return console.error(`Unknown member ${g}`),null;w=3}if(1===g.length){if(m.endsWith("f"))return this.buffer.byteLength<y+4*w+4?(console.log("Insufficient buffer data"),null):new Oe(new Float32Array(this.buffer,y+4*w,1),i.getTypeInfo("f32"),this);if(m.endsWith("h"))return new Oe(new Float32Array(this.buffer,y+4*w,1),i.getTypeInfo("f16"),this);if(m.endsWith("i"))return new Oe(new Int32Array(this.buffer,y+4*w,1),i.getTypeInfo("i32"),this);if(m.endsWith("b"))return new Oe(new Int32Array(this.buffer,y+4*w,1),i.getTypeInfo("bool"),this);if(m.endsWith("u"))return new Oe(new Uint32Array(this.buffer,y+4*w,1),i.getTypeInfo("i32"),this)}if("vec2f"===m)_.push(new Float32Array(this.buffer,y,2)[w]);else if("vec3f"===m){if(y+12>=this.buffer.byteLength)return console.log("Insufficient buffer data"),null;const i=new Float32Array(this.buffer,y,3);_.push(i[w])}else if("vec4f"===m)_.push(new Float32Array(this.buffer,y,4)[w]);else if("vec2i"===m)x="i",_.push(new Int32Array(this.buffer,y,2)[w]);else if("vec3i"===m)x="i",_.push(new Int32Array(this.buffer,y,3)[w]);else if("vec4i"===m)x="i",_.push(new Int32Array(this.buffer,y,4)[w]);else if("vec2u"===m){x="u";const i=new Uint32Array(this.buffer,y,2);_.push(i[w])}else"vec3u"===m?(x="u",_.push(new Uint32Array(this.buffer,y,3)[w])):"vec4u"===m&&(x="u",_.push(new Uint32Array(this.buffer,y,4)[w]))}return 2===_.length?T=i.getTypeInfo(`vec2${x}`):3===_.length?T=i.getTypeInfo(`vec3${x}`):4===_.length?T=i.getTypeInfo(`vec4${x}`):console.error(`GetDataValue:Invalid vector length ${_.length}`),new Fe(_,T,null)}return console.error(`GetDataValue:Unknown member ${g}`),null}return console.error(`GetDataValue:Type ${m} is not a struct`),null}}}m=m.postfix}const w=T.getTypeName();return"f32"===w?new Oe(new Float32Array(this.buffer,y,1),T,this):"i32"===w?new Oe(new Int32Array(this.buffer,y,1),T,this):"u32"===w?new Oe(new Uint32Array(this.buffer,y,1),T,this):"vec2f"===w?new Fe(new Float32Array(this.buffer,y,2),T,this):"vec3f"===w?new Fe(new Float32Array(this.buffer,y,3),T,this):"vec4f"===w?new Fe(new Float32Array(this.buffer,y,4),T,this):"vec2i"===w?new Fe(new Int32Array(this.buffer,y,2),T,this):"vec3i"===w?new Fe(new Int32Array(this.buffer,y,3),T,this):"vec4i"===w?new Fe(new Int32Array(this.buffer,y,4),T,this):"vec2u"===w?new Fe(new Uint32Array(this.buffer,y,2),T,this):"vec3u"===w?new Fe(new Uint32Array(this.buffer,y,3),T,this):"vec4u"===w?new Fe(new Uint32Array(this.buffer,y,4),T,this):T instanceof a&&"atomic"===T.name?"u32"===(null===(x=T.format)||void 0===x?void 0:x.name)?new Oe(new Uint32Array(this.buffer,y,1)[0],T.format,this):"i32"===(null===(_=T.format)||void 0===_?void 0:_.name)?new Oe(new Int32Array(this.buffer,y,1)[0],T.format,this):(console.error(`GetDataValue:Invalid atomic format ${null===(b=T.format)||void 0===b?void 0:b.name}`),null):new Ue(this.buffer,T,y,this)}toString(){let i="";if(this.typeInfo instanceof s)if("f32"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]}`;for(let g=1;g<m.length;++g)i+=`,${m[g]}`}else if("i32"===this.typeInfo.format.name){const m=new Int32Array(this.buffer,this.offset);i=`[${m[0]}`;for(let g=1;g<m.length;++g)i+=`,${m[g]}`}else if("u32"===this.typeInfo.format.name){const m=new Uint32Array(this.buffer,this.offset);i=`[${m[0]}`;for(let g=1;g<m.length;++g)i+=`,${m[g]}`}else if("vec2f"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]},${m[1]}]`;for(let g=1;g<m.length/2;++g)i+=`,[${m[2*g]},${m[2*g+1]}]`}else if("vec3f"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]},${m[1]},${m[2]}]`;for(let g=4;g<m.length;g+=4)i+=`,[${m[g]},${m[g+1]},${m[g+2]}]`}else if("vec4f"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]},${m[1]},${m[2]},${m[3]}]`;for(let g=4;g<m.length;g+=4)i+=`,[${m[g]},${m[g+1]},${m[g+2]},${m[g+3]}]`}else i="[...]";else this.typeInfo instanceof n?i+="{...}":i="[...]";return i}}class Pe extends De{constructor(i,m,g,x){super(m,null),this.data=i,this.descriptor=g,this.view=x}clone(){return new Pe(this.data,this.typeInfo,this.descriptor,this.view)}get width(){var i,m;const g=this.descriptor.size;return g instanceof Array&&g.length>0?null!==(i=g[0])&&void 0!==i?i:0:g instanceof Object&&null!==(m=g.width)&&void 0!==m?m:0}get height(){var i,m;const g=this.descriptor.size;return g instanceof Array&&g.length>1?null!==(i=g[1])&&void 0!==i?i:0:g instanceof Object&&null!==(m=g.height)&&void 0!==m?m:0}get depthOrArrayLayers(){var i,m;const g=this.descriptor.size;return g instanceof Array&&g.length>2?null!==(i=g[2])&&void 0!==i?i:0:g instanceof Object&&null!==(m=g.depthOrArrayLayers)&&void 0!==m?m:0}get format(){var i;return this.descriptor&&null!==(i=this.descriptor.format)&&void 0!==i?i:"rgba8unorm"}get sampleCount(){var i;return this.descriptor&&null!==(i=this.descriptor.sampleCount)&&void 0!==i?i:1}get mipLevelCount(){var i;return this.descriptor&&null!==(i=this.descriptor.mipLevelCount)&&void 0!==i?i:1}get dimension(){var i;return this.descriptor&&null!==(i=this.descriptor.dimension)&&void 0!==i?i:"2d"}getMipLevelSize(i){if(i>=this.mipLevelCount)return[0,0,0];const m=[this.width,this.height,this.depthOrArrayLayers];for(let g=0;g<m.length;++g)m[g]=Math.max(1,m[g]>>i);return m}get texelByteSize(){const i=this.format,m=Fr[i];return m?m.isDepthStencil?4:m.bytesPerBlock:0}get bytesPerRow(){return this.width*this.texelByteSize}get isDepthStencil(){const i=this.format,m=Fr[i];return!!m&&m.isDepthStencil}getGpuSize(){const i=this.format,m=Fr[i],g=this.width;if(!i||g<=0||!m)return-1;const x=this.height,_=this.depthOrArrayLayers,b=this.dimension;return g/m.blockWidth*("1d"===b?1:x/m.blockHeight)*m.bytesPerBlock*_}getPixel(i,m,g=0,x=0){const _=this.texelByteSize,b=this.bytesPerRow,y=this.height,T=this.data[x];return function(i,m,g,x,_,b,y,T,w){const P=x*(y>>=_)*(b>>=_)+g*y+m*T;switch(w){case"r8unorm":return[k(i,P,"8unorm",1)[0]];case"r8snorm":return[k(i,P,"8snorm",1)[0]];case"r8uint":return[k(i,P,"8uint",1)[0]];case"r8sint":return[k(i,P,"8sint",1)[0]];case"rg8unorm":{const m=k(i,P,"8unorm",2);return[m[0],m[1]]}case"rg8snorm":{const m=k(i,P,"8snorm",2);return[m[0],m[1]]}case"rg8uint":{const m=k(i,P,"8uint",2);return[m[0],m[1]]}case"rg8sint":{const m=k(i,P,"8sint",2);return[m[0],m[1]]}case"rgba8unorm-srgb":case"rgba8unorm":{const m=k(i,P,"8unorm",4);return[m[0],m[1],m[2],m[3]]}case"rgba8snorm":{const m=k(i,P,"8snorm",4);return[m[0],m[1],m[2],m[3]]}case"rgba8uint":{const m=k(i,P,"8uint",4);return[m[0],m[1],m[2],m[3]]}case"rgba8sint":{const m=k(i,P,"8sint",4);return[m[0],m[1],m[2],m[3]]}case"bgra8unorm-srgb":case"bgra8unorm":{const m=k(i,P,"8unorm",4);return[m[2],m[1],m[0],m[3]]}case"r16uint":return[k(i,P,"16uint",1)[0]];case"r16sint":return[k(i,P,"16sint",1)[0]];case"r16float":return[k(i,P,"16float",1)[0]];case"rg16uint":{const m=k(i,P,"16uint",2);return[m[0],m[1]]}case"rg16sint":{const m=k(i,P,"16sint",2);return[m[0],m[1]]}case"rg16float":{const m=k(i,P,"16float",2);return[m[0],m[1]]}case"rgba16uint":{const m=k(i,P,"16uint",4);return[m[0],m[1],m[2],m[3]]}case"rgba16sint":{const m=k(i,P,"16sint",4);return[m[0],m[1],m[2],m[3]]}case"rgba16float":{const m=k(i,P,"16float",4);return[m[0],m[1],m[2],m[3]]}case"r32uint":return[k(i,P,"32uint",1)[0]];case"r32sint":return[k(i,P,"32sint",1)[0]];case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return[k(i,P,"32float",1)[0]];case"rg32uint":{const m=k(i,P,"32uint",2);return[m[0],m[1]]}case"rg32sint":{const m=k(i,P,"32sint",2);return[m[0],m[1]]}case"rg32float":{const m=k(i,P,"32float",2);return[m[0],m[1]]}case"rgba32uint":{const m=k(i,P,"32uint",4);return[m[0],m[1],m[2],m[3]]}case"rgba32sint":{const m=k(i,P,"32sint",4);return[m[0],m[1],m[2],m[3]]}case"rgba32float":{const m=k(i,P,"32float",4);return[m[0],m[1],m[2],m[3]]}case"rg11b10ufloat":{const m=new Uint32Array(i.buffer,P,1)[0],g=(4192256&m)>>11,x=(4290772992&m)>>22;return[v(2047&m),v(g),function(i){const m=112+(i>>5&31)<<23|(31&i)<<18;return Or[0]=m,Nr[0]}(x),1]}}return null}(new Uint8Array(T),i,m,g,x,y,b,_,this.format)}setPixel(i,m,g,x,_){const b=this.texelByteSize,y=this.bytesPerRow,T=this.height,w=this.data[x];!function(i,m,g,x,_,b,y,T,w,P){const $=x*(y>>=_)*(b>>=_)+g*y+m*T;switch(w){case"r8unorm":return void I(i,$,"8unorm",1,P);case"r8snorm":return void I(i,$,"8snorm",1,P);case"r8uint":return void I(i,$,"8uint",1,P);case"r8sint":return void I(i,$,"8sint",1,P);case"rg8unorm":return void I(i,$,"8unorm",2,P);case"rg8snorm":return void I(i,$,"8snorm",2,P);case"rg8uint":return void I(i,$,"8uint",2,P);case"rg8sint":return void I(i,$,"8sint",2,P);case"rgba8unorm-srgb":case"rgba8unorm":case"bgra8unorm-srgb":case"bgra8unorm":return void I(i,$,"8unorm",4,P);case"rgba8snorm":return void I(i,$,"8snorm",4,P);case"rgba8uint":return void I(i,$,"8uint",4,P);case"rgba8sint":return void I(i,$,"8sint",4,P);case"r16uint":return void I(i,$,"16uint",1,P);case"r16sint":return void I(i,$,"16sint",1,P);case"r16float":return void I(i,$,"16float",1,P);case"rg16uint":return void I(i,$,"16uint",2,P);case"rg16sint":return void I(i,$,"16sint",2,P);case"rg16float":return void I(i,$,"16float",2,P);case"rgba16uint":return void I(i,$,"16uint",4,P);case"rgba16sint":return void I(i,$,"16sint",4,P);case"rgba16float":return void I(i,$,"16float",4,P);case"r32uint":return void I(i,$,"32uint",1,P);case"r32sint":return void I(i,$,"32sint",1,P);case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return void I(i,$,"32float",1,P);case"rg32uint":return void I(i,$,"32uint",2,P);case"rg32sint":return void I(i,$,"32sint",2,P);case"rg32float":return void I(i,$,"32float",2,P);case"rgba32uint":return void I(i,$,"32uint",4,P);case"rgba32sint":return void I(i,$,"32sint",4,P);case"rgba32float":return void I(i,$,"32float",4,P);case"rg11b10ufloat":console.error("TODO:rg11b10ufloat not supported for writing")}}(new Uint8Array(w),i,m,g,x,T,y,b,this.format,_)}}(i=>{i[i.token=0]="token",i[i.keyword=1]="keyword",i[i.reserved=2]="reserved"})(zr||(zr={}));class We{constructor(i,m,g){this.name=i,this.type=m,this.rule=g}toString(){return this.name}}class qe{}Hr=qe,qe.none=new We("",zr.reserved,""),qe.eof=new We("EOF",zr.token,""),qe.reserved={asm:new We("asm",zr.reserved,"asm"),bf16:new We("bf16",zr.reserved,"bf16"),do:new We("do",zr.reserved,"do"),enum:new We("enum",zr.reserved,"enum"),f16:new We("f16",zr.reserved,"f16"),f64:new We("f64",zr.reserved,"f64"),handle:new We("handle",zr.reserved,"handle"),i8:new We("i8",zr.reserved,"i8"),i16:new We("i16",zr.reserved,"i16"),i64:new We("i64",zr.reserved,"i64"),mat:new We("mat",zr.reserved,"mat"),premerge:new We("premerge",zr.reserved,"premerge"),regardless:new We("regardless",zr.reserved,"regardless"),typedef:new We("typedef",zr.reserved,"typedef"),u8:new We("u8",zr.reserved,"u8"),u16:new We("u16",zr.reserved,"u16"),u64:new We("u64",zr.reserved,"u64"),unless:new We("unless",zr.reserved,"unless"),using:new We("using",zr.reserved,"using"),vec:new We("vec",zr.reserved,"vec"),void:new We("void",zr.reserved,"void")},qe.keywords={array:new We("array",zr.keyword,"array"),atomic:new We("atomic",zr.keyword,"atomic"),bool:new We("bool",zr.keyword,"bool"),f32:new We("f32",zr.keyword,"f32"),i32:new We("i32",zr.keyword,"i32"),mat2x2:new We("mat2x2",zr.keyword,"mat2x2"),mat2x3:new We("mat2x3",zr.keyword,"mat2x3"),mat2x4:new We("mat2x4",zr.keyword,"mat2x4"),mat3x2:new We("mat3x2",zr.keyword,"mat3x2"),mat3x3:new We("mat3x3",zr.keyword,"mat3x3"),mat3x4:new We("mat3x4",zr.keyword,"mat3x4"),mat4x2:new We("mat4x2",zr.keyword,"mat4x2"),mat4x3:new We("mat4x3",zr.keyword,"mat4x3"),mat4x4:new We("mat4x4",zr.keyword,"mat4x4"),ptr:new We("ptr",zr.keyword,"ptr"),sampler:new We("sampler",zr.keyword,"sampler"),sampler_comparison:new We("sampler_comparison",zr.keyword,"sampler_comparison"),struct:new We("struct",zr.keyword,"struct"),texture_1d:new We("texture_1d",zr.keyword,"texture_1d"),texture_2d:new We("texture_2d",zr.keyword,"texture_2d"),texture_2d_array:new We("texture_2d_array",zr.keyword,"texture_2d_array"),texture_3d:new We("texture_3d",zr.keyword,"texture_3d"),texture_cube:new We("texture_cube",zr.keyword,"texture_cube"),texture_cube_array:new We("texture_cube_array",zr.keyword,"texture_cube_array"),texture_multisampled_2d:new We("texture_multisampled_2d",zr.keyword,"texture_multisampled_2d"),texture_storage_1d:new We("texture_storage_1d",zr.keyword,"texture_storage_1d"),texture_storage_2d:new We("texture_storage_2d",zr.keyword,"texture_storage_2d"),texture_storage_2d_array:new We("texture_storage_2d_array",zr.keyword,"texture_storage_2d_array"),texture_storage_3d:new We("texture_storage_3d",zr.keyword,"texture_storage_3d"),texture_depth_2d:new We("texture_depth_2d",zr.keyword,"texture_depth_2d"),texture_depth_2d_array:new We("texture_depth_2d_array",zr.keyword,"texture_depth_2d_array"),texture_depth_cube:new We("texture_depth_cube",zr.keyword,"texture_depth_cube"),texture_depth_cube_array:new We("texture_depth_cube_array",zr.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new We("texture_depth_multisampled_2d",zr.keyword,"texture_depth_multisampled_2d"),texture_external:new We("texture_external",zr.keyword,"texture_external"),u32:new We("u32",zr.keyword,"u32"),vec2:new We("vec2",zr.keyword,"vec2"),vec3:new We("vec3",zr.keyword,"vec3"),vec4:new We("vec4",zr.keyword,"vec4"),bitcast:new We("bitcast",zr.keyword,"bitcast"),block:new We("block",zr.keyword,"block"),break:new We("break",zr.keyword,"break"),case:new We("case",zr.keyword,"case"),continue:new We("continue",zr.keyword,"continue"),continuing:new We("continuing",zr.keyword,"continuing"),default:new We("default",zr.keyword,"default"),diagnostic:new We("diagnostic",zr.keyword,"diagnostic"),discard:new We("discard",zr.keyword,"discard"),else:new We("else",zr.keyword,"else"),enable:new We("enable",zr.keyword,"enable"),fallthrough:new We("fallthrough",zr.keyword,"fallthrough"),false:new We("false",zr.keyword,"false"),fn:new We("fn",zr.keyword,"fn"),for:new We("for",zr.keyword,"for"),function:new We("function",zr.keyword,"function"),if:new We("if",zr.keyword,"if"),let:new We("let",zr.keyword,"let"),const:new We("const",zr.keyword,"const"),loop:new We("loop",zr.keyword,"loop"),while:new We("while",zr.keyword,"while"),private:new We("private",zr.keyword,"private"),read:new We("read",zr.keyword,"read"),read_write:new We("read_write",zr.keyword,"read_write"),return:new We("return",zr.keyword,"return"),requires:new We("requires",zr.keyword,"requires"),storage:new We("storage",zr.keyword,"storage"),switch:new We("switch",zr.keyword,"switch"),true:new We("true",zr.keyword,"true"),alias:new We("alias",zr.keyword,"alias"),type:new We("type",zr.keyword,"type"),uniform:new We("uniform",zr.keyword,"uniform"),var:new We("var",zr.keyword,"var"),override:new We("override",zr.keyword,"override"),workgroup:new We("workgroup",zr.keyword,"workgroup"),write:new We("write",zr.keyword,"write"),r8unorm:new We("r8unorm",zr.keyword,"r8unorm"),r8snorm:new We("r8snorm",zr.keyword,"r8snorm"),r8uint:new We("r8uint",zr.keyword,"r8uint"),r8sint:new We("r8sint",zr.keyword,"r8sint"),r16uint:new We("r16uint",zr.keyword,"r16uint"),r16sint:new We("r16sint",zr.keyword,"r16sint"),r16float:new We("r16float",zr.keyword,"r16float"),rg8unorm:new We("rg8unorm",zr.keyword,"rg8unorm"),rg8snorm:new We("rg8snorm",zr.keyword,"rg8snorm"),rg8uint:new We("rg8uint",zr.keyword,"rg8uint"),rg8sint:new We("rg8sint",zr.keyword,"rg8sint"),r32uint:new We("r32uint",zr.keyword,"r32uint"),r32sint:new We("r32sint",zr.keyword,"r32sint"),r32float:new We("r32float",zr.keyword,"r32float"),rg16uint:new We("rg16uint",zr.keyword,"rg16uint"),rg16sint:new We("rg16sint",zr.keyword,"rg16sint"),rg16float:new We("rg16float",zr.keyword,"rg16float"),rgba8unorm:new We("rgba8unorm",zr.keyword,"rgba8unorm"),rgba8unorm_srgb:new We("rgba8unorm_srgb",zr.keyword,"rgba8unorm_srgb"),rgba8snorm:new We("rgba8snorm",zr.keyword,"rgba8snorm"),rgba8uint:new We("rgba8uint",zr.keyword,"rgba8uint"),rgba8sint:new We("rgba8sint",zr.keyword,"rgba8sint"),bgra8unorm:new We("bgra8unorm",zr.keyword,"bgra8unorm"),bgra8unorm_srgb:new We("bgra8unorm_srgb",zr.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new We("rgb10a2unorm",zr.keyword,"rgb10a2unorm"),rg11b10float:new We("rg11b10float",zr.keyword,"rg11b10float"),rg32uint:new We("rg32uint",zr.keyword,"rg32uint"),rg32sint:new We("rg32sint",zr.keyword,"rg32sint"),rg32float:new We("rg32float",zr.keyword,"rg32float"),rgba16uint:new We("rgba16uint",zr.keyword,"rgba16uint"),rgba16sint:new We("rgba16sint",zr.keyword,"rgba16sint"),rgba16float:new We("rgba16float",zr.keyword,"rgba16float"),rgba32uint:new We("rgba32uint",zr.keyword,"rgba32uint"),rgba32sint:new We("rgba32sint",zr.keyword,"rgba32sint"),rgba32float:new We("rgba32float",zr.keyword,"rgba32float"),static_assert:new We("static_assert",zr.keyword,"static_assert")},qe.tokens={decimal_float_literal:new We("decimal_float_literal",zr.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),hex_float_literal:new We("hex_float_literal",zr.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),int_literal:new We("int_literal",zr.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new We("uint_literal",zr.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),name:new We("name",zr.token,/([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),ident:new We("ident",zr.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new We("and",zr.token,"&"),and_and:new We("and_and",zr.token,"&&"),arrow:new We("arrow ",zr.token,"->"),attr:new We("attr",zr.token,"@"),forward_slash:new We("forward_slash",zr.token,"/"),bang:new We("bang",zr.token,"!"),bracket_left:new We("bracket_left",zr.token,"["),bracket_right:new We("bracket_right",zr.token,"]"),brace_left:new We("brace_left",zr.token,"{"),brace_right:new We("brace_right",zr.token,"}"),colon:new We("colon",zr.token,":"),comma:new We("comma",zr.token,","),equal:new We("equal",zr.token,"="),equal_equal:new We("equal_equal",zr.token,"=="),not_equal:new We("not_equal",zr.token,"!="),greater_than:new We("greater_than",zr.token,">"),greater_than_equal:new We("greater_than_equal",zr.token,">="),shift_right:new We("shift_right",zr.token,">>"),less_than:new We("less_than",zr.token,"<"),less_than_equal:new We("less_than_equal",zr.token,"<="),shift_left:new We("shift_left",zr.token,"<<"),modulo:new We("modulo",zr.token,"%"),minus:new We("minus",zr.token,"-"),minus_minus:new We("minus_minus",zr.token,"--"),period:new We("period",zr.token,"."),plus:new We("plus",zr.token,"+"),plus_plus:new We("plus_plus",zr.token,"++"),or:new We("or",zr.token,"|"),or_or:new We("or_or",zr.token,"||"),paren_left:new We("paren_left",zr.token,"("),paren_right:new We("paren_right",zr.token,")"),semicolon:new We("semicolon",zr.token,";"),star:new We("star",zr.token,"*"),tilde:new We("tilde",zr.token,"~"),underscore:new We("underscore",zr.token,"_"),xor:new We("xor",zr.token,"^"),plus_equal:new We("plus_equal",zr.token,"+="),minus_equal:new We("minus_equal",zr.token,"-="),times_equal:new We("times_equal",zr.token,"*="),division_equal:new We("division_equal",zr.token,"/="),modulo_equal:new We("modulo_equal",zr.token,"%="),and_equal:new We("and_equal",zr.token,"&="),or_equal:new We("or_equal",zr.token,"|="),xor_equal:new We("xor_equal",zr.token,"^="),shift_right_equal:new We("shift_right_equal",zr.token,">>="),shift_left_equal:new We("shift_left_equal",zr.token,"<<=")},qe.simpleTokens={"@":Hr.tokens.attr,"{":Hr.tokens.brace_left,"}":Hr.tokens.brace_right,":":Hr.tokens.colon,",":Hr.tokens.comma,"(":Hr.tokens.paren_left,")":Hr.tokens.paren_right,";":Hr.tokens.semicolon},qe.literalTokens={"&":Hr.tokens.and,"&&":Hr.tokens.and_and,"->":Hr.tokens.arrow,"/":Hr.tokens.forward_slash,"!":Hr.tokens.bang,"[":Hr.tokens.bracket_left,"]":Hr.tokens.bracket_right,"=":Hr.tokens.equal,"==":Hr.tokens.equal_equal,"!=":Hr.tokens.not_equal,">":Hr.tokens.greater_than,">=":Hr.tokens.greater_than_equal,">>":Hr.tokens.shift_right,"<":Hr.tokens.less_than,"<=":Hr.tokens.less_than_equal,"<<":Hr.tokens.shift_left,"%":Hr.tokens.modulo,"-":Hr.tokens.minus,"--":Hr.tokens.minus_minus,".":Hr.tokens.period,"+":Hr.tokens.plus,"++":Hr.tokens.plus_plus,"|":Hr.tokens.or,"||":Hr.tokens.or_or,"*":Hr.tokens.star,"~":Hr.tokens.tilde,_:Hr.tokens.underscore,"^":Hr.tokens.xor,"+=":Hr.tokens.plus_equal,"-=":Hr.tokens.minus_equal,"*=":Hr.tokens.times_equal,"/=":Hr.tokens.division_equal,"%=":Hr.tokens.modulo_equal,"&=":Hr.tokens.and_equal,"|=":Hr.tokens.or_equal,"^=":Hr.tokens.xor_equal,">>=":Hr.tokens.shift_right_equal,"<<=":Hr.tokens.shift_left_equal},qe.regexTokens={decimal_float_literal:Hr.tokens.decimal_float_literal,hex_float_literal:Hr.tokens.hex_float_literal,int_literal:Hr.tokens.int_literal,uint_literal:Hr.tokens.uint_literal,ident:Hr.tokens.ident},qe.storage_class=[Hr.keywords.function,Hr.keywords.private,Hr.keywords.workgroup,Hr.keywords.uniform,Hr.keywords.storage],qe.access_mode=[Hr.keywords.read,Hr.keywords.write,Hr.keywords.read_write],qe.sampler_type=[Hr.keywords.sampler,Hr.keywords.sampler_comparison],qe.sampled_texture_type=[Hr.keywords.texture_1d,Hr.keywords.texture_2d,Hr.keywords.texture_2d_array,Hr.keywords.texture_3d,Hr.keywords.texture_cube,Hr.keywords.texture_cube_array],qe.multisampled_texture_type=[Hr.keywords.texture_multisampled_2d],qe.storage_texture_type=[Hr.keywords.texture_storage_1d,Hr.keywords.texture_storage_2d,Hr.keywords.texture_storage_2d_array,Hr.keywords.texture_storage_3d],qe.depth_texture_type=[Hr.keywords.texture_depth_2d,Hr.keywords.texture_depth_2d_array,Hr.keywords.texture_depth_cube,Hr.keywords.texture_depth_cube_array,Hr.keywords.texture_depth_multisampled_2d],qe.texture_external_type=[Hr.keywords.texture_external],qe.any_texture_type=[...Hr.sampled_texture_type,...Hr.multisampled_texture_type,...Hr.storage_texture_type,...Hr.depth_texture_type,...Hr.texture_external_type],qe.texel_format=[Hr.keywords.r8unorm,Hr.keywords.r8snorm,Hr.keywords.r8uint,Hr.keywords.r8sint,Hr.keywords.r16uint,Hr.keywords.r16sint,Hr.keywords.r16float,Hr.keywords.rg8unorm,Hr.keywords.rg8snorm,Hr.keywords.rg8uint,Hr.keywords.rg8sint,Hr.keywords.r32uint,Hr.keywords.r32sint,Hr.keywords.r32float,Hr.keywords.rg16uint,Hr.keywords.rg16sint,Hr.keywords.rg16float,Hr.keywords.rgba8unorm,Hr.keywords.rgba8unorm_srgb,Hr.keywords.rgba8snorm,Hr.keywords.rgba8uint,Hr.keywords.rgba8sint,Hr.keywords.bgra8unorm,Hr.keywords.bgra8unorm_srgb,Hr.keywords.rgb10a2unorm,Hr.keywords.rg11b10float,Hr.keywords.rg32uint,Hr.keywords.rg32sint,Hr.keywords.rg32float,Hr.keywords.rgba16uint,Hr.keywords.rgba16sint,Hr.keywords.rgba16float,Hr.keywords.rgba32uint,Hr.keywords.rgba32sint,Hr.keywords.rgba32float],qe.const_literal=[Hr.tokens.int_literal,Hr.tokens.uint_literal,Hr.tokens.decimal_float_literal,Hr.tokens.hex_float_literal,Hr.keywords.true,Hr.keywords.false],qe.literal_or_ident=[Hr.tokens.ident,Hr.tokens.int_literal,Hr.tokens.uint_literal,Hr.tokens.decimal_float_literal,Hr.tokens.hex_float_literal,Hr.tokens.name],qe.element_count_expression=[Hr.tokens.int_literal,Hr.tokens.uint_literal,Hr.tokens.ident],qe.template_types=[Hr.keywords.vec2,Hr.keywords.vec3,Hr.keywords.vec4,Hr.keywords.mat2x2,Hr.keywords.mat2x3,Hr.keywords.mat2x4,Hr.keywords.mat3x2,Hr.keywords.mat3x3,Hr.keywords.mat3x4,Hr.keywords.mat4x2,Hr.keywords.mat4x3,Hr.keywords.mat4x4,Hr.keywords.atomic,Hr.keywords.bitcast,...Hr.any_texture_type],qe.attribute_name=[Hr.tokens.ident,Hr.keywords.block,Hr.keywords.diagnostic],qe.assignment_operators=[Hr.tokens.equal,Hr.tokens.plus_equal,Hr.tokens.minus_equal,Hr.tokens.times_equal,Hr.tokens.division_equal,Hr.tokens.modulo_equal,Hr.tokens.and_equal,Hr.tokens.or_equal,Hr.tokens.xor_equal,Hr.tokens.shift_right_equal,Hr.tokens.shift_left_equal],qe.increment_operators=[Hr.tokens.plus_plus,Hr.tokens.minus_minus];class He{constructor(i,m,g,x,_){this.type=i,this.lexeme=m,this.line=g,this.start=x,this.end=_}toString(){return this.lexeme}isTemplateType(){return-1!=qe.template_types.indexOf(this.type)}isArrayType(){return this.type==qe.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class ze{constructor(i){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=i?i:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new He(qe.eof,"",this._line,this._current,this._current)),this._tokens}scanToken(){let i=this._advance();if("\n"==i)return this._line++,!0;if(this._isWhitespace(i))return!0;if("/"==i){if("/"==this._peekAhead()){for(;"\n"!=i;){if(this._isAtEnd())return!0;i=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let m=1;for(;m>0;){if(this._isAtEnd())return!0;if(i=this._advance(),"\n"==i)this._line++;else if("*"==i){if("/"==this._peekAhead()&&(this._advance(),m--,0==m))return!0}else"/"==i&&"*"==this._peekAhead()&&(this._advance(),m++)}return!0}}const m=qe.simpleTokens[i];if(m)return this._addToken(m),!0;let g=qe.none;const x=this._isAlpha(i),_="_"===i;if(this._isAlphaNumeric(i)){let m=this._peekAhead();for(;this._isAlphaNumeric(m);)i+=this._advance(),m=this._peekAhead()}if(x){const m=qe.keywords[i];if(m)return this._addToken(m),!0}if(x||_)return this._addToken(qe.tokens.ident),!0;for(;;){let m=this._findType(i);const x=this._peekAhead();if("-"==i&&this._tokens.length>0){if("="==x)return this._current++,i+=x,this._addToken(qe.tokens.minus_equal),!0;if("-"==x)return this._current++,i+=x,this._addToken(qe.tokens.minus_minus),!0;const g=this._tokens.length-1;if((-1!=qe.literal_or_ident.indexOf(this._tokens[g].type)||this._tokens[g].type==qe.tokens.paren_right)&&">"!=x)return this._addToken(m),!0}if(">"==i&&(">"==x||"="==x)){let i=!1,g=this._tokens.length-1;for(let m=0;m<5&&g>=0&&-1===qe.assignment_operators.indexOf(this._tokens[g].type);++m,--g)if(this._tokens[g].type===qe.tokens.less_than){g>0&&this._tokens[g-1].isArrayOrTemplateType()&&(i=!0);break}if(i)return this._addToken(m),!0}if(m===qe.none){let x=i,_=0;const b=2;for(let i=0;i<b;++i)if(x+=this._peekAhead(i),m=this._findType(x),m!==qe.none){_=i;break}if(m===qe.none)return g!==qe.none&&(this._current--,this._addToken(g),!0);i=x,this._current+=_+1}if(g=m,this._isAtEnd())break;i+=this._advance()}return g!==qe.none&&(this._addToken(g),!0)}_findType(i){for(const m in qe.regexTokens){const g=qe.regexTokens[m];if(this._match(i,g.rule))return g}return qe.literalTokens[i]||qe.none}_match(i,m){const g=m.exec(i);return g&&0==g.index&&g[0]==i}_isAtEnd(){return this._current>=this._source.length}_isAlpha(i){return!this._isNumeric(i)&&!this._isWhitespace(i)&&"_"!==i&&"."!==i&&"("!==i&&")"!==i&&"["!==i&&"]"!==i&&"{"!==i&&"}"!==i&&","!==i&&";"!==i&&":"!==i&&"="!==i&&"!"!==i&&"<"!==i&&">"!==i&&"+"!==i&&"-"!==i&&"*"!==i&&"/"!==i&&"%"!==i&&"&"!==i&&"|"!==i&&"^"!==i&&"~"!==i&&"@"!==i&&"#"!==i&&"?"!==i&&"'"!==i&&"`"!==i&&'"'!==i&&"\\"!==i&&"\n"!==i&&"\r"!==i&&"\t"!==i&&"\0"!==i}_isNumeric(i){return i>="0"&&i<="9"}_isAlphaNumeric(i){return this._isAlpha(i)||this._isNumeric(i)||"_"===i}_isWhitespace(i){return" "==i||"\t"==i||"\r"==i}_advance(i=0){let m=this._source[this._current];return i=i||0,i++,this._current+=i,m}_peekAhead(i=0){return i=i||0,this._current+i>=this._source.length?"\0":this._source[this._current+i]}_addToken(i){const m=this._source.substring(this._start,this._current);this._tokens.push(new He(i,m,this._line,this._start,this._current))}}function Re(i){return Array.isArray(i)||(null==i?void 0:i.buffer)instanceof ArrayBuffer}const Kr=new Float32Array(1),Wr=new Uint32Array(Kr.buffer),Xr=new Uint32Array(Kr.buffer),jr=new Int32Array(1),Yr=new Float32Array(jr.buffer),Zr=new Uint32Array(jr.buffer),Jr=new Uint32Array(1),Qr=new Float32Array(Jr.buffer),en=new Int32Array(Jr.buffer);function tt(i,m,g){if(m===g)return i;if("f32"===m){if("i32"===g||"x32"===g)return Kr[0]=i,Wr[0];if("u32"===g)return Kr[0]=i,Xr[0]}else if("i32"===m||"x32"===m){if("f32"===g)return jr[0]=i,Yr[0];if("u32"===g)return jr[0]=i,Zr[0]}else if("u32"===m){if("f32"===g)return Jr[0]=i,Qr[0];if("i32"===g||"x32"===g)return Jr[0]=i,en[0]}return console.error(`Unsupported cast from ${m} to ${g}`),i}class nt{constructor(i){this.resources=null,this.inUse=!1,this.info=null,this.node=i}}class st{constructor(i,m){this.align=i,this.size=m}}class rt{constructor(){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new d,this.functions=[],this._types=new Map,this._functions=new Map}_isStorageTexture(i){return"texture_storage_1d"==i.name||"texture_storage_2d"==i.name||"texture_storage_2d_array"==i.name||"texture_storage_3d"==i.name}updateAST(i){for(const m of i)m instanceof C&&this._functions.set(m.name,new nt(m));for(const m of i)if(m instanceof ie){const i=this.getTypeInfo(m,null);i instanceof n&&this.structs.push(i)}for(const m of i)if(m instanceof ee)this.aliases.push(this._getAliasInfo(m));else if(m instanceof F){const i=m,g=this._getAttributeNum(i.attributes,"id",0),x=null!=i.type?this.getTypeInfo(i.type,i.attributes):null;this.overrides.push(new h(i.name,x,i.attributes,g))}else if(this._isUniformVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),x=this._getAttributeNum(i.attributes,"binding",0),_=this.getTypeInfo(i.type,i.attributes),b=new o(i.name,_,g,x,i.attributes,Dr.Uniform,i.access);b.access||(b.access="read"),this.uniforms.push(b)}else if(this._isStorageVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),x=this._getAttributeNum(i.attributes,"binding",0),_=this.getTypeInfo(i.type,i.attributes),b=this._isStorageTexture(_),y=new o(i.name,_,g,x,i.attributes,b?Dr.StorageTexture:Dr.Storage,i.access);y.access||(y.access="read"),this.storage.push(y)}else if(this._isTextureVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),x=this._getAttributeNum(i.attributes,"binding",0),_=this.getTypeInfo(i.type,i.attributes),b=this._isStorageTexture(_),y=new o(i.name,_,g,x,i.attributes,b?Dr.StorageTexture:Dr.Texture,i.access);y.access||(y.access="read"),b?this.storage.push(y):this.textures.push(y)}else if(this._isSamplerVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),x=this._getAttributeNum(i.attributes,"binding",0),_=this.getTypeInfo(i.type,i.attributes),b=new o(i.name,_,g,x,i.attributes,Dr.Sampler,i.access);this.samplers.push(b)}for(const m of i)if(m instanceof C){const i=this._getAttribute(m,"vertex"),g=this._getAttribute(m,"fragment"),x=this._getAttribute(m,"compute"),_=i||g||x,b=new p(m.name,null==_?void 0:_.name,m.attributes);b.attributes=m.attributes,b.startLine=m.startLine,b.endLine=m.endLine,this.functions.push(b),this._functions.get(m.name).info=b,_&&(this._functions.get(m.name).inUse=!0,b.inUse=!0,b.resources=this._findResources(m,!!_),b.inputs=this._getInputs(m.args),b.outputs=this._getOutputs(m.returnType),this.entry[_.name].push(b)),b.arguments=m.args.map(i=>new f(i.name,this.getTypeInfo(i.type,i.attributes),i.attributes)),b.returnType=m.returnType?this.getTypeInfo(m.returnType,m.attributes):null}for(const i of this._functions.values())i.info&&(i.info.inUse=i.inUse,this._addCalls(i.node,i.info.calls));for(const i of this._functions.values())i.node.search(m=>{var g,x,_;if(m instanceof Ce){if(m.value)if(Re(m.value))for(const x of m.value)for(const m of this.overrides)x===m.name&&(null===(g=i.info)||void 0===g||g.overrides.push(m));else for(const g of this.overrides)m.value===g.name&&(null===(x=i.info)||void 0===x||x.overrides.push(g))}else if(m instanceof me)for(const g of this.overrides)m.name===g.name&&(null===(_=i.info)||void 0===_||_.overrides.push(g))});for(const i of this.uniforms)this._markStructsInUse(i.type);for(const i of this.storage)this._markStructsInUse(i.type)}getStructInfo(i){for(const m of this.structs)if(m.name==i)return m;return null}getOverrideInfo(i){for(const m of this.overrides)if(m.name==i)return m;return null}_markStructsInUse(i){if(i)if(i.isStruct){if(i.inUse=!0,i.members)for(const m of i.members)this._markStructsInUse(m.type)}else if(i.isArray)this._markStructsInUse(i.format);else if(i.isTemplate)i.format&&this._markStructsInUse(i.format);else{const m=this._getAlias(i.name);m&&this._markStructsInUse(m)}}_addCalls(i,m){var g;for(const x of i.calls){const i=null===(g=this._functions.get(x.name))||void 0===g?void 0:g.info;i&&m.add(i)}}findResource(i,m,g){if(g){for(const x of this.entry.compute)if(x.name===g)for(const g of x.resources)if(g.group==i&&g.binding==m)return g;for(const x of this.entry.vertex)if(x.name===g)for(const g of x.resources)if(g.group==i&&g.binding==m)return g;for(const x of this.entry.fragment)if(x.name===g)for(const g of x.resources)if(g.group==i&&g.binding==m)return g}for(const g of this.uniforms)if(g.group==i&&g.binding==m)return g;for(const g of this.storage)if(g.group==i&&g.binding==m)return g;for(const g of this.textures)if(g.group==i&&g.binding==m)return g;for(const g of this.samplers)if(g.group==i&&g.binding==m)return g;return null}_findResource(i){for(const m of this.uniforms)if(m.name==i)return m;for(const m of this.storage)if(m.name==i)return m;for(const m of this.textures)if(m.name==i)return m;for(const m of this.samplers)if(m.name==i)return m;return null}_markStructsFromAST(i){const m=this.getTypeInfo(i,null);this._markStructsInUse(m)}_findResources(i,m){const g=[],x=this,_=[];return i.search(b=>{if(b instanceof A)_.push({});else if(b instanceof E)_.pop();else if(b instanceof B){const i=b;m&&null!==i.type&&this._markStructsFromAST(i.type),_.length>0&&(_[_.length-1][i.name]=i)}else if(b instanceof pe){const i=b;m&&null!==i.type&&this._markStructsFromAST(i.type)}else if(b instanceof M){const i=b;m&&null!==i.type&&this._markStructsFromAST(i.type),_.length>0&&(_[_.length-1][i.name]=i)}else if(b instanceof me){const i=b;if(_.length>0&&_[_.length-1][i.name])return;const m=x._findResource(i.name);m&&g.push(m)}else if(b instanceof de){const _=b,y=x._functions.get(_.name);y&&(m&&(y.inUse=!0),i.calls.add(y.node),null===y.resources&&(y.resources=x._findResources(y.node,m)),g.push(...y.resources))}else if(b instanceof G){const _=b,y=x._functions.get(_.name);y&&(m&&(y.inUse=!0),i.calls.add(y.node),null===y.resources&&(y.resources=x._findResources(y.node,m)),g.push(...y.resources))}}),[...new Map(g.map(i=>[i.name,i])).values()]}getBindGroups(){const i=[];function t(m,g){m>=i.length&&(i.length=m+1),void 0===i[m]&&(i[m]=[]),g>=i[m].length&&(i[m].length=g+1)}for(const m of this.uniforms)t(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.storage)t(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.textures)t(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.samplers)t(m.group,m.binding),i[m.group][m.binding]=m;return i}_getOutputs(i,m=void 0){if(void 0===m&&(m=[]),i instanceof ie)this._getStructOutputs(i,m);else{const g=this._getOutputInfo(i);null!==g&&m.push(g)}return m}_getStructOutputs(i,m){for(const g of i.members)if(g.type instanceof ie)this._getStructOutputs(g.type,m);else{const i=this._getAttribute(g,"location")||this._getAttribute(g,"builtin");if(null!==i){const x=this.getTypeInfo(g.type,g.type.attributes),_=this._parseInt(i.value),b=new u(g.name,x,i.name,_);m.push(b)}}}_getOutputInfo(i){const m=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==m){const g=this.getTypeInfo(i,i.attributes),x=this._parseInt(m.value);return new u("",g,m.name,x)}return null}_getInputs(i,m=void 0){void 0===m&&(m=[]);for(const g of i)if(g.type instanceof ie)this._getStructInputs(g.type,m);else{const i=this._getInputInfo(g);null!==i&&m.push(i)}return m}_getStructInputs(i,m){for(const g of i.members)if(g.type instanceof ie)this._getStructInputs(g.type,m);else{const i=this._getInputInfo(g);null!==i&&m.push(i)}}_getInputInfo(i){const m=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==m){const g=this._getAttribute(i,"interpolation"),x=this.getTypeInfo(i.type,i.attributes),_=this._parseInt(m.value),b=new c(i.name,x,m.name,_);return null!==g&&(b.interpolation=this._parseString(g.value)),b}return null}_parseString(i){return i instanceof Array&&(i=i[0]),i}_parseInt(i){i instanceof Array&&(i=i[0]);const m=parseInt(i);return isNaN(m)?i:m}_getAlias(i){for(const m of this.aliases)if(m.name==i)return m.type;return null}_getAliasInfo(i){return new l(i.name,this.getTypeInfo(i.type,null))}getTypeInfoByName(i){for(const m of this.structs)if(m.name==i)return m;for(const m of this.aliases)if(m.name==i)return m.type;return null}getTypeInfo(i,m=null){if(this._types.has(i))return this._types.get(i);if(i instanceof le){const g=i.type?this.getTypeInfo(i.type,i.attributes):null,x=new r(i.name,g,m);return this._types.set(i,x),this._updateTypeInfo(x),x}if(i instanceof ce){const g=i,x=g.format?this.getTypeInfo(g.format,g.attributes):null,_=new s(g.name,m);return _.format=x,_.count=g.count,this._types.set(i,_),this._updateTypeInfo(_),_}if(i instanceof ie){const g=i,x=new n(g.name,m);x.startLine=g.startLine,x.endLine=g.endLine;for(const i of g.members){const m=this.getTypeInfo(i.type,i.attributes);x.members.push(new t(i.name,m,i.attributes))}return this._types.set(i,x),this._updateTypeInfo(x),x}if(i instanceof ue){const g=i,x=g.format instanceof re,_=g.format?x?this.getTypeInfo(g.format,null):new e(g.format,null):null,b=new a(g.name,_,m,g.access);return this._types.set(i,b),this._updateTypeInfo(b),b}if(i instanceof oe){const g=i,x=g.format?this.getTypeInfo(g.format,null):null,_=new a(g.name,x,m,g.access);return this._types.set(i,_),this._updateTypeInfo(_),_}const g=new e(i.name,m);return this._types.set(i,g),this._updateTypeInfo(g),g}_updateTypeInfo(i){var m,g,x;const _=this._getTypeSize(i);if(i.size=null!==(m=null==_?void 0:_.size)&&void 0!==m?m:0,i instanceof s&&i.format){const m=this._getTypeSize(i.format);i.stride=Math.max(null!==(g=null==m?void 0:m.size)&&void 0!==g?g:0,null!==(x=null==m?void 0:m.align)&&void 0!==x?x:0),this._updateTypeInfo(i.format)}i instanceof r&&this._updateTypeInfo(i.format),i instanceof n&&this._updateStructInfo(i)}_updateStructInfo(i){var m;let g=0,x=0,_=0,b=0;for(let y=0,T=i.members.length;y<T;++y){const T=i.members[y],w=this._getTypeSize(T);if(!w)continue;null!==(m=this._getAlias(T.type.name))&&void 0!==m||T.type;const P=w.align,$=w.size;g=this._roundUp(P,g+x),x=$,_=g,b=Math.max(b,P),T.offset=g,T.size=$,this._updateTypeInfo(T.type)}i.size=this._roundUp(b,_+x),i.align=b}_getTypeSize(i){var m,g;if(null==i)return null;const x=this._getAttributeNum(i.attributes,"size",0),_=this._getAttributeNum(i.attributes,"align",0);if(i instanceof t&&(i=i.type),i instanceof e){const m=this._getAlias(i.name);null!==m&&(i=m)}{const g=rt._typeInfo[i.name];if(void 0!==g){const b="f16"===(null===(m=i.format)||void 0===m?void 0:m.name)?2:1;return new st(Math.max(_,g.align/b),Math.max(x,g.size/b))}}{const m=rt._typeInfo[i.name.substring(0,i.name.length-1)];if(m){const g="h"===i.name[i.name.length-1]?2:1;return new st(Math.max(_,m.align/g),Math.max(x,m.size/g))}}if(i instanceof s){let m=i,b=8,y=8;const T=this._getTypeSize(m.format);return null!==T&&(y=T.size,b=T.align),y=m.count*this._getAttributeNum(null!==(g=null==i?void 0:i.attributes)&&void 0!==g?g:null,"stride",this._roundUp(b,y)),x&&(y=x),new st(Math.max(_,b),Math.max(x,y))}if(i instanceof n){let m=0,g=0,b=0,y=0,T=0;for(const g of i.members){const i=this._getTypeSize(g.type);null!==i&&(m=Math.max(i.align,m),b=this._roundUp(i.align,b+y),y=i.size,T=b)}return g=this._roundUp(m,T+y),new st(Math.max(_,m),Math.max(x,g))}return null}_isUniformVar(i){return i instanceof B&&"uniform"==i.storage}_isStorageVar(i){return i instanceof B&&"storage"==i.storage}_isTextureVar(i){return i instanceof B&&null!==i.type&&-1!=rt._textureTypes.indexOf(i.type.name)}_isSamplerVar(i){return i instanceof B&&null!==i.type&&-1!=rt._samplerTypes.indexOf(i.type.name)}_getAttribute(i,m){const g=i;if(!g||!g.attributes)return null;const x=g.attributes;for(let i of x)if(i.name==m)return i;return null}_getAttributeNum(i,m,g){if(null===i)return g;for(let x of i)if(x.name==m){let i=null!==x&&null!==x.value?x.value:g;return i instanceof Array&&(i=i[0]),"number"==typeof i?i:"string"==typeof i?parseInt(i):g}return g}_roundUp(i,m){return Math.ceil(m/i)*i}}rt._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},rt._textureTypes=qe.any_texture_type.map(i=>i.name),rt._samplerTypes=qe.sampler_type.map(i=>i.name);let tn=0;class it{constructor(i,m,g){this.id=tn++,this.name=i,this.value=m,this.node=g}clone(){return new it(this.name,this.value,this.node)}}class ot{constructor(i){this.id=tn++,this.name=i.name,this.node=i}clone(){return new ot(this.node)}}class lt{constructor(i){this.parent=null,this.variables=new Map,this.functions=new Map,this.currentFunctionName="",this.id=tn++,i&&(this.parent=i,this.currentFunctionName=i.currentFunctionName)}getVariable(i){var m;return this.variables.has(i)?null!==(m=this.variables.get(i))&&void 0!==m?m:null:this.parent?this.parent.getVariable(i):null}getFunction(i){var m;return this.functions.has(i)?null!==(m=this.functions.get(i))&&void 0!==m?m:null:this.parent?this.parent.getFunction(i):null}createVariable(i,m,g){this.variables.set(i,new it(i,m,null!=g?g:null))}setVariable(i,m,g){const x=this.getVariable(i);null!==x?x.value=m:this.createVariable(i,m,g)}getVariableValue(i){var m;const g=this.getVariable(i);return null!==(m=null==g?void 0:g.value)&&void 0!==m?m:null}clone(){return new lt(this)}}class ct{evalExpression(i,m){return null}getTypeInfo(i){return null}getVariableName(i,m){return""}}class ut{constructor(i){this.exec=i}getTypeInfo(i){return this.exec.getTypeInfo(i)}All(i,m){const g=this.exec.evalExpression(i.args[0],m);let x=!0;if(g instanceof Fe)return g.data.forEach(i=>{i||(x=!1)}),new Oe(x?1:0,this.getTypeInfo("bool"));throw new Error(`All() expects a vector argument. Line ${i.line}`)}Any(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe){const i=g.data.some(i=>i);return new Oe(i?1:0,this.getTypeInfo("bool"))}throw new Error(`Any() expects a vector argument. Line ${i.line}`)}Select(i,m){const g=this.exec.evalExpression(i.args[2],m);if(!(g instanceof Oe))throw new Error(`Select() expects a bool condition. Line ${i.line}`);return g.value?this.exec.evalExpression(i.args[1],m):this.exec.evalExpression(i.args[0],m)}ArrayLength(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.evalExpression(g,m);if(x instanceof Ue&&0===x.typeInfo.size){const i=x.typeInfo,m=x.buffer.byteLength/i.stride;return new Oe(m,this.getTypeInfo("u32"))}return new Oe(x.typeInfo.size,this.getTypeInfo("u32"))}Abs(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.abs(i)),g.typeInfo);const x=g;return new Oe(Math.abs(x.value),x.typeInfo)}Acos(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.acos(i)),g.typeInfo);const x=g;return new Oe(Math.acos(x.value),g.typeInfo)}Acosh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.acosh(i)),g.typeInfo);const x=g;return new Oe(Math.acosh(x.value),g.typeInfo)}Asin(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.asin(i)),g.typeInfo);const x=g;return new Oe(Math.asin(x.value),g.typeInfo)}Asinh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.asinh(i)),g.typeInfo);const x=g;return new Oe(Math.asinh(x.value),g.typeInfo)}Atan(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.atan(i)),g.typeInfo);const x=g;return new Oe(Math.atan(x.value),g.typeInfo)}Atanh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.atanh(i)),g.typeInfo);const x=g;return new Oe(Math.atanh(x.value),g.typeInfo)}Atan2(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe)return new Fe(g.data.map((i,m)=>Math.atan2(i,x.data[m])),g.typeInfo);const _=g,b=x;return new Oe(Math.atan2(_.value,b.value),g.typeInfo)}Ceil(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.ceil(i)),g.typeInfo);const x=g;return new Oe(Math.ceil(x.value),g.typeInfo)}_clamp(i,m,g){return Math.min(Math.max(i,m),g)}Clamp(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&x instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>this._clamp(i,x.data[m],_.data[m])),g.typeInfo);const b=g,y=x,T=_;return new Oe(this._clamp(b.value,y.value,T.value),g.typeInfo)}Cos(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.cos(i)),g.typeInfo);const x=g;return new Oe(Math.cos(x.value),g.typeInfo)}Cosh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.cosh(i)),g.typeInfo);const x=g;return new Oe(Math.cos(x.value),g.typeInfo)}CountLeadingZeros(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.clz32(i)),g.typeInfo);const x=g;return new Oe(Math.clz32(x.value),g.typeInfo)}_countOneBits(i){let m=0;for(;0!==i;)1&i&&m++,i>>=1;return m}CountOneBits(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._countOneBits(i)),g.typeInfo);const x=g;return new Oe(this._countOneBits(x.value),g.typeInfo)}_countTrailingZeros(i){if(0===i)return 32;let m=0;for(;!(1&i);)i>>=1,m++;return m}CountTrailingZeros(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._countTrailingZeros(i)),g.typeInfo);const x=g;return new Oe(this._countTrailingZeros(x.value),g.typeInfo)}Cross(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe){if(3!==g.data.length||3!==x.data.length)return console.error(`Cross() expects 3D vectors. Line ${i.line}`),null;const m=g.data,_=x.data;return new Fe([m[1]*_[2]-_[1]*m[2],m[2]*_[0]-_[2]*m[0],m[0]*_[1]-_[0]*m[1]],g.typeInfo)}return console.error(`Cross() expects vector arguments. Line ${i.line}`),null}Degrees(i,m){const g=this.exec.evalExpression(i.args[0],m),x=180/Math.PI;return g instanceof Fe?new Fe(g.data.map(i=>i*x),g.typeInfo):new Oe(g.value*x,this.getTypeInfo("f32"))}Determinant(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Me){const i=g.data,m=g.typeInfo.getTypeName(),x=m.endsWith("h")?this.getTypeInfo("f16"):this.getTypeInfo("f32");if("mat2x2"===m||"mat2x2f"===m||"mat2x2h"===m)return new Oe(i[0]*i[3]-i[1]*i[2],x);if("mat2x3"===m||"mat2x3f"===m||"mat2x3h"===m)return new Oe(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),x);if("mat2x4"===m||"mat2x4f"===m||"mat2x4h"===m)console.error(`TODO:Determinant for ${m}`);else if("mat3x2"===m||"mat3x2f"===m||"mat3x2h"===m)console.error(`TODO:Determinant for ${m}`);else{if("mat3x3"===m||"mat3x3f"===m||"mat3x3h"===m)return new Oe(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),x);"mat3x4"===m||"mat3x4f"===m||"mat3x4h"===m||"mat4x2"===m||"mat4x2f"===m||"mat4x2h"===m||"mat4x3"===m||"mat4x3f"===m||"mat4x3h"===m?console.error(`TODO:Determinant for ${m}`):"mat4x4"!==m&&"mat4x4f"!==m&&"mat4x4h"!==m||console.error(`TODO:Determinant for ${m}`)}}return console.error(`Determinant expects a matrix argument. Line ${i.line}`),null}Distance(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe){let i=0;for(let m=0;m<g.data.length;++m)i+=(g.data[m]-x.data[m])*(g.data[m]-x.data[m]);return new Oe(Math.sqrt(i),this.getTypeInfo("f32"))}const _=g,b=x;return new Oe(Math.abs(_.value-b.value),g.typeInfo)}_dot(i,m){let g=0;for(let x=0;x<i.length;++x)g+=m[x]*i[x];return g}Dot(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);return g instanceof Fe&&x instanceof Fe?new Oe(this._dot(g.data,x.data),this.getTypeInfo("f32")):(console.error(`Dot() expects vector arguments. Line ${i.line}`),null)}Dot4U8Packed(i,m){return console.error(`TODO:dot4U8Packed. Line ${i.line}`),null}Dot4I8Packed(i,m){return console.error(`TODO:dot4I8Packed. Line ${i.line}`),null}Exp(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.exp(i)),g.typeInfo);const x=g;return new Oe(Math.exp(x.value),g.typeInfo)}Exp2(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.pow(2,i)),g.typeInfo);const x=g;return new Oe(Math.pow(2,x.value),g.typeInfo)}ExtractBits(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m);if("u32"!==x.typeInfo.name&&"x32"!==x.typeInfo.name)return console.error(`ExtractBits() expects an i32 offset argument. Line ${i.line}`),null;if("u32"!==_.typeInfo.name&&"x32"!==_.typeInfo.name)return console.error(`ExtractBits() expects an i32 count argument. Line ${i.line}`),null;const b=x.value,y=_.value;if(g instanceof Fe)return new Fe(g.data.map(i=>i>>b&(1<<y)-1),g.typeInfo);if("i32"!==g.typeInfo.name&&"x32"!==g.typeInfo.name)return console.error(`ExtractBits() expects an i32 argument. Line ${i.line}`),null;const T=g.value;return new Oe(T>>b&(1<<y)-1,this.getTypeInfo("i32"))}FaceForward(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&x instanceof Fe&&_ instanceof Fe){const i=this._dot(x.data,_.data);return new Fe(i<0?Array.from(g.data):g.data.map(i=>-i),g.typeInfo)}return console.error(`FaceForward() expects vector arguments. Line ${i.line}`),null}_firstLeadingBit(i){return 0===i?-1:31-Math.clz32(i)}FirstLeadingBit(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._firstLeadingBit(i)),g.typeInfo);const x=g;return new Oe(this._firstLeadingBit(x.value),g.typeInfo)}_firstTrailingBit(i){return 0===i?-1:Math.log2(i&-i)}FirstTrailingBit(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._firstTrailingBit(i)),g.typeInfo);const x=g;return new Oe(this._firstTrailingBit(x.value),g.typeInfo)}Floor(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.floor(i)),g.typeInfo);const x=g;return new Oe(Math.floor(x.value),g.typeInfo)}Fma(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&x instanceof Fe&&_ instanceof Fe)return g.data.length!==x.data.length||g.data.length!==_.data.length?(console.error(`Fma() expects vectors of the same length. Line ${i.line}`),null):new Fe(g.data.map((i,m)=>i*x.data[m]+_.data[m]),g.typeInfo);const b=g,y=x,T=_;return new Oe(b.value*y.value+T.value,b.typeInfo)}Fract(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>i-Math.floor(i)),g.typeInfo);const x=g;return new Oe(x.value-Math.floor(x.value),g.typeInfo)}Frexp(i,m){return console.error(`TODO:frexp. Line ${i.line}`),null}InsertBits(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m),b=this.exec.evalExpression(i.args[3],m);if("u32"!==_.typeInfo.name&&"x32"!==_.typeInfo.name)return console.error(`InsertBits() expects an i32 offset argument. Line ${i.line}`),null;const y=_.value,T=(1<<b.value)-1<<y,w=~T;if(g instanceof Fe&&x instanceof Fe)return new Fe(g.data.map((i,m)=>i&w|x.data[m]<<y&T),g.typeInfo);const P=g.value,$=x.value;return new Oe(P&w|$<<y&T,g.typeInfo)}InverseSqrt(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>1/Math.sqrt(i)),g.typeInfo);const x=g;return new Oe(1/Math.sqrt(x.value),g.typeInfo)}Ldexp(i,m){return console.error(`TODO:ldexp. Line ${i.line}`),null}Length(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe){let i=0;return g.data.forEach(m=>{i+=m*m}),new Oe(Math.sqrt(i),this.getTypeInfo("f32"))}const x=g;return new Oe(Math.abs(x.value),g.typeInfo)}Log(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.log(i)),g.typeInfo);const x=g;return new Oe(Math.log(x.value),g.typeInfo)}Log2(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.log2(i)),g.typeInfo);const x=g;return new Oe(Math.log2(x.value),g.typeInfo)}Max(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe)return new Fe(g.data.map((i,m)=>Math.max(i,x.data[m])),g.typeInfo);const _=g,b=x;return new Oe(Math.max(_.value,b.value),g.typeInfo)}Min(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe)return new Fe(g.data.map((i,m)=>Math.min(i,x.data[m])),g.typeInfo);const _=g,b=x;return new Oe(Math.min(_.value,b.value),g.typeInfo)}Mix(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&x instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>g.data[m]*(1-_.data[m])+x.data[m]*_.data[m]),g.typeInfo);const b=x,y=_;return new Oe(g.value*(1-y.value)+b.value*y.value,g.typeInfo)}Modf(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe)return new Fe(g.data.map((i,m)=>i%x.data[m]),g.typeInfo);const _=x;return new Oe(g.value%_.value,g.typeInfo)}Normalize(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe){const x=this.Length(i,m).value;return new Fe(g.data.map(i=>i/x),g.typeInfo)}return console.error(`Normalize() expects a vector argument. Line ${i.line}`),null}Pow(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe)return new Fe(g.data.map((i,m)=>Math.pow(i,x.data[m])),g.typeInfo);const _=g,b=x;return new Oe(Math.pow(_.value,b.value),g.typeInfo)}QuantizeToF16(i,m){const g=this.exec.evalExpression(i.args[0],m);return g instanceof Fe?new Fe(g.data.map(i=>i),g.typeInfo):new Oe(g.value,g.typeInfo)}Radians(i,m){const g=this.exec.evalExpression(i.args[0],m);return g instanceof Fe?new Fe(g.data.map(i=>i*Math.PI/180),g.typeInfo):new Oe(g.value*Math.PI/180,this.getTypeInfo("f32"))}Reflect(i,m){let g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&x instanceof Fe){const i=this._dot(g.data,x.data);return new Fe(g.data.map((m,g)=>m-2*i*x.data[g]),g.typeInfo)}return console.error(`Reflect() expects vector arguments. Line ${i.line}`),null}Refract(i,m){let g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&x instanceof Fe&&_ instanceof Oe){const i=this._dot(x.data,g.data);return new Fe(g.data.map((m,g)=>{const b=1-_.value*_.value*(1-i*i);if(b<0)return 0;const y=Math.sqrt(b);return _.value*m-(_.value*i+y)*x.data[g]}),g.typeInfo)}return console.error(`Refract() expects vector arguments and a scalar argument. Line ${i.line}`),null}ReverseBits(i,m){return console.error(`TODO:reverseBits. Line ${i.line}`),null}Round(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.round(i)),g.typeInfo);const x=g;return new Oe(Math.round(x.value),g.typeInfo)}Saturate(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.min(Math.max(i,0),1)),g.typeInfo);const x=g;return new Oe(Math.min(Math.max(x.value,0),1),g.typeInfo)}Sign(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sign(i)),g.typeInfo);const x=g;return new Oe(Math.sign(x.value),g.typeInfo)}Sin(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sin(i)),g.typeInfo);const x=g;return new Oe(Math.sin(x.value),g.typeInfo)}Sinh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sinh(i)),g.typeInfo);const x=g;return new Oe(Math.sinh(x.value),g.typeInfo)}_smoothstep(i,m,g){const x=Math.min(Math.max((g-i)/(m-i),0),1);return x*x*(3-2*x)}SmoothStep(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m),_=this.exec.evalExpression(i.args[2],m);if(_ instanceof Fe&&g instanceof Fe&&x instanceof Fe)return new Fe(_.data.map((i,m)=>this._smoothstep(g.data[m],x.data[m],i)),_.typeInfo);const b=g,y=x,T=_;return new Oe(this._smoothstep(b.value,y.value,T.value),_.typeInfo)}Sqrt(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sqrt(i)),g.typeInfo);const x=g;return new Oe(Math.sqrt(x.value),g.typeInfo)}Step(i,m){const g=this.exec.evalExpression(i.args[0],m),x=this.exec.evalExpression(i.args[1],m);if(x instanceof Fe&&g instanceof Fe)return new Fe(x.data.map((i,m)=>i<g.data[m]?0:1),x.typeInfo);const _=g;return new Oe(x.value<_.value?0:1,_.typeInfo)}Tan(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.tan(i)),g.typeInfo);const x=g;return new Oe(Math.tan(x.value),g.typeInfo)}Tanh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.tanh(i)),g.typeInfo);const x=g;return new Oe(Math.tanh(x.value),g.typeInfo)}_getTransposeType(i){const m=i.getTypeName();return"mat2x2f"===m||"mat2x2h"===m?i:"mat2x3f"===m?this.getTypeInfo("mat3x2f"):"mat2x3h"===m?this.getTypeInfo("mat3x2h"):"mat2x4f"===m?this.getTypeInfo("mat4x2f"):"mat2x4h"===m?this.getTypeInfo("mat4x2h"):"mat3x2f"===m?this.getTypeInfo("mat2x3f"):"mat3x2h"===m?this.getTypeInfo("mat2x3h"):"mat3x3f"===m||"mat3x3h"===m?i:"mat3x4f"===m?this.getTypeInfo("mat4x3f"):"mat3x4h"===m?this.getTypeInfo("mat4x3h"):"mat4x2f"===m?this.getTypeInfo("mat2x4f"):"mat4x2h"===m?this.getTypeInfo("mat2x4h"):"mat4x3f"===m?this.getTypeInfo("mat3x4f"):"mat4x3h"===m?this.getTypeInfo("mat3x4h"):("mat4x4f"===m||"mat4x4h"===m||console.error(`Invalid matrix type ${m}`),i)}Transpose(i,m){const g=this.exec.evalExpression(i.args[0],m);if(!(g instanceof Me))return console.error(`Transpose() expects a matrix argument. Line ${i.line}`),null;const x=this._getTransposeType(g.typeInfo);if("mat2x2"===g.typeInfo.name||"mat2x2f"===g.typeInfo.name||"mat2x2h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[2],i[1],i[3]],x)}if("mat2x3"===g.typeInfo.name||"mat2x3f"===g.typeInfo.name||"mat2x3h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[3],i[6],i[1],i[4],i[7]],x)}if("mat2x4"===g.typeInfo.name||"mat2x4f"===g.typeInfo.name||"mat2x4h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13]],x)}if("mat3x2"===g.typeInfo.name||"mat3x2f"===g.typeInfo.name||"mat3x2h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[3],i[1],i[4],i[2],i[5]],x)}if("mat3x3"===g.typeInfo.name||"mat3x3f"===g.typeInfo.name||"mat3x3h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[3],i[6],i[1],i[4],i[7],i[2],i[5],i[8]],x)}if("mat3x4"===g.typeInfo.name||"mat3x4f"===g.typeInfo.name||"mat3x4h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14]],x)}if("mat4x2"===g.typeInfo.name||"mat4x2f"===g.typeInfo.name||"mat4x2h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[1],i[5],i[2],i[6]],x)}if("mat4x3"===g.typeInfo.name||"mat4x3f"===g.typeInfo.name||"mat4x3h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[1],i[5],i[9],i[2],i[6],i[10]],x)}if("mat4x4"===g.typeInfo.name||"mat4x4f"===g.typeInfo.name||"mat4x4h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14],i[3],i[7],i[11],i[15]],x)}return console.error(`Invalid matrix type ${g.typeInfo.name}`),null}Trunc(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.trunc(i)),g.typeInfo);const x=g;return new Oe(Math.trunc(x.value),g.typeInfo)}Dpdx(i,m){return console.error(`TODO:dpdx. Line ${i.line}`),null}DpdxCoarse(i,m){return console.error(`TODO:dpdxCoarse. Line ${i.line}`),null}DpdxFine(i,m){return console.error("TODO:dpdxFine"),null}Dpdy(i,m){return console.error("TODO:dpdy"),null}DpdyCoarse(i,m){return console.error("TODO:dpdyCoarse"),null}DpdyFine(i,m){return console.error("TODO:dpdyFine"),null}Fwidth(i,m){return console.error("TODO:fwidth"),null}FwidthCoarse(i,m){return console.error("TODO:fwidthCoarse"),null}FwidthFine(i,m){return console.error("TODO:fwidthFine"),null}TextureDimensions(i,m){const g=i.args[0],x=i.args.length>1?this.exec.evalExpression(i.args[1],m).value:0;if(g instanceof me){const _=g.name,b=m.getVariableValue(_);if(b instanceof Pe){if(x<0||x>=b.mipLevelCount)return console.error(`Invalid mip level for textureDimensions. Line ${i.line}`),null;const m=b.getMipLevelSize(x),g=b.dimension;return"1d"===g?new Oe(m[0],this.getTypeInfo("u32")):"3d"===g?new Fe(m,this.getTypeInfo("vec3u")):"2d"===g?new Fe(m.slice(0,2),this.getTypeInfo("vec2u")):(console.error(`Invalid texture dimension ${g} not found. Line ${i.line}`),null)}return console.error(`Texture ${_} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureDimensions. Line ${i.line}`),null}TextureGather(i,m){return console.error("TODO:textureGather"),null}TextureGatherCompare(i,m){return console.error("TODO:textureGatherCompare"),null}TextureLoad(i,m){const g=i.args[0],x=this.exec.evalExpression(i.args[1],m),_=i.args.length>2?this.exec.evalExpression(i.args[2],m).value:0;if(!(x instanceof Fe)||2!==x.data.length)return console.error(`Invalid UV argument for textureLoad. Line ${i.line}`),null;if(g instanceof me){const b=g.name,y=m.getVariableValue(b);if(y instanceof Pe){const m=Math.floor(x.data[0]),g=Math.floor(x.data[1]);if(m<0||m>=y.width||g<0||g>=y.height)return console.error(`Texture ${b} out of bounds. Line ${i.line}`),null;const T=y.getPixel(m,g,0,_);return null===T?(console.error(`Invalid texture format for textureLoad. Line ${i.line}`),null):new Fe(T,this.getTypeInfo("vec4f"))}return console.error(`Texture ${b} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureLoad. Line ${i.line}`),null}TextureNumLayers(i,m){const g=i.args[0];if(g instanceof me){const x=g.name,_=m.getVariableValue(x);return _ instanceof Pe?new Oe(_.depthOrArrayLayers,this.getTypeInfo("u32")):(console.error(`Texture ${x} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLayers. Line ${i.line}`),null}TextureNumLevels(i,m){const g=i.args[0];if(g instanceof me){const x=g.name,_=m.getVariableValue(x);return _ instanceof Pe?new Oe(_.mipLevelCount,this.getTypeInfo("u32")):(console.error(`Texture ${x} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLevels. Line ${i.line}`),null}TextureNumSamples(i,m){const g=i.args[0];if(g instanceof me){const x=g.name,_=m.getVariableValue(x);return _ instanceof Pe?new Oe(_.sampleCount,this.getTypeInfo("u32")):(console.error(`Texture ${x} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumSamples. Line ${i.line}`),null}TextureSample(i,m){return console.error("TODO:textureSample"),null}TextureSampleBias(i,m){return console.error("TODO:textureSampleBias"),null}TextureSampleCompare(i,m){return console.error("TODO:textureSampleCompare"),null}TextureSampleCompareLevel(i,m){return console.error("TODO:textureSampleCompareLevel"),null}TextureSampleGrad(i,m){return console.error("TODO:textureSampleGrad"),null}TextureSampleLevel(i,m){return console.error("TODO:textureSampleLevel"),null}TextureSampleBaseClampToEdge(i,m){return console.error("TODO:textureSampleBaseClampToEdge"),null}TextureStore(i,m){const g=i.args[0],x=this.exec.evalExpression(i.args[1],m),_=4===i.args.length?this.exec.evalExpression(i.args[2],m).value:0,b=4===i.args.length?this.exec.evalExpression(i.args[3],m).data:this.exec.evalExpression(i.args[2],m).data;if(4!==b.length)return console.error(`Invalid value argument for textureStore. Line ${i.line}`),null;if(!(x instanceof Fe)||2!==x.data.length)return console.error(`Invalid UV argument for textureStore. Line ${i.line}`),null;if(g instanceof me){const y=g.name,T=m.getVariableValue(y);if(T instanceof Pe){const m=T.getMipLevelSize(0),g=Math.floor(x.data[0]),w=Math.floor(x.data[1]);return g<0||g>=m[0]||w<0||w>=m[1]?(console.error(`Texture ${y} out of bounds. Line ${i.line}`),null):(T.setPixel(g,w,0,_,Array.from(b)),null)}return console.error(`Texture ${y} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureStore. Line ${i.line}`),null}AtomicLoad(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m);return m.getVariable(x).value.getSubData(this.exec,g.postfix,m)}AtomicStore(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m);return T instanceof Oe&&y instanceof Oe&&(T.value=y.value),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),null}AtomicAdd(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value+=y.value),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicSub(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value-=y.value),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicMax(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value=Math.max(T.value,y.value)),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicMin(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value=Math.min(T.value,y.value)),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicAnd(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value=T.value&y.value),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicOr(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value=T.value|y.value),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicXor(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value=T.value^y.value),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicExchange(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const x=this.exec.getVariableName(g,m),_=m.getVariable(x);let b=i.args[1];const y=this.exec.evalExpression(b,m),T=_.value.getSubData(this.exec,g.postfix,m),w=new Oe(T.value,T.typeInfo);return T instanceof Oe&&y instanceof Oe&&(T.value=y.value),_.value instanceof Ue&&_.value.setDataValue(this.exec,T,g.postfix,m),w}AtomicCompareExchangeWeak(i,m){return console.error("TODO:atomicCompareExchangeWeak"),null}Pack4x8snorm(i,m){return console.error("TODO:pack4x8snorm"),null}Pack4x8unorm(i,m){return console.error("TODO:pack4x8unorm"),null}Pack4xI8(i,m){return console.error("TODO:pack4xI8"),null}Pack4xU8(i,m){return console.error("TODO:pack4xU8"),null}Pack4x8Clamp(i,m){return console.error("TODO:pack4x8Clamp"),null}Pack4xU8Clamp(i,m){return console.error("TODO:pack4xU8Clamp"),null}Pack2x16snorm(i,m){return console.error("TODO:pack2x16snorm"),null}Pack2x16unorm(i,m){return console.error("TODO:pack2x16unorm"),null}Pack2x16float(i,m){return console.error("TODO:pack2x16float"),null}Unpack4x8snorm(i,m){return console.error("TODO:unpack4x8snorm"),null}Unpack4x8unorm(i,m){return console.error("TODO:unpack4x8unorm"),null}Unpack4xI8(i,m){return console.error("TODO:unpack4xI8"),null}Unpack4xU8(i,m){return console.error("TODO:unpack4xU8"),null}Unpack2x16snorm(i,m){return console.error("TODO:unpack2x16snorm"),null}Unpack2x16unorm(i,m){return console.error("TODO:unpack2x16unorm"),null}Unpack2x16float(i,m){return console.error("TODO:unpack2x16float"),null}StorageBarrier(i,m){return null}TextureBarrier(i,m){return null}WorkgroupBarrier(i,m){return null}WorkgroupUniformLoad(i,m){return null}SubgroupAdd(i,m){return console.error("TODO:subgroupAdd"),null}SubgroupExclusiveAdd(i,m){return console.error("TODO:subgroupExclusiveAdd"),null}SubgroupInclusiveAdd(i,m){return console.error("TODO:subgroupInclusiveAdd"),null}SubgroupAll(i,m){return console.error("TODO:subgroupAll"),null}SubgroupAnd(i,m){return console.error("TODO:subgroupAnd"),null}SubgroupAny(i,m){return console.error("TODO:subgroupAny"),null}SubgroupBallot(i,m){return console.error("TODO:subgroupBallot"),null}SubgroupBroadcast(i,m){return console.error("TODO:subgroupBroadcast"),null}SubgroupBroadcastFirst(i,m){return console.error("TODO:subgroupBroadcastFirst"),null}SubgroupElect(i,m){return console.error("TODO:subgroupElect"),null}SubgroupMax(i,m){return console.error("TODO:subgroupMax"),null}SubgroupMin(i,m){return console.error("TODO:subgroupMin"),null}SubgroupMul(i,m){return console.error("TODO:subgroupMul"),null}SubgroupExclusiveMul(i,m){return console.error("TODO:subgroupExclusiveMul"),null}SubgroupInclusiveMul(i,m){return console.error("TODO:subgroupInclusiveMul"),null}SubgroupOr(i,m){return console.error("TODO:subgroupOr"),null}SubgroupShuffle(i,m){return console.error("TODO:subgroupShuffle"),null}SubgroupShuffleDown(i,m){return console.error("TODO:subgroupShuffleDown"),null}SubgroupShuffleUp(i,m){return console.error("TODO:subgroupShuffleUp"),null}SubgroupShuffleXor(i,m){return console.error("TODO:subgroupShuffleXor"),null}SubgroupXor(i,m){return console.error("TODO:subgroupXor"),null}QuadBroadcast(i,m){return console.error("TODO:quadBroadcast"),null}QuadSwapDiagonal(i,m){return console.error("TODO:quadSwapDiagonal"),null}QuadSwapX(i,m){return console.error("TODO:quadSwapX"),null}QuadSwapY(i,m){return console.error("TODO:quadSwapY"),null}}const rn={vec2:2,vec2f:2,vec2i:2,vec2u:2,vec2b:2,vec2h:2,vec3:3,vec3f:3,vec3i:3,vec3u:3,vec3b:3,vec3h:3,vec4:4,vec4f:4,vec4i:4,vec4u:4,vec4b:4,vec4h:4},nn={mat2x2:[2,2,4],mat2x2f:[2,2,4],mat2x2h:[2,2,4],mat2x3:[2,3,6],mat2x3f:[2,3,6],mat2x3h:[2,3,6],mat2x4:[2,4,8],mat2x4f:[2,4,8],mat2x4h:[2,4,8],mat3x2:[3,2,6],mat3x2f:[3,2,6],mat3x2h:[3,2,6],mat3x3:[3,3,9],mat3x3f:[3,3,9],mat3x3h:[3,3,9],mat3x4:[3,4,12],mat3x4f:[3,4,12],mat3x4h:[3,4,12],mat4x2:[4,2,8],mat4x2f:[4,2,8],mat4x2h:[4,2,8],mat4x3:[4,3,12],mat4x3f:[4,3,12],mat4x3h:[4,3,12],mat4x4:[4,4,16],mat4x4f:[4,4,16],mat4x4h:[4,4,16]};class pt extends ct{constructor(i,m){var g;super(),this.ast=null!=i?i:[],this.reflection=new rt,this.reflection.updateAST(this.ast),this.context=null!==(g=null==m?void 0:m.clone())&&void 0!==g?g:new lt,this.builtins=new ut(this),this.typeInfo={bool:this.getTypeInfo(re.bool),i32:this.getTypeInfo(re.i32),u32:this.getTypeInfo(re.u32),f32:this.getTypeInfo(re.f32),f16:this.getTypeInfo(re.f16),vec2f:this.getTypeInfo(oe.vec2f),vec2u:this.getTypeInfo(oe.vec2u),vec2i:this.getTypeInfo(oe.vec2i),vec2h:this.getTypeInfo(oe.vec2h),vec3f:this.getTypeInfo(oe.vec3f),vec3u:this.getTypeInfo(oe.vec3u),vec3i:this.getTypeInfo(oe.vec3i),vec3h:this.getTypeInfo(oe.vec3h),vec4f:this.getTypeInfo(oe.vec4f),vec4u:this.getTypeInfo(oe.vec4u),vec4i:this.getTypeInfo(oe.vec4i),vec4h:this.getTypeInfo(oe.vec4h),mat2x2f:this.getTypeInfo(oe.mat2x2f),mat2x3f:this.getTypeInfo(oe.mat2x3f),mat2x4f:this.getTypeInfo(oe.mat2x4f),mat3x2f:this.getTypeInfo(oe.mat3x2f),mat3x3f:this.getTypeInfo(oe.mat3x3f),mat3x4f:this.getTypeInfo(oe.mat3x4f),mat4x2f:this.getTypeInfo(oe.mat4x2f),mat4x3f:this.getTypeInfo(oe.mat4x3f),mat4x4f:this.getTypeInfo(oe.mat4x4f)}}getVariableValue(i){var m,g;const x=null!==(g=null===(m=this.context.getVariable(i))||void 0===m?void 0:m.value)&&void 0!==g?g:null;if(null===x)return null;if(x instanceof Oe)return x.value;if(x instanceof Fe)return Array.from(x.data);if(x instanceof Me)return Array.from(x.data);if(x instanceof Ue&&x.typeInfo instanceof s){if("u32"===x.typeInfo.format.name)return Array.from(new Uint32Array(x.buffer,x.offset,x.typeInfo.count));if("i32"===x.typeInfo.format.name)return Array.from(new Int32Array(x.buffer,x.offset,x.typeInfo.count));if("f32"===x.typeInfo.format.name)return Array.from(new Float32Array(x.buffer,x.offset,x.typeInfo.count))}return console.error(`Unsupported return variable type ${x.typeInfo.name}`),null}execute(i){(i=null!=i?i:{}).constants&&this._setOverrides(i.constants,this.context),this._execStatements(this.ast,this.context)}dispatchWorkgroups(i,m,g,x){const _=this.context.clone();(x=null!=x?x:{}).constants&&this._setOverrides(x.constants,_),this._execStatements(this.ast,_);const b=_.getFunction(i);if(!b)return void console.error(`Function ${i} not found`);if("number"==typeof m)m=[m,1,1];else{if(0===m.length)return void console.error("Invalid dispatch count");1===m.length?m=[m[0],1,1]:2===m.length?m=[m[0],m[1],1]:m.length>3&&(m=[m[0],m[1],m[2]])}const y=m[0],T=m[1],w=m[2],P=this.getTypeInfo("vec3u");_.setVariable("@num_workgroups",new Fe(m,P));for(const i in g)for(const m in g[i]){const x=g[i][m];_.variables.forEach(g=>{var _;const b=g.node;if(null==b?void 0:b.attributes){let y=null,T=null;for(const i of b.attributes)"binding"===i.name?y=i.value:"group"===i.name&&(T=i.value);if(m==y&&i==T)if(void 0!==x.texture&&void 0!==x.descriptor){const i=new Pe(x.texture,this.getTypeInfo(b.type),x.descriptor,null!==(_=x.texture.view)&&void 0!==_?_:null);g.value=i}else void 0!==x.uniform?g.value=new Ue(x.uniform,this.getTypeInfo(b.type)):g.value=new Ue(x,this.getTypeInfo(b.type))}})}for(let i=0;i<w;++i)for(let m=0;m<T;++m)for(let g=0;g<y;++g)_.setVariable("@workgroup_id",new Fe([g,m,i],this.getTypeInfo("vec3u"))),this._dispatchWorkgroup(b,[g,m,i],_)}execStatement(i,m){if(i instanceof Q)return this.evalExpression(i.value,m);if(i instanceof ne){if(i.condition){const g=this.evalExpression(i.condition,m);if(!(g instanceof Oe))throw new Error("Invalid break-if condition");if(!g.value)return null}return pt._breakObj}if(i instanceof se)return pt._continueObj;if(i instanceof M)this._let(i,m);else if(i instanceof B)this._var(i,m);else if(i instanceof U)this._const(i,m);else if(i instanceof C)this._function(i,m);else{if(i instanceof Z)return this._if(i,m);if(i instanceof j)return this._switch(i,m);if(i instanceof O)return this._for(i,m);if(i instanceof N)return this._while(i,m);if(i instanceof X)return this._loop(i,m);if(i instanceof V){const g=m.clone();return g.currentFunctionName=m.currentFunctionName,this._execStatements(i.body,g)}if(i instanceof R)this._assign(i,m);else if(i instanceof qr)this._increment(i,m);else{if(i instanceof ie)return null;if(i instanceof F){const g=i.name;null===m.getVariable(g)&&m.setVariable(g,new Oe(0,this.getTypeInfo("u32")))}else if(i instanceof G)this._call(i,m);else{if(i instanceof J)return null;if(i instanceof ee)return null;console.error("Invalid statement type.",i,`Line ${i.line}`)}}}return null}evalExpression(i,m){return i instanceof ke?this._evalBinaryOp(i,m):i instanceof ge?this._evalLiteral(i,m):i instanceof me?this._evalVariable(i,m):i instanceof de?this._evalCall(i,m):i instanceof pe?this._evalCreate(i,m):i instanceof _e?this._evalConst(i,m):i instanceof xe?this._evalBitcast(i,m):i instanceof we?this._evalUnaryOp(i,m):(console.error("Invalid expression type",i,`Line ${i.line}`),null)}getTypeInfo(i){var m;if(i instanceof re){const m=this.reflection.getTypeInfo(i);if(null!==m)return m}let g=null!==(m=this.typeInfo[i])&&void 0!==m?m:null;return null!==g||(g=this.reflection.getTypeInfoByName(i)),g}_setOverrides(i,m){for(const g in i){const x=i[g],_=this.reflection.getOverrideInfo(g);null!==_?(null===_.type&&(_.type=this.getTypeInfo("u32")),"u32"===_.type.name||"i32"===_.type.name||"f32"===_.type.name||"f16"===_.type.name?m.setVariable(g,new Oe(x,_.type)):"bool"===_.type.name?m.setVariable(g,new Oe(x?1:0,_.type)):"vec2"===_.type.name||"vec3"===_.type.name||"vec4"===_.type.name||"vec2f"===_.type.name||"vec3f"===_.type.name||"vec4f"===_.type.name||"vec2i"===_.type.name||"vec3i"===_.type.name||"vec4i"===_.type.name||"vec2u"===_.type.name||"vec3u"===_.type.name||"vec4u"===_.type.name||"vec2h"===_.type.name||"vec3h"===_.type.name||"vec4h"===_.type.name?m.setVariable(g,new Fe(x,_.type)):console.error(`Invalid constant type for ${g}`)):console.error(`Override ${g} does not exist in the shader.`)}}_dispatchWorkgroup(i,m,g){const x=[1,1,1];for(const m of i.node.attributes)if("workgroup_size"===m.name){if(m.value.length>0){const i=g.getVariableValue(m.value[0]);x[0]=i instanceof Oe?i.value:parseInt(m.value[0])}if(m.value.length>1){const i=g.getVariableValue(m.value[1]);x[1]=i instanceof Oe?i.value:parseInt(m.value[1])}if(m.value.length>2){const i=g.getVariableValue(m.value[2]);x[2]=i instanceof Oe?i.value:parseInt(m.value[2])}}const _=this.getTypeInfo("vec3u"),b=this.getTypeInfo("u32");g.setVariable("@workgroup_size",new Fe(x,_));const y=x[0],T=x[1],w=x[2];for(let P=0,$=0;P<w;++P)for(let w=0;w<T;++w)for(let T=0;T<y;++T,++$){const y=[T,w,P],H=[T+m[0]*x[0],w+m[1]*x[1],P+m[2]*x[2]];g.setVariable("@local_invocation_id",new Fe(y,_)),g.setVariable("@global_invocation_id",new Fe(H,_)),g.setVariable("@local_invocation_index",new Oe($,b)),this._dispatchExec(i,g)}}_dispatchExec(i,m){for(const g of i.node.args)for(const i of g.attributes)if("builtin"===i.name){const x=`@${i.value}`,_=m.getVariable(x);void 0!==_&&m.variables.set(g.name,_)}this._execStatements(i.node.body,m)}getVariableName(i,m){for(;i instanceof we;)i=i.right;return i instanceof me?i.name:(console.error("Unknown variable type",i,"Line",i.line),null)}_execStatements(i,m){for(const g of i){if(g instanceof Array){const i=m.clone(),x=this._execStatements(g,i);if(x)return x;continue}const i=this.execStatement(g,m);if(i)return i}return null}_call(i,m){const g=m.clone();g.currentFunctionName=i.name;const x=m.getFunction(i.name);if(x){for(let m=0;m<x.node.args.length;++m){const _=x.node.args[m],b=this.evalExpression(i.args[m],g);g.setVariable(_.name,b,_)}this._execStatements(x.node.body,g)}else i.isBuiltin?this._callBuiltinFunction(i,g):this.getTypeInfo(i.name)&&this._evalCreate(i,m)}_increment(i,m){const g=this.getVariableName(i.variable,m),x=m.getVariable(g);x?"++"===i.operator?x.value instanceof Oe?x.value.value++:console.error(`Variable ${g} is not a scalar. Line ${i.line}`):"--"===i.operator?x.value instanceof Oe?x.value.value--:console.error(`Variable ${g} is not a scalar. Line ${i.line}`):console.error(`Unknown increment operator ${i.operator}. Line ${i.line}`):console.error(`Variable ${g} not found. Line ${i.line}`)}_getVariableData(i,m){if(i instanceof me){const g=this.getVariableName(i,m),x=m.getVariable(g);return null===x?(console.error(`Variable ${g} not found. Line ${i.line}`),null):x.value.getSubData(this,i.postfix,m)}if(i instanceof we){if("*"===i.operator){const g=this._getVariableData(i.right,m);return g instanceof Ve?g.reference.getSubData(this,i.postfix,m):(console.error(`Variable ${i.right} is not a pointer. Line ${i.line}`),null)}if("&"===i.operator){const g=this._getVariableData(i.right,m);return new Ve(g)}}return null}_assign(i,m){let g=null,x="<var>",_=null;if(i.variable instanceof we){const g=this._getVariableData(i.variable,m),x=this.evalExpression(i.value,m),_=i.operator;if("="===_){if(g instanceof Oe||g instanceof Fe||g instanceof Me){if(x instanceof Oe||x instanceof Fe||x instanceof Me&&g.data.length===x.data.length)return void g.data.set(x.data);console.error(`Invalid assignment. Line ${i.line}`)}else if(g instanceof Ue&&x instanceof Ue&&g.buffer.byteLength-g.offset>=x.buffer.byteLength-x.offset)return void(g.buffer.byteLength%4==0?new Uint32Array(g.buffer,g.offset,g.typeInfo.size/4).set(new Uint32Array(x.buffer,x.offset,x.typeInfo.size/4)):new Uint8Array(g.buffer,g.offset,g.typeInfo.size).set(new Uint8Array(x.buffer,x.offset,x.typeInfo.size)));return console.error(`Invalid assignment. Line ${i.line}`),null}if("+="===_)return g instanceof Oe||g instanceof Fe||g instanceof Me?x instanceof Oe||x instanceof Fe||x instanceof Me?void g.data.set(x.data.map((i,m)=>g.data[m]+i)):void console.error(`Invalid assignment . Line ${i.line}`):void console.error(`Invalid assignment. Line ${i.line}`);if("-="===_)return(g instanceof Oe||g instanceof Fe||g instanceof Me)&&(x instanceof Oe||x instanceof Fe||x instanceof Me)?void g.data.set(x.data.map((i,m)=>g.data[m]-i)):void console.error(`Invalid assignment. Line ${i.line}`)}if(i.variable instanceof we){if("*"===i.variable.operator){x=this.getVariableName(i.variable.right,m);const _=m.getVariable(x);if(!(_&&_.value instanceof Ve))return void console.error(`Variable ${x} is not a pointer. Line ${i.line}`);g=_.value.reference;let b=i.variable.postfix;if(!b){let m=i.variable.right;for(;m instanceof we;){if(m.postfix){b=m.postfix;break}m=m.right}}b&&(g=g.getSubData(this,b,m))}}else{_=i.variable.postfix,x=this.getVariableName(i.variable,m);const b=m.getVariable(x);if(null===b)return void console.error(`Variable ${x} not found. Line ${i.line}`);g=b.value}if(g instanceof Ve&&(g=g.reference),null===g)return void console.error(`Variable ${x} not found. Line ${i.line}`);const b=this.evalExpression(i.value,m),y=i.operator;if("="===y)if(g instanceof Ue)g.setDataValue(this,b,_,m);else if(_){if(!(g instanceof Fe||g instanceof Me))return void console.error(`Variable ${x} is not a vector or matrix. Line ${i.line}`);if(_ instanceof be){const y=this.evalExpression(_.index,m).value;if(g instanceof Fe){if(!(b instanceof Oe))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[y]=b.value}else{if(!(g instanceof Me))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);{const y=this.evalExpression(_.index,m).value;if(y<0)return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);if(!(b instanceof Fe))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);{const m=g.typeInfo.getTypeName();if("mat2x2"===m||"mat2x2f"===m||"mat2x2h"===m){if(!(y<2&&2===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[2*y]=b.data[0],g.data[2*y+1]=b.data[1]}else if("mat2x3"===m||"mat2x3f"===m||"mat2x3h"===m){if(!(y<2&&3===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[3*y]=b.data[0],g.data[3*y+1]=b.data[1],g.data[3*y+2]=b.data[2]}else if("mat2x4"===m||"mat2x4f"===m||"mat2x4h"===m){if(!(y<2&&4===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[4*y]=b.data[0],g.data[4*y+1]=b.data[1],g.data[4*y+2]=b.data[2],g.data[4*y+3]=b.data[3]}else if("mat3x2"===m||"mat3x2f"===m||"mat3x2h"===m){if(!(y<3&&2===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[2*y]=b.data[0],g.data[2*y+1]=b.data[1]}else if("mat3x3"===m||"mat3x3f"===m||"mat3x3h"===m){if(!(y<3&&3===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[3*y]=b.data[0],g.data[3*y+1]=b.data[1],g.data[3*y+2]=b.data[2]}else if("mat3x4"===m||"mat3x4f"===m||"mat3x4h"===m){if(!(y<3&&4===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[4*y]=b.data[0],g.data[4*y+1]=b.data[1],g.data[4*y+2]=b.data[2],g.data[4*y+3]=b.data[3]}else if("mat4x2"===m||"mat4x2f"===m||"mat4x2h"===m){if(!(y<4&&2===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[2*y]=b.data[0],g.data[2*y+1]=b.data[1]}else if("mat4x3"===m||"mat4x3f"===m||"mat4x3h"===m){if(!(y<4&&3===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[3*y]=b.data[0],g.data[3*y+1]=b.data[1],g.data[3*y+2]=b.data[2]}else{if("mat4x4"!==m&&"mat4x4f"!==m&&"mat4x4h"!==m)return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);if(!(y<4&&4===b.data.length))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);g.data[4*y]=b.data[0],g.data[4*y+1]=b.data[1],g.data[4*y+2]=b.data[2],g.data[4*y+3]=b.data[3]}}}}}else if(_ instanceof fe){const m=_.value;if(!(g instanceof Fe))return void console.error(`Invalid assignment to ${m}. Variable ${x} is not a vector. Line ${i.line}`);if(b instanceof Oe){if(m.length>1)return void console.error(`Invalid assignment to ${m} for variable ${x}. Line ${i.line}`);if("x"===m)g.data[0]=b.value;else if("y"===m){if(g.data.length<2)return void console.error(`Invalid assignment to ${m} for variable ${x}. Line ${i.line}`);g.data[1]=b.value}else if("z"===m){if(g.data.length<3)return void console.error(`Invalid assignment to ${m} for variable ${x}. Line ${i.line}`);g.data[2]=b.value}else if("w"===m){if(g.data.length<4)return void console.error(`Invalid assignment to ${m} for variable ${x}. Line ${i.line}`);g.data[3]=b.value}}else{if(!(b instanceof Fe))return void console.error(`Invalid assignment to ${x}. Line ${i.line}`);if(m.length!==b.data.length)return void console.error(`Invalid assignment to ${m} for variable ${x}. Line ${i.line}`);for(let _=0;_<m.length;++_){const y=m[_];if("x"===y||"r"===y)g.data[0]=b.data[_];else if("y"===y||"g"===y){if(b.data.length<2)return void console.error(`Invalid assignment to ${y} for variable ${x}. Line ${i.line}`);g.data[1]=b.data[_]}else if("z"===y||"b"===y){if(b.data.length<3)return void console.error(`Invalid assignment to ${y} for variable ${x}. Line ${i.line}`);g.data[2]=b.data[_]}else{if("w"!==y&&"a"!==y)return void console.error(`Invalid assignment to ${y} for variable ${x}. Line ${i.line}`);if(b.data.length<4)return void console.error(`Invalid assignment to ${y} for variable ${x}. Line ${i.line}`);g.data[3]=b.data[_]}}}}}else g instanceof Oe&&b instanceof Oe?g.value=b.value:g instanceof Fe&&b instanceof Fe||g instanceof Me&&b instanceof Me?g.data.set(b.data):console.error(`Invalid assignment to ${x}. Line ${i.line}`);else{const x=g.getSubData(this,_,m);if(x instanceof Fe&&b instanceof Oe){const m=x.data,g=b.value;if("+="===y)for(let i=0;i<m.length;++i)m[i]+=g;else if("-="===y)for(let i=0;i<m.length;++i)m[i]-=g;else if("*="===y)for(let i=0;i<m.length;++i)m[i]*=g;else if("/="===y)for(let i=0;i<m.length;++i)m[i]/=g;else if("%="===y)for(let i=0;i<m.length;++i)m[i]%=g;else if("&="===y)for(let i=0;i<m.length;++i)m[i]&=g;else if("|="===y)for(let i=0;i<m.length;++i)m[i]|=g;else if("^="===y)for(let i=0;i<m.length;++i)m[i]^=g;else if("<<="===y)for(let i=0;i<m.length;++i)m[i]<<=g;else if(">>="===y)for(let i=0;i<m.length;++i)m[i]>>=g;else console.error(`Invalid operator ${y}. Line ${i.line}`)}else if(x instanceof Fe&&b instanceof Fe){const m=x.data,g=b.data;if(m.length!==g.length)return void console.error(`Vector length mismatch. Line ${i.line}`);if("+="===y)for(let i=0;i<m.length;++i)m[i]+=g[i];else if("-="===y)for(let i=0;i<m.length;++i)m[i]-=g[i];else if("*="===y)for(let i=0;i<m.length;++i)m[i]*=g[i];else if("/="===y)for(let i=0;i<m.length;++i)m[i]/=g[i];else if("%="===y)for(let i=0;i<m.length;++i)m[i]%=g[i];else if("&="===y)for(let i=0;i<m.length;++i)m[i]&=g[i];else if("|="===y)for(let i=0;i<m.length;++i)m[i]|=g[i];else if("^="===y)for(let i=0;i<m.length;++i)m[i]^=g[i];else if("<<="===y)for(let i=0;i<m.length;++i)m[i]<<=g[i];else if(">>="===y)for(let i=0;i<m.length;++i)m[i]>>=g[i];else console.error(`Invalid operator ${y}. Line ${i.line}`)}else{if(!(x instanceof Oe&&b instanceof Oe))return void console.error(`Invalid type for ${i.operator} operator. Line ${i.line}`);"+="===y?x.value+=b.value:"-="===y?x.value-=b.value:"*="===y?x.value*=b.value:"/="===y?x.value/=b.value:"%="===y?x.value%=b.value:"&="===y?x.value&=b.value:"|="===y?x.value|=b.value:"^="===y?x.value^=b.value:"<<="===y?x.value<<=b.value:">>="===y?x.value>>=b.value:console.error(`Invalid operator ${y}. Line ${i.line}`)}g instanceof Ue&&g.setDataValue(this,x,_,m)}}_function(i,m){const g=new ot(i);m.functions.set(i.name,g)}_const(i,m){let g=null;null!==i.value&&(g=this.evalExpression(i.value,m)),m.createVariable(i.name,g,i)}_let(i,m){let g=null;if(null!==i.value){if(g=this.evalExpression(i.value,m),null===g)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof we||(g=g.clone())}else{const x=i.type.name;if("f32"===x||"i32"===x||"u32"===x||"bool"===x||"f16"===x||"vec2"===x||"vec3"===x||"vec4"===x||"vec2f"===x||"vec3f"===x||"vec4f"===x||"vec2i"===x||"vec3i"===x||"vec4i"===x||"vec2u"===x||"vec3u"===x||"vec4u"===x||"vec2h"===x||"vec3h"===x||"vec4h"===x||"vec2b"===x||"vec3b"===x||"vec4b"===x||"mat2x2"===x||"mat2x3"===x||"mat2x4"===x||"mat3x2"===x||"mat3x3"===x||"mat3x4"===x||"mat4x2"===x||"mat4x3"===x||"mat4x4"===x||"mat2x2f"===x||"mat2x3f"===x||"mat2x4f"===x||"mat3x2f"===x||"mat3x3f"===x||"mat3x4f"===x||"mat4x2f"===x||"mat4x3f"===x||"mat4x4f"===x||"mat2x2h"===x||"mat2x3h"===x||"mat2x4h"===x||"mat3x2h"===x||"mat3x3h"===x||"mat3x4h"===x||"mat4x2h"===x||"mat4x3h"===x||"mat4x4h"===x||"array"===x){const x=new pe(i.type,[]);g=this._evalCreate(x,m)}}m.createVariable(i.name,g,i)}_var(i,m){let g=null;if(null!==i.value){if(g=this.evalExpression(i.value,m),null===g)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof we||(g=g.clone())}else{if(null===i.type)return void console.error(`Variable ${i.name} has no type. Line ${i.line}`);const x=i.type.name;if("f32"===x||"i32"===x||"u32"===x||"bool"===x||"f16"===x||"vec2"===x||"vec3"===x||"vec4"===x||"vec2f"===x||"vec3f"===x||"vec4f"===x||"vec2i"===x||"vec3i"===x||"vec4i"===x||"vec2u"===x||"vec3u"===x||"vec4u"===x||"vec2h"===x||"vec3h"===x||"vec4h"===x||"vec2b"===x||"vec3b"===x||"vec4b"===x||"mat2x2"===x||"mat2x3"===x||"mat2x4"===x||"mat3x2"===x||"mat3x3"===x||"mat3x4"===x||"mat4x2"===x||"mat4x3"===x||"mat4x4"===x||"mat2x2f"===x||"mat2x3f"===x||"mat2x4f"===x||"mat3x2f"===x||"mat3x3f"===x||"mat3x4f"===x||"mat4x2f"===x||"mat4x3f"===x||"mat4x4f"===x||"mat2x2h"===x||"mat2x3h"===x||"mat2x4h"===x||"mat3x2h"===x||"mat3x3h"===x||"mat3x4h"===x||"mat4x2h"===x||"mat4x3h"===x||"mat4x4h"===x||i.type instanceof ce||i.type instanceof ie||i.type instanceof oe){const x=new pe(i.type,[]);g=this._evalCreate(x,m)}}m.createVariable(i.name,g,i)}_switch(i,m){m=m.clone();const g=this.evalExpression(i.condition,m);if(!(g instanceof Oe))return console.error(`Invalid if condition. Line ${i.line}`),null;let x=null;for(const _ of i.cases)if(_ instanceof Se)for(const b of _.selectors){if(b instanceof Te){x=_;continue}const y=this.evalExpression(b,m);if(!(y instanceof Oe))return console.error(`Invalid case selector. Line ${i.line}`),null;if(y.value===g.value)return this._execStatements(_.body,m)}else _ instanceof Ae&&(x=_);return x?this._execStatements(x.body,m):null}_if(i,m){m=m.clone();const g=this.evalExpression(i.condition,m);if(!(g instanceof Oe))return console.error(`Invalid if condition. Line ${i.line}`),null;if(g.value)return this._execStatements(i.body,m);for(const g of i.elseif){const x=this.evalExpression(g.condition,m);if(!(x instanceof Oe))return console.error(`Invalid if condition. Line ${i.line}`),null;if(x.value)return this._execStatements(g.body,m)}return i.else?this._execStatements(i.else,m):null}_getScalarValue(i){return i instanceof Oe?i.value:(console.error("Expected scalar value.",i),0)}_for(i,m){for(m=m.clone(),this.execStatement(i.init,m);this._getScalarValue(this.evalExpression(i.condition,m));){const g=this._execStatements(i.body,m);if(g===pt._breakObj)break;if(null!==g&&g!==pt._continueObj)return g;this.execStatement(i.increment,m)}return null}_loop(i,m){for(m=m.clone();;){const g=this._execStatements(i.body,m);if(g===pt._breakObj)break;if(g===pt._continueObj){if(i.continuing&&this._execStatements(i.continuing.body,m)===pt._breakObj)break}else if(null!==g)return g}return null}_while(i,m){for(m=m.clone();this._getScalarValue(this.evalExpression(i.condition,m));){const g=this._execStatements(i.body,m);if(g===pt._breakObj)break;if(g!==pt._continueObj&&null!==g)return g}return null}_evalBitcast(i,m){const g=this.evalExpression(i.value,m),x=i.type;if(g instanceof Oe){const i=tt(g.value,g.typeInfo.name,x.name);return new Oe(i,this.getTypeInfo(x))}if(g instanceof Fe){const m=g.typeInfo.getTypeName();let _="";if(m.endsWith("f"))_="f32";else if(m.endsWith("i"))_="i32";else if(m.endsWith("u"))_="u32";else if(m.endsWith("b"))_="bool";else{if(!m.endsWith("h"))return console.error(`Unknown vector type ${m}. Line ${i.line}`),null;_="f16"}const b=x.getTypeName();let y="";if(b.endsWith("f"))y="f32";else if(b.endsWith("i"))y="i32";else if(b.endsWith("u"))y="u32";else if(b.endsWith("b"))y="bool";else{if(!b.endsWith("h"))return console.error(`Unknown vector type ${y}. Line ${i.line}`),null;y="f16"}const T=function(i,m,g){if(m===g)return i;const x=new Array(i.length);for(let _=0;_<i.length;_++)x[_]=tt(i[_],m,g);return x}(Array.from(g.data),_,y);return new Fe(T,this.getTypeInfo(x))}return console.error(`TODO:bitcast for ${g.typeInfo.name}. Line ${i.line}`),null}_evalConst(i,m){return m.getVariableValue(i.name).clone().getSubData(this,i.postfix,m)}_evalCreate(i,m){var g;if(i instanceof pe){if(null===i.type)return Ne.void;switch(i.type.getTypeName()){case"bool":case"i32":case"u32":case"f32":case"f16":return this._callConstructorValue(i,m);case"vec2":case"vec3":case"vec4":case"vec2f":case"vec3f":case"vec4f":case"vec2h":case"vec3h":case"vec4h":case"vec2i":case"vec3i":case"vec4i":case"vec2u":case"vec3u":case"vec4u":case"vec2b":case"vec3b":case"vec4b":return this._callConstructorVec(i,m);case"mat2x2":case"mat2x2f":case"mat2x2h":case"mat2x3":case"mat2x3f":case"mat2x3h":case"mat2x4":case"mat2x4f":case"mat2x4h":case"mat3x2":case"mat3x2f":case"mat3x2h":case"mat3x3":case"mat3x3f":case"mat3x3h":case"mat3x4":case"mat3x4f":case"mat3x4h":case"mat4x2":case"mat4x2f":case"mat4x2h":case"mat4x3":case"mat4x3f":case"mat4x3h":case"mat4x4":case"mat4x4f":case"mat4x4h":return this._callConstructorMatrix(i,m)}}const x=i instanceof pe?i.type.name:i.name,_=i instanceof pe?this.getTypeInfo(i.type):this.getTypeInfo(i.name);if(null===_)return console.error(`Unknown type ${x}. Line ${i.line}`),null;if(0===_.size)return null;const b=new Ue(new ArrayBuffer(_.size),_,0);if(_ instanceof n){if(i.args)for(let g=0;g<i.args.length;++g){const x=_.members[g],y=i.args[g],T=this.evalExpression(y,m);b.setData(this,T,x.type,x.offset,m)}}else if(_ instanceof s){let x=0;if(i.args)for(let y=0;y<i.args.length;++y){const T=i.args[y],w=this.evalExpression(T,m);null===_.format&&("x32"===(null===(g=w.typeInfo)||void 0===g?void 0:g.name)?_.format=this.getTypeInfo("i32"):_.format=w.typeInfo),b.setData(this,w,_.format,x,m),x+=_.stride}}else console.error(`Unknown type "${x}". Line ${i.line}`);return i instanceof pe?b.getSubData(this,i.postfix,m):b}_evalLiteral(i,m){const g=this.getTypeInfo(i.type),x=g.name;return"x32"===x||"u32"===x||"f32"===x||"f16"===x||"i32"===x||"bool"===x?new Oe(i.scalarValue,g):"vec2"===x||"vec3"===x||"vec4"===x||"vec2f"===x||"vec3f"===x||"vec4f"===x||"vec2h"===x||"vec3h"===x||"vec4h"===x||"vec2i"===x||"vec3i"===x||"vec4i"===x||"vec2u"===x||"vec3u"===x||"vec4u"===x?this._callConstructorVec(i,m):"mat2x2"===x||"mat2x3"===x||"mat2x4"===x||"mat3x2"===x||"mat3x3"===x||"mat3x4"===x||"mat4x2"===x||"mat4x3"===x||"mat4x4"===x||"mat2x2f"===x||"mat2x3f"===x||"mat2x4f"===x||"mat3x2f"===x||"mat3x3f"===x||"mat3x4f"===x||"mat4x2f"===x||"mat4x3f"===x||"mat4x4f"===x||"mat2x2h"===x||"mat2x3h"===x||"mat2x4h"===x||"mat3x2h"===x||"mat3x3h"===x||"mat3x4h"===x||"mat4x2h"===x||"mat4x3h"===x||"mat4x4h"===x?this._callConstructorMatrix(i,m):i.value}_evalVariable(i,m){const g=m.getVariableValue(i.name);return null===g?g:g.getSubData(this,i.postfix,m)}_maxFormatTypeInfo(i){let m=i[0];if("f32"===m.name)return m;for(let g=1;g<i.length;++g){const x=pt._priority.get(m.name);pt._priority.get(i[g].name)<x&&(m=i[g])}return"x32"===m.name?this.getTypeInfo("i32"):m}_evalUnaryOp(i,m){const g=this.evalExpression(i.right,m);if("&"===i.operator)return new Ve(g);if("*"===i.operator)return g instanceof Ve?g.reference.getSubData(this,i.postfix,m):(console.error(`Invalid dereference. Line ${i.line}`),null);const x=g instanceof Oe?g.value:g instanceof Fe?Array.from(g.data):null;switch(i.operator){case"+":{if(Re(x)){const i=x.map((i,m)=>+i);return new Fe(i,g.typeInfo)}const i=x,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(+i,m)}case"-":{if(Re(x)){const i=x.map((i,m)=>-i);return new Fe(i,g.typeInfo)}const i=x,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(-i,m)}case"!":{if(Re(x)){const i=x.map((i,m)=>i?0:1);return new Fe(i,g.typeInfo)}const i=x,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(i?0:1,m)}case"~":{if(Re(x)){const i=x.map((i,m)=>~i);return new Fe(i,g.typeInfo)}const i=x,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(~i,m)}}return console.error(`Invalid unary operator ${i.operator}. Line ${i.line}`),null}_evalBinaryOp(i,m){const g=this.evalExpression(i.left,m),x=this.evalExpression(i.right,m),_=g instanceof Oe?g.value:g instanceof Fe||g instanceof Me?Array.from(g.data):null,b=x instanceof Oe?x.value:x instanceof Fe||x instanceof Me?Array.from(x.data):null;switch(i.operator){case"+":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i+x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m+i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i+m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m+y,T)}case"-":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i-x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m-i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i-m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m-y,T)}case"*":{if(Re(_)&&Re(b)){const m=_,y=b;if(g instanceof Me&&x instanceof Me){const _=function(i,m,g,x){if(void 0===nn[m.name]||void 0===nn[x.name])return null;const _=nn[m.name][0],b=nn[m.name][1],y=nn[x.name][0];if(_!==nn[x.name][1])return null;const T=new Array(y*b);for(let m=0;m<b;m++)for(let x=0;x<y;x++){let w=0;for(let y=0;y<_;y++)w+=i[y*b+m]*g[x*_+y];T[m*y+x]=w}return T}(m,g.typeInfo,y,x.typeInfo);if(null===_)return console.error(`Matrix multiplication failed. Line ${i.line}.`),null;const b=nn[x.typeInfo.name][0],T=nn[g.typeInfo.name][1],w=this.getTypeInfo(`mat${b}x${T}f`);return new Me(_,w)}if(g instanceof Me&&x instanceof Fe){const _=function(i,m,g,x){if(void 0===nn[m.name]||void 0===rn[x.name])return null;const _=nn[m.name][0],b=nn[m.name][1];if(_!==g.length)return null;const y=new Array(b);for(let m=0;m<b;m++){let x=0;for(let y=0;y<_;y++)x+=i[y*b+m]*g[y];y[m]=x}return y}(m,g.typeInfo,y,x.typeInfo);return null===_?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new Fe(_,x.typeInfo)}if(g instanceof Fe&&x instanceof Me){const _=function(i,m,g,x){if(void 0===rn[m.name]||void 0===nn[x.name])return null;const _=nn[x.name][0],b=nn[x.name][1];if(b!==i.length)return null;const y=[];for(let m=0;m<_;m++){let x=0;for(let y=0;y<b;y++)x+=i[y]*g[y*_+m];y[m]=x}return y}(m,g.typeInfo,y,x.typeInfo);return null===_?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new Fe(_,g.typeInfo)}{if(m.length!==y.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const x=m.map((i,m)=>i*y[m]);return new Fe(x,g.typeInfo)}}if(Re(_)){const i=b,m=_.map((m,g)=>m*i);return g instanceof Me?new Me(m,g.typeInfo):new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i*m);return x instanceof Me?new Me(m,x.typeInfo):new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m*y,T)}case"%":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i%x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m%i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i%m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m%y,T)}case"/":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i/x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m/i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i/m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m/y,T)}case"&":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i&x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m&i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i&m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m&y,T)}case"|":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i|x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m|i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i|m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m|y,T)}case"^":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i^x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m^i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i^m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m^y,T)}case"<<":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i<<x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m<<i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i<<m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m<<y,T)}case">>":{if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i>>x[m]);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m>>i);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i>>m);return new Fe(m,x.typeInfo)}const m=_,y=b,T=this._maxFormatTypeInfo([g.typeInfo,x.typeInfo]);return new Oe(m>>y,T)}case">":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i>x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m>i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i>m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_>b?1:0,this.getTypeInfo("bool"));case"<":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i<x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m<i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i<m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_<b?1:0,this.getTypeInfo("bool"));case"==":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i===x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m==i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i==m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_===b?1:0,this.getTypeInfo("bool"));case"!=":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i!==x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m!==i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i!==m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_!==b?1:0,this.getTypeInfo("bool"));case">=":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i>=x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m>=i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i>=m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_>=b?1:0,this.getTypeInfo("bool"));case"<=":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i<=x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m<=i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i<=m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_<=b?1:0,this.getTypeInfo("bool"));case"&&":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i&&x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m&&i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i&&m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_&&b?1:0,this.getTypeInfo("bool"));case"||":if(Re(_)&&Re(b)){const m=_,x=b;if(m.length!==x.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=m.map((i,m)=>i||x[m]?1:0);return new Fe(y,g.typeInfo)}if(Re(_)){const i=b,m=_.map((m,g)=>m||i?1:0);return new Fe(m,g.typeInfo)}if(Re(b)){const i=_,m=b.map((m,g)=>i||m?1:0);return new Fe(m,x.typeInfo)}return new Oe(_||b?1:0,this.getTypeInfo("bool"))}return console.error(`Unknown operator ${i.operator}. Line ${i.line}`),null}_evalCall(i,m){if(null!==i.cachedReturnValue)return i.cachedReturnValue;const g=m.clone();g.currentFunctionName=i.name;const x=m.getFunction(i.name);if(!x)return i.isBuiltin?this._callBuiltinFunction(i,g):this.getTypeInfo(i.name)?this._evalCreate(i,m):(console.error(`Unknown function "${i.name}". Line ${i.line}`),null);for(let m=0;m<x.node.args.length;++m){const _=x.node.args[m],b=this.evalExpression(i.args[m],g);g.createVariable(_.name,b,_)}return this._execStatements(x.node.body,g)}_callBuiltinFunction(i,m){switch(i.name){case"all":return this.builtins.All(i,m);case"any":return this.builtins.Any(i,m);case"select":return this.builtins.Select(i,m);case"arrayLength":return this.builtins.ArrayLength(i,m);case"abs":return this.builtins.Abs(i,m);case"acos":return this.builtins.Acos(i,m);case"acosh":return this.builtins.Acosh(i,m);case"asin":return this.builtins.Asin(i,m);case"asinh":return this.builtins.Asinh(i,m);case"atan":return this.builtins.Atan(i,m);case"atanh":return this.builtins.Atanh(i,m);case"atan2":return this.builtins.Atan2(i,m);case"ceil":return this.builtins.Ceil(i,m);case"clamp":return this.builtins.Clamp(i,m);case"cos":return this.builtins.Cos(i,m);case"cosh":return this.builtins.Cosh(i,m);case"countLeadingZeros":return this.builtins.CountLeadingZeros(i,m);case"countOneBits":return this.builtins.CountOneBits(i,m);case"countTrailingZeros":return this.builtins.CountTrailingZeros(i,m);case"cross":return this.builtins.Cross(i,m);case"degrees":return this.builtins.Degrees(i,m);case"determinant":return this.builtins.Determinant(i,m);case"distance":return this.builtins.Distance(i,m);case"dot":return this.builtins.Dot(i,m);case"dot4U8Packed":return this.builtins.Dot4U8Packed(i,m);case"dot4I8Packed":return this.builtins.Dot4I8Packed(i,m);case"exp":return this.builtins.Exp(i,m);case"exp2":return this.builtins.Exp2(i,m);case"extractBits":return this.builtins.ExtractBits(i,m);case"faceForward":return this.builtins.FaceForward(i,m);case"firstLeadingBit":return this.builtins.FirstLeadingBit(i,m);case"firstTrailingBit":return this.builtins.FirstTrailingBit(i,m);case"floor":return this.builtins.Floor(i,m);case"fma":return this.builtins.Fma(i,m);case"fract":return this.builtins.Fract(i,m);case"frexp":return this.builtins.Frexp(i,m);case"insertBits":return this.builtins.InsertBits(i,m);case"inverseSqrt":return this.builtins.InverseSqrt(i,m);case"ldexp":return this.builtins.Ldexp(i,m);case"length":return this.builtins.Length(i,m);case"log":return this.builtins.Log(i,m);case"log2":return this.builtins.Log2(i,m);case"max":return this.builtins.Max(i,m);case"min":return this.builtins.Min(i,m);case"mix":return this.builtins.Mix(i,m);case"modf":return this.builtins.Modf(i,m);case"normalize":return this.builtins.Normalize(i,m);case"pow":return this.builtins.Pow(i,m);case"quantizeToF16":return this.builtins.QuantizeToF16(i,m);case"radians":return this.builtins.Radians(i,m);case"reflect":return this.builtins.Reflect(i,m);case"refract":return this.builtins.Refract(i,m);case"reverseBits":return this.builtins.ReverseBits(i,m);case"round":return this.builtins.Round(i,m);case"saturate":return this.builtins.Saturate(i,m);case"sign":return this.builtins.Sign(i,m);case"sin":return this.builtins.Sin(i,m);case"sinh":return this.builtins.Sinh(i,m);case"smoothStep":return this.builtins.SmoothStep(i,m);case"sqrt":return this.builtins.Sqrt(i,m);case"step":return this.builtins.Step(i,m);case"tan":return this.builtins.Tan(i,m);case"tanh":return this.builtins.Tanh(i,m);case"transpose":return this.builtins.Transpose(i,m);case"trunc":return this.builtins.Trunc(i,m);case"dpdx":return this.builtins.Dpdx(i,m);case"dpdxCoarse":return this.builtins.DpdxCoarse(i,m);case"dpdxFine":return this.builtins.DpdxFine(i,m);case"dpdy":return this.builtins.Dpdy(i,m);case"dpdyCoarse":return this.builtins.DpdyCoarse(i,m);case"dpdyFine":return this.builtins.DpdyFine(i,m);case"fwidth":return this.builtins.Fwidth(i,m);case"fwidthCoarse":return this.builtins.FwidthCoarse(i,m);case"fwidthFine":return this.builtins.FwidthFine(i,m);case"textureDimensions":return this.builtins.TextureDimensions(i,m);case"textureGather":return this.builtins.TextureGather(i,m);case"textureGatherCompare":return this.builtins.TextureGatherCompare(i,m);case"textureLoad":return this.builtins.TextureLoad(i,m);case"textureNumLayers":return this.builtins.TextureNumLayers(i,m);case"textureNumLevels":return this.builtins.TextureNumLevels(i,m);case"textureNumSamples":return this.builtins.TextureNumSamples(i,m);case"textureSample":return this.builtins.TextureSample(i,m);case"textureSampleBias":return this.builtins.TextureSampleBias(i,m);case"textureSampleCompare":return this.builtins.TextureSampleCompare(i,m);case"textureSampleCompareLevel":return this.builtins.TextureSampleCompareLevel(i,m);case"textureSampleGrad":return this.builtins.TextureSampleGrad(i,m);case"textureSampleLevel":return this.builtins.TextureSampleLevel(i,m);case"textureSampleBaseClampToEdge":return this.builtins.TextureSampleBaseClampToEdge(i,m);case"textureStore":return this.builtins.TextureStore(i,m);case"atomicLoad":return this.builtins.AtomicLoad(i,m);case"atomicStore":return this.builtins.AtomicStore(i,m);case"atomicAdd":return this.builtins.AtomicAdd(i,m);case"atomicSub":return this.builtins.AtomicSub(i,m);case"atomicMax":return this.builtins.AtomicMax(i,m);case"atomicMin":return this.builtins.AtomicMin(i,m);case"atomicAnd":return this.builtins.AtomicAnd(i,m);case"atomicOr":return this.builtins.AtomicOr(i,m);case"atomicXor":return this.builtins.AtomicXor(i,m);case"atomicExchange":return this.builtins.AtomicExchange(i,m);case"atomicCompareExchangeWeak":return this.builtins.AtomicCompareExchangeWeak(i,m);case"pack4x8snorm":return this.builtins.Pack4x8snorm(i,m);case"pack4x8unorm":return this.builtins.Pack4x8unorm(i,m);case"pack4xI8":return this.builtins.Pack4xI8(i,m);case"pack4xU8":return this.builtins.Pack4xU8(i,m);case"pack4x8Clamp":return this.builtins.Pack4x8Clamp(i,m);case"pack4xU8Clamp":return this.builtins.Pack4xU8Clamp(i,m);case"pack2x16snorm":return this.builtins.Pack2x16snorm(i,m);case"pack2x16unorm":return this.builtins.Pack2x16unorm(i,m);case"pack2x16float":return this.builtins.Pack2x16float(i,m);case"unpack4x8snorm":return this.builtins.Unpack4x8snorm(i,m);case"unpack4x8unorm":return this.builtins.Unpack4x8unorm(i,m);case"unpack4xI8":return this.builtins.Unpack4xI8(i,m);case"unpack4xU8":return this.builtins.Unpack4xU8(i,m);case"unpack2x16snorm":return this.builtins.Unpack2x16snorm(i,m);case"unpack2x16unorm":return this.builtins.Unpack2x16unorm(i,m);case"unpack2x16float":return this.builtins.Unpack2x16float(i,m);case"storageBarrier":return this.builtins.StorageBarrier(i,m);case"textureBarrier":return this.builtins.TextureBarrier(i,m);case"workgroupBarrier":return this.builtins.WorkgroupBarrier(i,m);case"workgroupUniformLoad":return this.builtins.WorkgroupUniformLoad(i,m);case"subgroupAdd":return this.builtins.SubgroupAdd(i,m);case"subgroupExclusiveAdd":return this.builtins.SubgroupExclusiveAdd(i,m);case"subgroupInclusiveAdd":return this.builtins.SubgroupInclusiveAdd(i,m);case"subgroupAll":return this.builtins.SubgroupAll(i,m);case"subgroupAnd":return this.builtins.SubgroupAnd(i,m);case"subgroupAny":return this.builtins.SubgroupAny(i,m);case"subgroupBallot":return this.builtins.SubgroupBallot(i,m);case"subgroupBroadcast":return this.builtins.SubgroupBroadcast(i,m);case"subgroupBroadcastFirst":return this.builtins.SubgroupBroadcastFirst(i,m);case"subgroupElect":return this.builtins.SubgroupElect(i,m);case"subgroupMax":return this.builtins.SubgroupMax(i,m);case"subgroupMin":return this.builtins.SubgroupMin(i,m);case"subgroupMul":return this.builtins.SubgroupMul(i,m);case"subgroupExclusiveMul":return this.builtins.SubgroupExclusiveMul(i,m);case"subgroupInclusiveMul":return this.builtins.SubgroupInclusiveMul(i,m);case"subgroupOr":return this.builtins.SubgroupOr(i,m);case"subgroupShuffle":return this.builtins.SubgroupShuffle(i,m);case"subgroupShuffleDown":return this.builtins.SubgroupShuffleDown(i,m);case"subgroupShuffleUp":return this.builtins.SubgroupShuffleUp(i,m);case"subgroupShuffleXor":return this.builtins.SubgroupShuffleXor(i,m);case"subgroupXor":return this.builtins.SubgroupXor(i,m);case"quadBroadcast":return this.builtins.QuadBroadcast(i,m);case"quadSwapDiagonal":return this.builtins.QuadSwapDiagonal(i,m);case"quadSwapX":return this.builtins.QuadSwapX(i,m);case"quadSwapY":return this.builtins.QuadSwapY(i,m)}const g=m.getFunction(i.name);if(g){const x=m.clone();for(let m=0;m<g.node.args.length;++m){const _=g.node.args[m],b=this.evalExpression(i.args[m],x);x.setVariable(_.name,b,_)}return this._execStatements(g.node.body,x)}return null}_callConstructorValue(i,m){if(!i.args||0===i.args.length)return new Oe(0,this.getTypeInfo(i.type));const g=this.evalExpression(i.args[0],m);return g.typeInfo=this.getTypeInfo(i.type),g.getSubData(this,i.postfix,m).clone()}_callConstructorVec(i,m){const g=this.getTypeInfo(i.type),x=i.type.getTypeName(),_=rn[x];if(void 0===_)return console.error(`Invalid vec constructor ${x}. Line ${i.line}`),null;const b=[];if(i instanceof ge)if(i.isVector){const m=i.vectorValue;for(const i of m)b.push(i)}else b.push(i.scalarValue);else if(i.args)for(const g of i.args){const i=this.evalExpression(g,m);if(i instanceof Fe){const m=i.data;for(let i=0;i<m.length;++i){let g=m[i];b.push(g)}}else if(i instanceof Oe){let m=i.value;b.push(m)}}if(i.type instanceof oe&&null===i.type.format&&(i.type.format=oe.f32),0===b.length){const x=new Array(_).fill(0);return new Fe(x,g).getSubData(this,i.postfix,m)}if(1===b.length)for(;b.length<_;)b.push(b[0]);return b.length<_?(console.error(`Invalid vec constructor. Line ${i.line}`),null):new Fe(b.length>_?b.slice(0,_):b,g).getSubData(this,i.postfix,m)}_callConstructorMatrix(i,m){const g=this.getTypeInfo(i.type),x=i.type.getTypeName(),_=nn[x];if(void 0===_)return console.error(`Invalid matrix constructor ${x}. Line ${i.line}`),null;const b=[];if(i instanceof ge)if(i.isVector){const m=i.vectorValue;for(const i of m)b.push(i)}else b.push(i.scalarValue);else if(i.args)for(const g of i.args){const i=this.evalExpression(g,m);i instanceof Fe?b.push(...i.data):i instanceof Oe?b.push(i.value):i instanceof Me&&b.push(...i.data)}if(g instanceof a&&null===g.format&&(g.format=this.getTypeInfo("f32")),0===b.length){const x=new Array(_[2]).fill(0);return new Me(x,g).getSubData(this,i.postfix,m)}return b.length!==_[2]?(console.error(`Invalid matrix constructor. Line ${i.line}`),null):new Me(b,g).getSubData(this,i.postfix,m)}}pt._breakObj=new De(new e("BREAK",null),null),pt._continueObj=new De(new e("CONTINUE",null),null),pt._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class dt{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class mt{constructor(){this._tokens=[],this._current=0,this._currentLine=1,this._deferArrayCountEval=[],this._currentLoop=[],this._context=new dt,this._exec=new pt,this._forwardTypeCount=0}parse(i){this._initialize(i),this._deferArrayCountEval.length=0;const m=[];for(;!this._isAtEnd();){const i=this._global_decl_or_directive();if(!i)break;m.push(i)}if(this._deferArrayCountEval.length>0){for(const m of this._deferArrayCountEval){const g=m.arrayType,x=m.countNode;if(x instanceof me){const m=x.name,_=this._context.constants.get(m);if(_)try{const i=_.constEvaluate(this._exec);g.count=i}catch(i){}}}this._deferArrayCountEval.length=0}if(this._forwardTypeCount>0)for(const i of m)i.search(i=>{i instanceof Le||i instanceof le?i.type=this._forwardType(i.type):i instanceof ce?i.format=this._forwardType(i.format):i instanceof B||i instanceof M||i instanceof U?i.type=this._forwardType(i.type):i instanceof C?i.returnType=this._forwardType(i.returnType):i instanceof Ee&&(i.type=this._forwardType(i.type))});return m}_forwardType(i){if(i instanceof ae){const m=this._getType(i.name);if(m)return m}else i instanceof le?i.type=this._forwardType(i.type):i instanceof ce&&(i.format=this._forwardType(i.format));return i}_initialize(i){if(i)if("string"==typeof i){const m=new ze(i);this._tokens=m.scanTokens()}else this._tokens=i;else this._tokens=[];this._current=0}_updateNode(i,m){return i.line=null!=m?m:this._currentLine,i}_error(i,m){return{token:i,message:m,toString:()=>`${m}`}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==qe.eof}_match(i){if(i instanceof We)return!!this._check(i)&&(this._advance(),!0);for(let m=0,g=i.length;m<g;++m){const g=i[m];if(this._check(g))return this._advance(),!0}return!1}_consume(i,m){if(this._check(i))return this._advance();throw this._error(this._peek(),`${m}. Line:${this._currentLine}`)}_check(i){if(this._isAtEnd())return!1;const m=this._peek();if(i instanceof Array){const g=m.type;let x=!1;for(const m of i){if(g===m)return!0;m===qe.tokens.name&&(x=!0)}if(x){const i=qe.tokens.name.rule.exec(m.lexeme);if(i&&0==i.index&&i[0]==m.lexeme)return!0}return!1}if(m.type===i)return!0;if(i===qe.tokens.name){const i=qe.tokens.name.rule.exec(m.lexeme);return i&&0==i.index&&i[0]==m.lexeme}return!1}_advance(){var i,m;return this._currentLine=null!==(m=null===(i=this._peek())||void 0===i?void 0:i.line)&&void 0!==m?m:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(qe.tokens.semicolon)&&!this._isAtEnd(););if(this._match(qe.keywords.alias)){const i=this._type_alias();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(qe.keywords.diagnostic)){const i=this._diagnostic();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(qe.keywords.requires)){const i=this._requires_directive();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(qe.keywords.enable)){const i=this._enable_directive();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}const i=this._attribute();if(this._check(qe.keywords.var)){const m=this._global_variable_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.override)){const m=this._override_variable_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.let)){const m=this._global_let_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.const)){const m=this._global_const_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.struct)){const m=this._struct_decl();return null!=m&&(m.attributes=i),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.fn)){const m=this._function_decl();return null!=m&&(m.attributes=i),this._exec.reflection.updateAST([m]),m}return null}_function_decl(){if(!this._match(qe.keywords.fn))return null;const i=this._currentLine,m=this._consume(qe.tokens.ident,"Expected function name.").toString();this._consume(qe.tokens.paren_left,"Expected '(' for function arguments.");const g=[];if(!this._check(qe.tokens.paren_right))do{if(this._check(qe.tokens.paren_right))break;const i=this._attribute(),m=this._consume(qe.tokens.name,"Expected argument name.").toString();this._consume(qe.tokens.colon,"Expected ':' for argument type.");const x=this._attribute(),_=this._type_decl();null!=_&&(_.attributes=x,g.push(this._updateNode(new Ee(m,_,i))))}while(this._match(qe.tokens.comma));this._consume(qe.tokens.paren_right,"Expected ')' after function arguments.");let x=null;if(this._match(qe.tokens.arrow)){const i=this._attribute();x=this._type_decl(),null!=x&&(x.attributes=i)}const _=this._compound_statement(),b=this._currentLine;return this._updateNode(new C(m,g,x,_,i,b),i)}_compound_statement(){const i=[];for(this._consume(qe.tokens.brace_left,"Expected '{' for block.");!this._check(qe.tokens.brace_right);){const m=this._statement();null!==m&&i.push(m)}return this._consume(qe.tokens.brace_right,"Expected '}' for block."),i}_statement(){for(;this._match(qe.tokens.semicolon)&&!this._isAtEnd(););if(this._check(qe.tokens.attr)&&this._attribute(),this._check(qe.keywords.if))return this._if_statement();if(this._check(qe.keywords.switch))return this._switch_statement();if(this._check(qe.keywords.loop))return this._loop_statement();if(this._check(qe.keywords.for))return this._for_statement();if(this._check(qe.keywords.while))return this._while_statement();if(this._check(qe.keywords.continuing))return this._continuing_statement();if(this._check(qe.keywords.static_assert))return this._static_assert_statement();if(this._check(qe.tokens.brace_left))return this._compound_statement();let i=null;if(this._check(qe.keywords.return))i=this._return_statement();else if(this._check([qe.keywords.var,qe.keywords.let,qe.keywords.const]))i=this._variable_statement();else if(this._match(qe.keywords.discard))i=this._updateNode(new te);else if(this._match(qe.keywords.break)){const m=this._updateNode(new ne);if(this._currentLoop.length>0){const i=this._currentLoop[this._currentLoop.length-1];m.loopId=i.id}i=m,this._check(qe.keywords.if)&&(this._advance(),m.condition=this._optional_paren_expression())}else if(this._match(qe.keywords.continue)){const m=this._updateNode(new se);if(!(this._currentLoop.length>0))throw this._error(this._peek(),`Continue statement must be inside a loop. Line:${m.line}`);{const i=this._currentLoop[this._currentLoop.length-1];m.loopId=i.id}i=m}else i=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement();return null!=i&&this._consume(qe.tokens.semicolon,"Expected ';' after statement."),i}_static_assert_statement(){if(!this._match(qe.keywords.static_assert))return null;const i=this._currentLine,m=this._optional_paren_expression();return this._updateNode(new D(m),i)}_while_statement(){if(!this._match(qe.keywords.while))return null;const i=this._updateNode(new N(null,null));return this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(qe.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_continuing_statement(){const i=this._currentLoop.length>0?this._currentLoop[this._currentLoop.length-1].id:-1;if(!this._match(qe.keywords.continuing))return null;const m=this._currentLine,g=this._compound_statement();return this._updateNode(new V(g,i),m)}_for_statement(){if(!this._match(qe.keywords.for))return null;this._consume(qe.tokens.paren_left,"Expected '('.");const i=this._updateNode(new O(null,null,null,null));return this._currentLoop.push(i),i.init=this._check(qe.tokens.semicolon)?null:this._for_init(),this._consume(qe.tokens.semicolon,"Expected ';'."),i.condition=this._check(qe.tokens.semicolon)?null:this._short_circuit_or_expression(),this._consume(qe.tokens.semicolon,"Expected ';'."),i.increment=this._check(qe.tokens.paren_right)?null:this._for_increment(),this._consume(qe.tokens.paren_right,"Expected ')'."),this._check(qe.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(qe.keywords.var)){const i=this._variable_decl();if(null===i)throw this._error(this._peek(),"Variable declaration expected.");let m=null;return this._match(qe.tokens.equal)&&(m=this._short_circuit_or_expression()),this._updateNode(new B(i.name,i.type,i.storage,i.access,m),i.line)}if(this._match(qe.keywords.let)){const i=this._currentLine,m=this._consume(qe.tokens.name,"Expected name for let.").toString();let g=null;if(this._match(qe.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}this._consume(qe.tokens.equal,"Expected '=' for let.");const x=this._short_circuit_or_expression();return this._updateNode(new M(m,g,null,null,x),i)}if(this._match(qe.keywords.const)){const i=this._currentLine,m=this._consume(qe.tokens.name,"Expected name for const.").toString();let g=null;if(this._match(qe.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}this._consume(qe.tokens.equal,"Expected '=' for const.");const x=this._short_circuit_or_expression();return null===g&&x instanceof ge&&(g=x.type),this._updateNode(new U(m,g,null,null,x),i)}return null}_increment_decrement_statement(){const i=this._current,m=this._unary_expression();if(null==m)return null;if(!this._check(qe.increment_operators))return this._current=i,null;const g=this._consume(qe.increment_operators,"Expected increment operator");return this._updateNode(new qr(g.type===qe.tokens.plus_plus?Vr.increment:Vr.decrement,m))}_assignment_statement(){let i=null;const m=this._currentLine;if(this._check(qe.tokens.brace_right))return null;let g=this._match(qe.tokens.underscore);if(g||(i=this._unary_expression()),!g&&null==i)return null;const x=this._consume(qe.assignment_operators,"Expected assignment operator."),_=this._short_circuit_or_expression();return this._updateNode(new R($r.parse(x.lexeme),i,_),m)}_func_call_statement(){if(!this._check(qe.tokens.ident))return null;const i=this._currentLine,m=this._current,g=this._consume(qe.tokens.ident,"Expected function name."),x=this._argument_expression_list();return null===x?(this._current=m,null):this._updateNode(new G(g.lexeme,x),i)}_loop_statement(){if(!this._match(qe.keywords.loop))return null;this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Expected '{' for loop.");const i=this._updateNode(new X([],null));this._currentLoop.push(i);let m=this._statement();for(;null!==m;){if(Array.isArray(m))for(let g of m)i.body.push(g);else i.body.push(m);if(m instanceof V){i.continuing=m;break}m=this._statement()}return this._currentLoop.pop(),this._consume(qe.tokens.brace_right,"Expected '}' for loop."),i}_switch_statement(){if(!this._match(qe.keywords.switch))return null;const i=this._updateNode(new j(null,[]));if(this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Expected '{' for switch."),i.cases=this._switch_body(),null==i.cases||0==i.cases.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(qe.tokens.brace_right,"Expected '}' for switch."),this._currentLoop.pop(),i}_switch_body(){const i=[];let m=!1;for(;this._check([qe.keywords.default,qe.keywords.case]);){if(this._match(qe.keywords.case)){const g=this._case_selectors();for(const i of g)if(i instanceof Te){if(m)throw this._error(this._previous(),"Multiple default cases in switch statement.");m=!0;break}this._match(qe.tokens.colon),this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Exected '{' for switch case.");const x=this._case_body();this._consume(qe.tokens.brace_right,"Exected '}' for switch case."),i.push(this._updateNode(new Se(g,x)))}if(this._match(qe.keywords.default)){if(m)throw this._error(this._previous(),"Multiple default cases in switch statement.");this._match(qe.tokens.colon),this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Exected '{' for switch default.");const g=this._case_body();this._consume(qe.tokens.brace_right,"Exected '}' for switch default."),i.push(this._updateNode(new Ae(g)))}}return i}_case_selectors(){const i=[];for(this._match(qe.keywords.default)?i.push(this._updateNode(new Te)):i.push(this._shift_expression());this._match(qe.tokens.comma);)this._match(qe.keywords.default)?i.push(this._updateNode(new Te)):i.push(this._shift_expression());return i}_case_body(){if(this._match(qe.keywords.fallthrough))return this._consume(qe.tokens.semicolon,"Expected ';'"),[];let i=this._statement();if(null==i)return[];i instanceof Array||(i=[i]);const m=this._case_body();return 0==m.length?i:[...i,m[0]]}_if_statement(){if(!this._match(qe.keywords.if))return null;const i=this._currentLine,m=this._optional_paren_expression();this._check(qe.tokens.attr)&&this._attribute();const g=this._compound_statement();let x=[];this._match_elseif()&&(this._check(qe.tokens.attr)&&this._attribute(),x=this._elseif_statement(x));let _=null;return this._match(qe.keywords.else)&&(this._check(qe.tokens.attr)&&this._attribute(),_=this._compound_statement()),this._updateNode(new Z(m,g,x,_),i)}_match_elseif(){return this._tokens[this._current].type===qe.keywords.else&&this._tokens[this._current+1].type===qe.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(i=[]){const m=this._optional_paren_expression(),g=this._compound_statement();return i.push(this._updateNode(new $e(m,g))),this._match_elseif()&&(this._check(qe.tokens.attr)&&this._attribute(),this._elseif_statement(i)),i}_return_statement(){if(!this._match(qe.keywords.return))return null;const i=this._short_circuit_or_expression();return this._updateNode(new Q(i))}_short_circuit_or_expression(){let i=this._short_circuit_and_expr();for(;this._match(qe.tokens.or_or);)i=this._updateNode(new ke(this._previous().toString(),i,this._short_circuit_and_expr()));return i}_short_circuit_and_expr(){let i=this._inclusive_or_expression();for(;this._match(qe.tokens.and_and);)i=this._updateNode(new ke(this._previous().toString(),i,this._inclusive_or_expression()));return i}_inclusive_or_expression(){let i=this._exclusive_or_expression();for(;this._match(qe.tokens.or);)i=this._updateNode(new ke(this._previous().toString(),i,this._exclusive_or_expression()));return i}_exclusive_or_expression(){let i=this._and_expression();for(;this._match(qe.tokens.xor);)i=this._updateNode(new ke(this._previous().toString(),i,this._and_expression()));return i}_and_expression(){let i=this._equality_expression();for(;this._match(qe.tokens.and);)i=this._updateNode(new ke(this._previous().toString(),i,this._equality_expression()));return i}_equality_expression(){const i=this._relational_expression();return this._match([qe.tokens.equal_equal,qe.tokens.not_equal])?this._updateNode(new ke(this._previous().toString(),i,this._relational_expression())):i}_relational_expression(){let i=this._shift_expression();for(;this._match([qe.tokens.less_than,qe.tokens.greater_than,qe.tokens.less_than_equal,qe.tokens.greater_than_equal]);)i=this._updateNode(new ke(this._previous().toString(),i,this._shift_expression()));return i}_shift_expression(){let i=this._additive_expression();for(;this._match([qe.tokens.shift_left,qe.tokens.shift_right]);)i=this._updateNode(new ke(this._previous().toString(),i,this._additive_expression()));return i}_additive_expression(){let i=this._multiplicative_expression();for(;this._match([qe.tokens.plus,qe.tokens.minus]);)i=this._updateNode(new ke(this._previous().toString(),i,this._multiplicative_expression()));return i}_multiplicative_expression(){let i=this._unary_expression();for(;this._match([qe.tokens.star,qe.tokens.forward_slash,qe.tokens.modulo]);)i=this._updateNode(new ke(this._previous().toString(),i,this._unary_expression()));return i}_unary_expression(){return this._match([qe.tokens.minus,qe.tokens.bang,qe.tokens.tilde,qe.tokens.star,qe.tokens.and])?this._updateNode(new we(this._previous().toString(),this._unary_expression())):this._singular_expression()}_singular_expression(){const i=this._primary_expression(),m=this._postfix_expression();return m&&(i.postfix=m),i}_postfix_expression(){if(this._match(qe.tokens.bracket_left)){const i=this._short_circuit_or_expression();this._consume(qe.tokens.bracket_right,"Expected ']'.");const m=this._updateNode(new be(i)),g=this._postfix_expression();return g&&(m.postfix=g),m}if(this._match(qe.tokens.period)){const i=this._consume(qe.tokens.name,"Expected member name."),m=this._postfix_expression(),g=this._updateNode(new fe(i.lexeme));return m&&(g.postfix=m),g}return null}_getStruct(i){return this._context.aliases.has(i)?this._context.aliases.get(i).type:this._context.structs.has(i)?this._context.structs.get(i):null}_getType(i){const m=this._getStruct(i);if(null!==m)return m;switch(i){case"void":return re.void;case"bool":return re.bool;case"i32":return re.i32;case"u32":return re.u32;case"f32":return re.f32;case"f16":return re.f16;case"vec2f":return oe.vec2f;case"vec3f":return oe.vec3f;case"vec4f":return oe.vec4f;case"vec2i":return oe.vec2i;case"vec3i":return oe.vec3i;case"vec4i":return oe.vec4i;case"vec2u":return oe.vec2u;case"vec3u":return oe.vec3u;case"vec4u":return oe.vec4u;case"vec2h":return oe.vec2h;case"vec3h":return oe.vec3h;case"vec4h":return oe.vec4h;case"mat2x2f":return oe.mat2x2f;case"mat2x3f":return oe.mat2x3f;case"mat2x4f":return oe.mat2x4f;case"mat3x2f":return oe.mat3x2f;case"mat3x3f":return oe.mat3x3f;case"mat3x4f":return oe.mat3x4f;case"mat4x2f":return oe.mat4x2f;case"mat4x3f":return oe.mat4x3f;case"mat4x4f":return oe.mat4x4f;case"mat2x2h":return oe.mat2x2h;case"mat2x3h":return oe.mat2x3h;case"mat2x4h":return oe.mat2x4h;case"mat3x2h":return oe.mat3x2h;case"mat3x3h":return oe.mat3x3h;case"mat3x4h":return oe.mat3x4h;case"mat4x2h":return oe.mat4x2h;case"mat4x3h":return oe.mat4x3h;case"mat4x4h":return oe.mat4x4h;case"mat2x2i":return oe.mat2x2i;case"mat2x3i":return oe.mat2x3i;case"mat2x4i":return oe.mat2x4i;case"mat3x2i":return oe.mat3x2i;case"mat3x3i":return oe.mat3x3i;case"mat3x4i":return oe.mat3x4i;case"mat4x2i":return oe.mat4x2i;case"mat4x3i":return oe.mat4x3i;case"mat4x4i":return oe.mat4x4i;case"mat2x2u":return oe.mat2x2u;case"mat2x3u":return oe.mat2x3u;case"mat2x4u":return oe.mat2x4u;case"mat3x2u":return oe.mat3x2u;case"mat3x3u":return oe.mat3x3u;case"mat3x4u":return oe.mat3x4u;case"mat4x2u":return oe.mat4x2u;case"mat4x3u":return oe.mat4x3u;case"mat4x4u":return oe.mat4x4u}return null}_validateTypeRange(i,m){if("i32"===m.name){if(i<-2147483648||i>2147483647)throw this._error(this._previous(),`Value out of range for i32:${i}. Line:${this._currentLine}.`)}else if("u32"===m.name&&(i<0||i>4294967295))throw this._error(this._previous(),`Value out of range for u32:${i}. Line:${this._currentLine}.`)}_primary_expression(){if(this._match(qe.tokens.ident)){const i=this._previous().toString();if(this._check(qe.tokens.paren_left)){const m=this._argument_expression_list(),g=this._getType(i);return null!==g?this._updateNode(new pe(g,m)):this._updateNode(new de(i,m))}if(this._context.constants.has(i)){const m=this._context.constants.get(i);return this._updateNode(new _e(i,m.value))}return this._updateNode(new me(i))}if(this._match(qe.tokens.int_literal)){const i=this._previous().toString();let m=i.endsWith("i")||i.endsWith("i")?re.i32:i.endsWith("u")||i.endsWith("U")?re.u32:re.x32;const g=parseInt(i);return this._validateTypeRange(g,m),this._updateNode(new ge(new Oe(g,this._exec.getTypeInfo(m)),m))}if(this._match(qe.tokens.uint_literal)){const i=parseInt(this._previous().toString());return this._validateTypeRange(i,re.u32),this._updateNode(new ge(new Oe(i,this._exec.getTypeInfo(re.u32)),re.u32))}if(this._match([qe.tokens.decimal_float_literal,qe.tokens.hex_float_literal])){let i=this._previous().toString(),m=i.endsWith("h");m&&(i=i.substring(0,i.length-1));const g=parseFloat(i);this._validateTypeRange(g,m?re.f16:re.f32);const x=m?re.f16:re.f32;return this._updateNode(new ge(new Oe(g,this._exec.getTypeInfo(x)),x))}if(this._match([qe.keywords.true,qe.keywords.false])){let i=this._previous().toString()===qe.keywords.true.rule;return this._updateNode(new ge(new Oe(i?1:0,this._exec.getTypeInfo(re.bool)),re.bool))}if(this._check(qe.tokens.paren_left))return this._paren_expression();if(this._match(qe.keywords.bitcast)){this._consume(qe.tokens.less_than,"Expected '<'.");const i=this._type_decl();this._consume(qe.tokens.greater_than,"Expected '>'.");const m=this._paren_expression();return this._updateNode(new xe(i,m))}const i=this._type_decl(),m=this._argument_expression_list();return this._updateNode(new pe(i,m))}_argument_expression_list(){if(!this._match(qe.tokens.paren_left))return null;const i=[];do{if(this._check(qe.tokens.paren_right))break;const m=this._short_circuit_or_expression();i.push(m)}while(this._match(qe.tokens.comma));return this._consume(qe.tokens.paren_right,"Expected ')' for agument list"),i}_optional_paren_expression(){this._match(qe.tokens.paren_left);const i=this._short_circuit_or_expression();return this._match(qe.tokens.paren_right),i}_paren_expression(){this._consume(qe.tokens.paren_left,"Expected '('.");const i=this._short_circuit_or_expression();return this._consume(qe.tokens.paren_right,"Expected ')'."),i}_struct_decl(){if(!this._match(qe.keywords.struct))return null;const i=this._currentLine,m=this._consume(qe.tokens.ident,"Expected name for struct.").toString();this._consume(qe.tokens.brace_left,"Expected '{' for struct body.");const g=[];for(;!this._check(qe.tokens.brace_right);){const i=this._attribute(),m=this._consume(qe.tokens.name,"Expected variable name.").toString();this._consume(qe.tokens.colon,"Expected ':' for struct member type.");const x=this._attribute(),_=this._type_decl();null!=_&&(_.attributes=x),this._check(qe.tokens.brace_right)?this._match(qe.tokens.comma):this._consume(qe.tokens.comma,"Expected ',' for struct member."),g.push(this._updateNode(new Le(m,_,i)))}this._consume(qe.tokens.brace_right,"Expected '}' after struct body.");const x=this._currentLine,_=this._updateNode(new ie(m,g,i,x),i);return this._context.structs.set(m,_),_}_global_variable_decl(){const i=this._variable_decl();if(!i)return null;if(this._match(qe.tokens.equal)){const m=this._const_expression();i.value=m}if(null!==i.type&&i.value instanceof ge){if("x32"!==i.value.type.name&&i.type.getTypeName()!==i.value.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${i.value.type.name} to ${i.type.name}. Line:${this._currentLine}`);i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type),i.value.type=i.type}else null===i.type&&i.value instanceof ge&&(i.type="x32"===i.value.type.name?re.i32:i.value.type,i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type));return i}_override_variable_decl(){const i=this._override_decl();return i&&this._match(qe.tokens.equal)&&(i.value=this._const_expression()),i}_global_const_decl(){var i;if(!this._match(qe.keywords.const))return null;const m=this._consume(qe.tokens.name,"Expected variable name"),g=this._currentLine;let x=null;if(this._match(qe.tokens.colon)){const i=this._attribute();x=this._type_decl(),null!=x&&(x.attributes=i)}let _=null;this._consume(qe.tokens.equal,"const declarations require an assignment");const b=this._short_circuit_or_expression();try{let i=[re.f32],g=b.constEvaluate(this._exec,i);g instanceof Oe&&this._validateTypeRange(g.value,i[0]),i[0]instanceof oe&&null===i[0].format&&g.typeInfo instanceof a&&null!==g.typeInfo.format&&("f16"===g.typeInfo.format.name?i[0].format=re.f16:"f32"===g.typeInfo.format.name?i[0].format=re.f32:"i32"===g.typeInfo.format.name?i[0].format=re.i32:"u32"===g.typeInfo.format.name?i[0].format=re.u32:"bool"===g.typeInfo.format.name?i[0].format=re.bool:console.error(`TODO:impelement template format type ${g.typeInfo.format.name}`)),_=this._updateNode(new ge(g,i[0])),this._exec.context.setVariable(m.toString(),g)}catch(i){_=b}if(null!==x&&_ instanceof ge){if("x32"!==_.type.name&&x.getTypeName()!==_.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${_.type.name} to ${x.name}. Line:${this._currentLine}`);_.type=x,_.isScalar&&this._validateTypeRange(_.scalarValue,_.type)}else null===x&&_ instanceof ge&&(x=null!==(i=null==_?void 0:_.type)&&void 0!==i?i:re.f32,x===re.x32&&(x=re.i32));const y=this._updateNode(new U(m.toString(),x,"","",_),g);return this._context.constants.set(y.name,y),y}_global_let_decl(){if(!this._match(qe.keywords.let))return null;const i=this._currentLine,m=this._consume(qe.tokens.name,"Expected variable name");let g=null;if(this._match(qe.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}let x=null;if(this._match(qe.tokens.equal)&&(x=this._const_expression()),null!==g&&x instanceof ge){if("x32"!==x.type.name&&g.getTypeName()!==x.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${x.type.name} to ${g.name}. Line:${this._currentLine}`);x.type=g}else null===g&&x instanceof ge&&(g="x32"===x.type.name?re.i32:x.type);return x instanceof ge&&x.isScalar&&this._validateTypeRange(x.scalarValue,g),this._updateNode(new M(m.toString(),g,"","",x),i)}_const_expression(){return this._short_circuit_or_expression()}_variable_decl(){if(!this._match(qe.keywords.var))return null;const i=this._currentLine;let m="",g="";this._match(qe.tokens.less_than)&&(m=this._consume(qe.storage_class,"Expected storage_class.").toString(),this._match(qe.tokens.comma)&&(g=this._consume(qe.access_mode,"Expected access_mode.").toString()),this._consume(qe.tokens.greater_than,"Expected '>'."));const x=this._consume(qe.tokens.name,"Expected variable name");let _=null;if(this._match(qe.tokens.colon)){const i=this._attribute();_=this._type_decl(),null!=_&&(_.attributes=i)}return this._updateNode(new B(x.toString(),_,m,g,null),i)}_override_decl(){if(!this._match(qe.keywords.override))return null;const i=this._consume(qe.tokens.name,"Expected variable name");let m=null;if(this._match(qe.tokens.colon)){const i=this._attribute();m=this._type_decl(),null!=m&&(m.attributes=i)}return this._updateNode(new F(i.toString(),m,null))}_diagnostic(){this._consume(qe.tokens.paren_left,"Expected '('");const i=this._consume(qe.tokens.ident,"Expected severity control name.");this._consume(qe.tokens.comma,"Expected ','");let m=this._consume(qe.tokens.ident,"Expected diagnostic rule name.").toString();return this._match(qe.tokens.period)&&(m+=`.${this._consume(qe.tokens.ident,"Expected diagnostic message.").toString()}`),this._consume(qe.tokens.paren_right,"Expected ')'"),this._updateNode(new J(i.toString(),m))}_enable_directive(){const i=this._consume(qe.tokens.ident,"identity expected.");return this._updateNode(new Y(i.toString()))}_requires_directive(){const i=[this._consume(qe.tokens.ident,"identity expected.").toString()];for(;this._match(qe.tokens.comma);){const m=this._consume(qe.tokens.ident,"identity expected.");i.push(m.toString())}return this._updateNode(new K(i))}_type_alias(){const i=this._consume(qe.tokens.ident,"identity expected.");this._consume(qe.tokens.equal,"Expected '=' for type alias.");let m=this._type_decl();if(null===m)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(m.name)&&(m=this._context.aliases.get(m.name).type);const g=this._updateNode(new ee(i.toString(),m));return this._context.aliases.set(g.name,g),g}_type_decl(){if(this._check([qe.tokens.ident,...qe.texel_format,qe.keywords.bool,qe.keywords.f32,qe.keywords.i32,qe.keywords.u32])){const i=this._advance().toString();if(this._context.structs.has(i))return this._context.structs.get(i);if(this._context.aliases.has(i))return this._context.aliases.get(i).type;if(!this._getType(i)){const m=this._updateNode(new ae(i));return this._forwardTypeCount++,m}return this._updateNode(new re(i))}let i=this._texture_sampler_types();if(i)return i;if(this._check(qe.template_types)){let i=this._advance().toString(),m=null,g=null;return this._match(qe.tokens.less_than)&&(m=this._type_decl(),g=null,this._match(qe.tokens.comma)&&(g=this._consume(qe.access_mode,"Expected access_mode for pointer").toString()),this._consume(qe.tokens.greater_than,"Expected '>' for type.")),this._updateNode(new oe(i,m,g))}if(this._match(qe.keywords.ptr)){let i=this._previous().toString();this._consume(qe.tokens.less_than,"Expected '<' for pointer.");const m=this._consume(qe.storage_class,"Expected storage_class for pointer");this._consume(qe.tokens.comma,"Expected ',' for pointer.");const g=this._type_decl();let x=null;return this._match(qe.tokens.comma)&&(x=this._consume(qe.access_mode,"Expected access_mode for pointer").toString()),this._consume(qe.tokens.greater_than,"Expected '>' for pointer."),this._updateNode(new le(i,m.toString(),g,x))}const m=this._attribute();if(this._match(qe.keywords.array)){let g=null,x=-1;const _=this._previous();let b=null;if(this._match(qe.tokens.less_than)){g=this._type_decl(),this._context.aliases.has(g.name)&&(g=this._context.aliases.get(g.name).type);let m="";if(this._match(qe.tokens.comma)){b=this._shift_expression();try{m=b.constEvaluate(this._exec).toString(),b=null}catch(i){m="1"}}this._consume(qe.tokens.greater_than,"Expected '>' for array."),x=m?parseInt(m):0}const y=this._updateNode(new ce(_.toString(),m,g,x));return b&&this._deferArrayCountEval.push({arrayType:y,countNode:b}),y}return null}_texture_sampler_types(){if(this._match(qe.sampler_type))return this._updateNode(new ue(this._previous().toString(),null,null));if(this._match(qe.depth_texture_type))return this._updateNode(new ue(this._previous().toString(),null,null));if(this._match(qe.sampled_texture_type)||this._match(qe.multisampled_texture_type)){const i=this._previous();this._consume(qe.tokens.less_than,"Expected '<' for sampler type.");const m=this._type_decl();return this._consume(qe.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new ue(i.toString(),m,null))}if(this._match(qe.storage_texture_type)){const i=this._previous();this._consume(qe.tokens.less_than,"Expected '<' for sampler type.");const m=this._consume(qe.texel_format,"Invalid texel format.").toString();this._consume(qe.tokens.comma,"Expected ',' after texel format.");const g=this._consume(qe.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(qe.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new ue(i.toString(),m,g))}return null}_attribute(){let i=[];for(;this._match(qe.tokens.attr);){const m=this._consume(qe.attribute_name,"Expected attribute name"),g=this._updateNode(new Ce(m.toString(),null));if(this._match(qe.tokens.paren_left)){if(g.value=this._consume(qe.literal_or_ident,"Expected attribute value").toString(),this._check(qe.tokens.comma)){this._advance();do{const i=this._consume(qe.literal_or_ident,"Expected attribute value").toString();g.value instanceof Array||(g.value=[g.value]),g.value.push(i)}while(this._match(qe.tokens.comma))}this._consume(qe.tokens.paren_right,"Expected ')'")}i.push(g)}return 0==i.length?null:i}}class _t extends rt{constructor(i){super(),i&&this.update(i)}update(i){const m=(new mt).parse(i);this.updateAST(m)}}class UniformType{static get i32(){return{numElements:1,align:4,size:4,type:"i32",wgslType:"i32",View:Int32Array}}static get u32(){return{numElements:1,align:4,size:4,type:"u32",wgslType:"u32",View:Uint32Array}}static get f32(){return{numElements:1,align:4,size:4,type:"f32",wgslType:"f32",View:Float32Array}}static get f16(){return{numElements:1,align:2,size:2,type:"f16",wgslType:"f16",View:Uint16Array}}static get vec2f32(){return{numElements:2,align:8,size:8,type:"f32",wgslType:"vec2<f32>",View:Float32Array}}static get vec2i32(){return{numElements:2,align:8,size:8,type:"i32",wgslType:"vec2<i32>",View:Int32Array}}static get vec2u32(){return{numElements:2,align:8,size:8,type:"u32",wgslType:"vec2<u32>",View:Uint32Array}}static get vec2u16(){return{numElements:2,align:4,size:4,type:"u16",wgslType:"vec2<u16>",View:Uint16Array}}static get vec3i32(){return{numElements:3,align:16,size:12,type:"i32",wgslType:"vec3<i32>",View:Int32Array}}static get vec3u32(){return{numElements:3,align:16,size:12,type:"u32",wgslType:"vec3<u32>",View:Uint32Array}}static get vec3f32(){return{numElements:3,align:16,size:12,type:"f32",wgslType:"vec3<f32>",View:Float32Array}}static get vec3u16(){return{numElements:3,align:8,size:6,type:"u16",wgslType:"vec3<u16>",View:Uint16Array}}static get vec4i32(){return{numElements:4,align:16,size:16,type:"i32",wgslType:"vec4<i32>",View:Int32Array}}static get vec4u32(){return{numElements:4,align:16,size:16,type:"u32",wgslType:"vec4<u32>",View:Uint32Array}}static get vec4f32(){return{numElements:4,align:16,size:16,type:"f32",wgslType:"vec4<f32>",View:Float32Array}}static get vec4u16(){return{numElements:4,align:8,size:8,type:"u16",wgslType:"vec4<u16>",View:Uint16Array}}static get mat2x2f32(){return{numElements:4,align:8,size:16,type:"f32",wgslType:"mat2x2<f32>",View:Float32Array}}static get mat2x2u16(){return{numElements:4,align:4,size:8,type:"u16",wgslType:"mat2x2<u16>",View:Uint16Array}}static get mat3x2f32(){return{numElements:6,align:8,size:24,type:"f32",wgslType:"mat3x2<f32>",View:Float32Array}}static get mat3x2u16(){return{numElements:6,align:4,size:12,type:"u16",wgslType:"mat3x2<u16>",View:Uint16Array}}static get mat3x3f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat3x3<f32>",View:Float32Array}}static get mat4x2f32(){return{numElements:8,align:8,size:32,type:"f32",wgslType:"mat4x2<f32>",View:Float32Array}}static get mat4x2u16(){return{numElements:8,align:4,size:16,type:"u16",wgslType:"mat4x2<u16>",View:Uint16Array}}static get mat2x3f32(){return{numElements:8,align:16,size:32,type:"f32",wgslType:"mat2x3<f32>",View:Float32Array}}static get mat2x3u16(){return{numElements:8,align:8,size:16,type:"u16",wgslType:"mat2x3<u16>",View:Uint16Array}}static get mat4x4f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat4x4<f32>",View:Float32Array}}static get mat4x4u16(){return{numElements:16,align:8,size:32,type:"u16",wgslType:"mat4x4<u16>",View:Uint16Array}}}Object.freeze(UniformType);const an={TILE_COUNT_X:32,TILE_COUNT_Y:32,TILE_COUNT_Z:48,WORKGROUP_SIZE_X:8,WORKGROUP_SIZE_Y:4,WORKGROUP_SIZE_Z:8,MAX_LIGHTS_PER_CLUSTER:100,MAX_CLUSTER_LIGHTS:1024,getTotalTileSize:()=>an.TILE_COUNT_X*an.TILE_COUNT_Y*an.TILE_COUNT_Z,getClusterLightsBufferSize:()=>{const i=an.getTotalTileSize();return 8*i+8*an.MAX_LIGHTS_PER_CLUSTER*i+4},getDispatchSize:()=>[Math.ceil(an.TILE_COUNT_X/an.WORKGROUP_SIZE_X),Math.ceil(an.TILE_COUNT_Y/an.WORKGROUP_SIZE_Y),Math.ceil(an.TILE_COUNT_Z/an.WORKGROUP_SIZE_Z)]};Object.freeze(an);const sn=Object.freeze({SYSTEM_UNIFORM:"struct DirectionalLight {\r\n\t direction:vec3<f32>,\r\n\t color:vec3<f32>,\r\n\t intensity:f32,\r\n};\r\nstruct AmbientLight {\r\n\t color:vec3<f32>,\r\n\t intensity:f32\r\n};\r\n\r\nstruct Camera {\r\n\t cameraMatrix:mat4x4<f32>,\r\n\t cameraPosition:vec3<f32>,\r\n\t nearClipping:f32,\rfarClipping:f32\r\n};\r\n\r\nstruct SystemUniform {\r\n\t projectionMatrix:mat4x4<f32>,\r\n\t inverseProjectionMatrix:mat4x4<f32>,\r\n\t projectionCameraMatrix:mat4x4<f32>,\r\n\t camera:Camera,\r\n\t resolution:vec2<f32>,\r\n\t viewPosition:vec2<f32>,\r\n\t \r\n\t directionalLightCount:u32,\r\n\t directionalLights:array<DirectionalLight,3>,\r\n\t \r\n\t directionalLightProjectionViewMatrix:mat4x4<f32>,\r\n\t directionalLightProjectionMatrix:mat4x4<f32>,\r\n\t directionalLightViewMatrix:mat4x4<f32>,\r\n\t \r\n\t shadowDepthTextureSize:u32,\r\n\t bias:f32,\r\n\t \r\n\t ambientLight:AmbientLight,\r\n\r\n\t time:f32,\r\n\t \r\n\t useIblTexture:u32,\r\n\t isView3D:u32\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> systemUniforms:SystemUniform;\r\n@group(0) @binding(1) var directionalShadowMapSampler:sampler_comparison;\r\n@group(0) @binding(2) var directionalShadowMap:texture_depth_2d;\r\n@group(0) @binding(3) var iblTextureSampler:sampler;\r\n\r\n@group(0) @binding(7) var renderPath1ResultTextureSampler:sampler;\r\n@group(0) @binding(8) var renderPath1ResultTexture:texture_2d<f32>;\r\n@group(0) @binding(9) var packedTextureSampler:sampler;\r\n@group(0) @binding(10) var ibl_environmentTexture:texture_cube<f32>;\r\n@group(0) @binding(11) var ibl_irradianceTexture:texture_cube<f32>;\r\n\r\nconst clusterLight_indicesLength:u32=u32(REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu * REDGPU_DEFINE_TOTAL_TILESu);\r\nconst clusterLight_tileCount=vec3<u32>(REDGPU_DEFINE_TILE_COUNT_Xu,REDGPU_DEFINE_TILE_COUNT_Yu,REDGPU_DEFINE_TILE_COUNT_Zu);\r\n\r\nstruct ClusterLights {\roffset:u32,\rcount:u32\r\n};\r\nstruct ClusterLightsGroup {\roffset:atomic<u32>,\rlights:array<ClusterLights,REDGPU_DEFINE_TOTAL_TILES>,\rindices:array<u32,clusterLight_indicesLength>\r\n};\r\nstruct ClusterLight_ClusterCube {\rminAABB:vec4<f32>,\rmaxAABB:vec4<f32>\r};\r\nstruct ClusterLight_Clusters {\rcubeList:array<ClusterLight_ClusterCube,REDGPU_DEFINE_TOTAL_TILES>\r\n};\r\n\r\nfn linearDepth(depthSample:f32) -> f32 {\rreturn systemUniforms.camera.farClipping*systemUniforms.camera.nearClipping/fma(depthSample,systemUniforms.camera.nearClipping-systemUniforms.camera.farClipping,systemUniforms.camera.farClipping);\r\n}\r\nfn getClusterLightClusterIndex(fragCoord:vec4<f32>) -> u32 {\rlet tile=getClusterLightTile(fragCoord);\rreturn tile.x +\rtile.y * clusterLight_tileCount.x +\rtile.z * clusterLight_tileCount.x * clusterLight_tileCount.y;\r\n\r\n}\r\nfn getClusterLightTile(fragCoord:vec4<f32>) -> vec3<u32> {\rlet sliceScale=f32(clusterLight_tileCount.z)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping);\rlet sliceBias=-(f32(clusterLight_tileCount.z) * log2(systemUniforms.camera.nearClipping)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping));\rlet zTile=u32(max(log2(linearDepth(fragCoord.z)) * sliceScale + sliceBias,0.0));\rreturn vec3<u32>(u32(fragCoord.x/(systemUniforms.resolution.x/f32(clusterLight_tileCount.x))),\ru32(fragCoord.y/(systemUniforms.resolution.y/f32(clusterLight_tileCount.y))),\rzTile);\r\n}\r\n\r\nstruct ClusterLight {\rposition:vec3<f32>,radius:f32,\rcolor:vec3<f32>, intensity:f32,\risSpotLight:f32, directionX:f32, directionY:f32, directionZ:f32,\routerCutoff:f32, innerCutoff:f32,\r\n};\r\nstruct ClusterLightList {\rcount:vec4<f32>,\rlights:array<ClusterLight>\r\n};\r\n@group(0) @binding(5) var<storage> clusterLightList:ClusterLightList;\r\n@group(0) @binding(6) var<storage,read_write> clusterLightGroup:ClusterLightsGroup;\r\n",calcTintBlendMode:"fn calcTintBlendMode(baseColor:vec4<f32>,tintBlendMode:u32,tint:vec4<f32>) -> vec4<f32> {\rvar tintedColor:vec3<f32>;\rswitch (tintBlendMode) {\rcase 0u:{ \rreturn vec4<f32>(mix(baseColor.rgb,tint.rgb,tint.a),baseColor.a);\r}\rcase 1u:{ \rtintedColor=baseColor.rgb * tint.rgb;\r}\rcase 2u:{ \rtintedColor=max(baseColor.rgb,tint.rgb);\r}\rcase 3u:{ \rtintedColor=1.0 - (1.0 - baseColor.rgb) * (1.0 - tint.rgb);\r}\rcase 4u:{ \rtintedColor=clamp(baseColor.rgb + tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 5u:{ \rtintedColor=clamp(baseColor.rgb - tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 6u:{ \rtintedColor=min(baseColor.rgb,tint.rgb);\r}\rcase 7u:{ \rtintedColor=mix(\r2.0 * baseColor.rgb * tint.rgb,\r1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb),\rstep(vec3<f32>(0.5),baseColor.rgb)\r);\r}\rcase 8u:{ \rtintedColor=clamp(baseColor.rgb/(1.0 - tint.rgb),vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 9u:{ \rtintedColor=1.0 - clamp((1.0 - baseColor.rgb)/tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 10u:{ \rtintedColor=mix(\r2.0 * baseColor.rgb * tint.rgb,\r1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb),\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 11u:{ \rtintedColor=mix(\rbaseColor.rgb * (tint.rgb + tint.rgb - vec3<f32>(1.0)),\rbaseColor.rgb + tint.rgb - baseColor.rgb * tint.rgb,\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 12u:{ \rtintedColor=abs(baseColor.rgb - tint.rgb);\r}\rcase 13u:{ \rtintedColor=baseColor.rgb + tint.rgb - 2.0 * baseColor.rgb * tint.rgb;\r}\rcase 14u:{ \rtintedColor=clamp(baseColor.rgb/tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 15u:{ \rtintedColor=mix(\rclamp(baseColor.rgb/(1.0 - (tint.rgb - vec3<f32>(0.5)) * 2.0),vec3<f32>(0.0),vec3<f32>(1.0)),\r1.0 - clamp((1.0 - baseColor.rgb)/(tint.rgb * 2.0),vec3<f32>(0.0),vec3<f32>(1.0)),\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 16u:{ \rtintedColor=clamp(baseColor.rgb + tint.rgb - vec3<f32>(1.0),vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 17u:{ \rtintedColor=mix(\rmin(baseColor.rgb,2.0 * tint.rgb),\rmax(baseColor.rgb,2.0 * tint.rgb - vec3<f32>(1.0)),\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 18u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(baseHsl.x,tintHsl.y,baseHsl.z));\r}\rcase 19u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(tintHsl.x,baseHsl.y,baseHsl.z));\r}\rcase 20u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(baseHsl.x,baseHsl.y,tintHsl.z));\r}\rcase 21u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(tintHsl.x,tintHsl.y,baseHsl.z));\r}\rcase 22u:{ \rtintedColor=1.0 - abs(1.0 - baseColor.rgb - tint.rgb);\r}\rdefault:{\rtintedColor=baseColor.rgb;\r}\r}\r\n\rreturn vec4<f32>(tintedColor,baseColor.a * tint.a);\r\n}\r\n\r\n\r\nfn rgbToHsl(rgb:vec3<f32>) -> vec3<f32> {\rlet maxVal:f32=max(max(rgb.r,rgb.g),rgb.b);\rlet minVal:f32=min(min(rgb.r,rgb.g),rgb.b);\rlet delta:f32=maxVal - minVal;\r\n\rlet lightness:f32=(maxVal + minVal) * 0.5;\r\n\rif (delta==0.0) {\rreturn vec3<f32>(0.0,0.0,lightness);\r}\r\n\r\rvar saturation:f32;\rif (lightness < 0.5) {\rsaturation=delta/(maxVal + minVal);\r} else {\rsaturation=delta/(2.0 - maxVal - minVal);\r}\r\n\r\rvar hue:f32=0.0;\rif (rgb.r==maxVal) {\rhue=(rgb.g - rgb.b)/delta;\rif (rgb.g < rgb.b) {\rhue +=6.0;\r}\r} else if (rgb.g==maxVal) {\rhue=(rgb.b - rgb.r)/delta + 2.0;\r} else { \rhue=(rgb.r - rgb.g)/delta + 4.0;\r}\r\n\rhue=hue/6.0;\r\n\rreturn vec3<f32>(hue,saturation,lightness);\r\n}\r\n\r\nfn hslToRgb(hsl:vec3<f32>) -> vec3<f32> {\rlet h=hsl.x;\rlet s=hsl.y;\rlet l=hsl.z;\r\n\rif (s==0.0) {\r\rreturn vec3<f32>(l,l,l);\r}\r\n\r\rvar q:f32;\rif (l < 0.5) {\rq=l * (1.0 + s);\r} else {\rq=l + s - l * s;\r}\r\n\rlet p=2.0 * l - q;\r\n\r\rvar r:f32;\rvar g:f32;\rvar b:f32;\r\n\rfor (var i:i32=0;i < 3;i=i + 1) {\rvar t:f32;\rif (i==0) {\rt=h + 1.0/3.0;\r} else if (i==1) {\rt=h;\r} else {\rt=h - 1.0/3.0;\r}\r\n\rif (t < 0.0) {\rt=t + 1.0;\r}\rif (t > 1.0) {\rt=t - 1.0;\r}\r\n\rvar color:f32;\rif (t < 1.0/6.0) {\rcolor=p + (q - p) * 6.0 * t;\r} else if (t < 1.0/2.0) {\rcolor=q;\r} else if (t < 2.0/3.0) {\rcolor=p + (q - p) * (2.0/3.0 - t) * 6.0;\r} else {\rcolor=p;\r}\r\n\rif (i==0) {\rr=color;\r} else if (i==1) {\rg=color;\r} else {\rb=color;\r}\r}\r\n\rreturn vec3<f32>(r,g,b);\r\n}",calcDisplacements:"fn calcDisplacementPosition(input_position:vec3<f32>,input_vertexNormal:vec3<f32>,displacementTexture:texture_2d<f32>,displacementTextureSampler:sampler,displacementScale:f32,input_uv:vec2<f32>,mipLevel:f32) -> vec3<f32> {\rlet displacementSample=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,mipLevel).r;\rlet scaledDisplacement=(displacementSample - 0.5) * displacementScale;\rlet displacedPosition=input_position + input_vertexNormal * scaledDisplacement;\rreturn displacedPosition;\r\n}\r\nfn calcDisplacementNormal(input_vertexNormal:vec3<f32>,displacementTexture:texture_2d<f32>,displacementTextureSampler:sampler,displacementScale:f32,input_uv:vec2<f32>,mipLevel:f32) -> vec3<f32> {\rlet textureSize=textureDimensions(displacementTexture);\rlet texelSizeX=1.0/f32(textureSize.x);\rlet texelSizeY=1.0/f32(textureSize.y);\r\n\rlet displacementRight=textureSampleLevel(displacementTexture,displacementTextureSampler,\rinput_uv + vec2<f32>(texelSizeX,0.0),mipLevel).r;\rlet displacementLeft=textureSampleLevel(displacementTexture,displacementTextureSampler,\rinput_uv - vec2<f32>(texelSizeX,0.0),mipLevel).r;\rlet displacementUp=textureSampleLevel(displacementTexture,displacementTextureSampler,\rinput_uv + vec2<f32>(0.0,texelSizeY),mipLevel).r;\rlet displacementDown=textureSampleLevel(displacementTexture,displacementTextureSampler,\rinput_uv - vec2<f32>(0.0,texelSizeY),mipLevel).r;\r\n\rlet gradientX=((displacementRight - 0.5) - (displacementLeft - 0.5)) * displacementScale * 0.2;\rlet gradientY=((displacementUp - 0.5) - (displacementDown - 0.5)) * displacementScale * 0.2;\r\n\rlet up=vec3<f32>(0.0,1.0,0.0);\rlet tangent=normalize(cross(up,input_vertexNormal));\rlet bitangent=normalize(cross(input_vertexNormal,tangent));\r\n\rlet tangentSpaceNormal=normalize(vec3<f32>(gradientX,gradientY,1.0));\r\n\rlet objectSpaceNormal=tangentSpaceNormal.x * tangent +\rtangentSpaceNormal.y * bitangent +\rtangentSpaceNormal.z * input_vertexNormal;\r\n\rreturn normalize(objectSpaceNormal);\r\n\r\n}\r\n",drawDirectionalShadowDepth:"struct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\rlet u_useDisplacementTexture=vertexUniforms.useDisplacementTexture==1u;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_displacementScale=vertexUniforms.displacementScale;\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\rvar position:vec4<f32>;\rposition=u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_cameraPosition);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacedPosition=calcDisplacementPosition(input_position,input_vertexNormal,displacementTexture,displacementTextureSampler,u_displacementScale,input_uv,mipLevel);\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\r}\routput.position=u_directionalLightProjectionViewMatrix * position;\rreturn output;\r\n}\r\n",getBillboardMatrix:"fn getBillboardMatrix(cameraMatrix:mat4x4<f32>,modelMatrix:mat4x4<f32>) -> mat4x4<f32> {\r\rlet scaleX=length(vec3<f32>(modelMatrix[0].xyz));\rlet scaleY=length(vec3<f32>(modelMatrix[1].xyz));\rlet scaleZ=length(vec3<f32>(modelMatrix[2].xyz));\r\n\r\rlet scaleMatrix=mat4x4<f32>(\rvec4<f32>(scaleX,0.0,0.0,0.0),\rvec4<f32>(0.0,scaleY,0.0,0.0),\rvec4<f32>(0.0,0.0,scaleZ,0.0),\rvec4<f32>(0.0,0.0,0.0,1.0)\r);\r\n\r\rvar resultMatrix=cameraMatrix * modelMatrix;\rresultMatrix[0][0]=1.0;resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0;\rresultMatrix[1][0]=0.0;resultMatrix[1][1]=1.0;resultMatrix[1][2]=0.0;\rresultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=1.0;\r\n\r\rreturn resultMatrix * scaleMatrix;\r\n}\r\nfn getBillboardMatrixNoScaleRatio( cameraMatrix:mat4x4<f32>, modelMatrix:mat4x4<f32>)-> mat4x4<f32>{\rvar resultMatrix=cameraMatrix * modelMatrix;\rresultMatrix[0][0]=modelMatrix[0][0];resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0;\rresultMatrix[1][0]=0.0;resultMatrix[1][1]=modelMatrix[1][1];resultMatrix[1][2]=0.0;\rresultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=modelMatrix[2][2];\r\n\rreturn resultMatrix;\r\n}\r\n",extractScaleAndTranslation:"fn extractScaleAndTranslation(modelMatrix:mat4x4<f32>) -> mat4x4<f32> {\r\rlet scaleX=length(vec3<f32>(modelMatrix[0].xyz));\rlet scaleY=length(vec3<f32>(modelMatrix[1].xyz));\rlet scaleZ=length(vec3<f32>(modelMatrix[2].xyz));\r\n\r\rlet scaleMatrix=mat4x4<f32>(\rvec4<f32>(scaleX,0.0,0.0,0.0),\rvec4<f32>(0.0,scaleY,0.0,0.0),\rvec4<f32>(0.0,0.0,scaleZ,0.0),\rvec4<f32>(0.0,0.0,0.0,1.0)\r);\r\n\r\rreturn mat4x4<f32>(\rscaleMatrix[0],\rscaleMatrix[1],\rscaleMatrix[2],\rmodelMatrix[3] \r);\r\n}\r\n\r\n",calcDirectionalShadowVisibility:"fn calcDirectionalShadowVisibility(\rdirectionalShadowMap:texture_depth_2d,\rdirectionalShadowMapSampler:sampler_comparison,\rshadowDepthTextureSize:u32,\rbias:f32,\rshadowPos:vec3<f32>\r\n) -> f32 {\rlet oneOverShadowDepthTextureSize=1.0/f32(shadowDepthTextureSize);\rlet shadowDepth=clamp(shadowPos.z,0.0,1.0);\r\n\rvar visibility:f32=0.0;\r\n\rfor (var y=-1;y <=1;y++) {\rfor (var x=-1;x <=1;x++) {\rlet offset=vec2f(vec2(x,y)) * oneOverShadowDepthTextureSize;\rlet tUV=shadowPos.xy + offset;\r\n\rlet sampleVisibility=textureSampleCompare(\rdirectionalShadowMap,\rdirectionalShadowMapSampler,\rtUV,\rshadowDepth - bias\r);\r\n\rif (tUV.x < 0.0 || tUV.x > 1.0 || tUV.y < 0.0 || tUV.y > 1.0) {\rvisibility +=1.0;\r} else {\rvisibility +=sampleVisibility;\r}\r}\r}\r\n\rvisibility/=9.0;\r\n\rlet depthFactor=shadowDepth;\r\n\rlet minVisibility=0.2 + depthFactor * 0.6;\r\n\rreturn max(visibility,minVisibility);\r\n}\r\n",drawPicking:"\r\n@fragment\r\nfn picking(inputData:InputData) -> @location(0) vec4<f32> {\rvar finalColor:vec4<f32>=inputData.pickingId;\rreturn finalColor;\r\n}\r\n",normalFunctions:"\r\nfn cotangent_frame( N:vec3<f32>, p:vec3<f32>, uv:vec2<f32>) -> mat3x3<f32>{\rlet dp1:vec3<f32>=dpdx( p );\rlet dp2:vec3<f32>=dpdy( p );\rlet duv1:vec2<f32>=dpdx( uv );\rlet duv2:vec2<f32>=dpdy( uv );\r\n\rlet dp2perp:vec3<f32>=cross( dp2,N );\rlet dp1perp:vec3<f32>=cross( N,dp1 );\rlet T:vec3<f32>=dp2perp * duv1.x + dp1perp * duv2.x;\rlet B:vec3<f32>=dp2perp * duv1.y + dp1perp * duv2.y;\rlet invmax:f32=inverseSqrt( max( dot(T,T),dot(B,B) ) );\rreturn mat3x3<f32>( T * invmax,B * invmax,N );\r\n}\r\nfn perturb_normal( N:vec3<f32>, V:vec3<f32>, texcoord:vec2<f32>, normalColor:vec3<f32>,normalPower:f32 ) -> vec3<f32> {\rvar map:vec3<f32>=normalColor;\rmap= map * 255./127. - 128./127.;\rmap=vec3<f32>(map.xy * -normalPower,map.z);\rlet TBN:mat3x3<f32>=cotangent_frame(N,V,texcoord);\rreturn normalize(TBN * map);\r\n}\r\n"});Object.freeze(sn);const on=Object.keys(sn).join("|"),un=new RegExp(`#redgpu_include (${on})`,"g"),parseIncludeWGSL=i=>i.replace(un,(i,m)=>sn[m]||i).replace(/REDGPU_DEFINE_TILE_COUNT_X/g,an.TILE_COUNT_X.toString()).replace(/REDGPU_DEFINE_TILE_COUNT_Y/g,an.TILE_COUNT_Y.toString()).replace(/REDGPU_DEFINE_TILE_COUNT_Z/g,an.TILE_COUNT_Z.toString()).replace(/REDGPU_DEFINE_TOTAL_TILES/g,an.getTotalTileSize().toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_X/g,an.WORKGROUP_SIZE_X.toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_Y/g,an.WORKGROUP_SIZE_Y.toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_Z/g,an.WORKGROUP_SIZE_Z.toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_Z/g,an.WORKGROUP_SIZE_Z.toString()).replace(/REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTER/g,an.MAX_LIGHTS_PER_CLUSTER.toString()),processMembers=(i,m=0,g=0)=>{let x=0,_=g;const b=i?.reduce((i,g,b)=>{const{type:y,offset:T,size:w,stride:P,count:$,isArray:H}=g,{format:z}=y,q="array"===y.name?`${z.name}${z.format?`${z.format.name}`:""}`:`${y.name}${z?`${z.name}`:""}`;if(0===b&&(x=T),_=T+w,i[g.name]=((i,m,g)=>{const x=UniformType[g];return{uniformOffset:i.offset+m,stride:i.stride,isArray:i.isArray,typeInfo:x,View:x?.View}})(g,m,q),H&&z.members){const m=processMembers(z.members).members;i[g.name].memberList=Array.from({length:$},(i,g)=>{const x={};for(const i in m){const _=x[i]={...m[i]};_.uniformOffset=_.uniformOffset+T+P*g}return x})}else y.members&&(i[g.name]=processMembers(y.members,T+m,_));return i},{});return{members:b,startOffset:x,endOffset:_}},parseWGSL=i=>{const m=parseIncludeWGSL(i),g=new _t(m);return{uniforms:{...(_=g.uniforms,_.reduce((i,m)=>(i[m.name]={name:m.name,...processMembers(m.members),arrayBufferByteLength:m.size,stride:m.stride},m.attributes?.forEach(g=>i[m.name][g.name]=+g.value),i),{}))},storage:{...(x=g.storage,x.reduce((i,m)=>(i[m.name]={name:m.name,...processMembers(m.members),arrayBufferByteLength:m.size,stride:m.stride,acccess:m.access,type:m.type},m.attributes?.forEach(g=>i[m.name][g.name]=+g.value),i),{}))},samplers:g.samplers,textures:g.textures,vertexEntries:g.entry.vertex.map(i=>i.name),fragmentEntries:g.entry.fragment.map(i=>i.name),computeEntries:g.entry.compute.map(i=>i.name),shaderSource:m};var x,_},cn={ZERO:"zero",ONE:"one",SRC:"src",ONE_MINUS_SRC:"one-minus-src",SRC_ALPHA:"src-alpha",ONE_MINUS_SRC_ALPHA:"one-minus-src-alpha",DST:"dst",ONE_MINUS_DST:"one-minus-dst",DST_ALPHA:"dst-alpha",ONE_MINUS_DST_ALPHA:"one-minus-dst-alpha",SRC_ALPHA_SATURATED:"src-alpha-saturated",CONSTANT:"constant",ONE_MINUS_CONSTANT:"one-minus-constant",SRC1:"src1",ONE_MINUS_SRC1:"one-minus-src1",SRC1_ALPHA:"src1-alpha",ONE_MINUS_SRC1_ALPHA:"one-minus-src1-alpha"};Object.freeze(cn);const hn={ADD:"add",SUBTRACT:"subtract",REVERSE_SUBTRACT:"reverse-subtract",MIN:"min",MAX:"max"};Object.freeze(hn);class FragmentGPURenderInfo{fragmentShaderModule;fragmentUniformInfo;fragmentBindGroupLayout;fragmentUniformBuffer;fragmentUniformBindGroup;fragmentState;constructor(i,m,g,x,_,b){this.fragmentShaderModule=i,this.fragmentUniformInfo=m,this.fragmentBindGroupLayout=g,this.fragmentUniformBuffer=x,this.fragmentUniformBindGroup=_,this.fragmentState=b}}Object.freeze(FragmentGPURenderInfo);const fn=Object.values(cn),dn=Object.values(hn);class BlendState{state;#O;#N;#F;#G;constructor(i,m,g,x){this.#G=i,this.srcFactor=m,this.dstFactor=g,this.operation=x}get operation(){return this.#F}set operation(i){dn.includes(i)||consoleAndThrowError(`Invalid GPUBlendOperation:${i}. Valid operations are ${dn.join(",")}`),this.#F=i,this.#V()}get srcFactor(){return this.#O}set srcFactor(i){fn.includes(i)||consoleAndThrowError(`Invalid GPUBlendFactor:${i}. Valid srcFactor factors are ${fn.join(",")}`),this.#O=i,this.#V()}get dstFactor(){return this.#N}set dstFactor(i){fn.includes(i)||consoleAndThrowError(`Invalid GPUBlendFactor:${i}. Valid dstFactor factors are ${fn.join(",")}`),this.#N=i,this.#V()}#V(){const i=this.#F?{operation:this.#F}:{},m=this.#O?{srcFactor:this.#O}:{},g=this.#N?{dstFactor:this.#N}:{};this.state={...i,...m,...g},this.#G.dirtyPipeline=!0}}let mn=class{texture;src;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.src=i.src,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}};class ResourceStateCubeTexture{texture;srcList;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.srcList=i.srcList,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}class ResourceStateBitmapTexture{texture;src;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.src=i.src,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}const basicRegisterResource=(i,m)=>{const{uuid:g,targetResourceManagedState:x}=i,_=m instanceof ResourceStateCubeTexture||m instanceof mn||m instanceof ResourceStateBitmapTexture;try{x.table[g]&&consoleAndThrowError(`Buffer with UUID ${g} is already registered.`),x.table[g]=m,x.length++,_||(x.videoMemory+=i.size)}catch(i){consoleAndThrowError(i.message)}};class ResourceStateUniformBuffer{static dirtyList=[];buffer;uuid;#$=0;constructor(i){this.buffer=i,this.uuid=i.uuid}get useNum(){return this.#$}set useNum(i){this.#$=i,ResourceStateUniformBuffer.dirtyList.push(this)}}const basicUnregisterResource=i=>{const{uuid:m,targetResourceManagedState:g}=i,{table:x}=g;x[m]&&(g.videoMemory-=i.size,delete x[m],g.length--)};class ManagedResourceBase extends ResourceBase{#H;constructor(i,m){super(i),this.#H=i.resourceManager[m]}get targetResourceManagedState(){return this.#H}}class ABaseBuffer extends ManagedResourceBase{#z;constructor(i,m,g){super(i,m),this.#z=g}get usage(){return this.#z}}class AUniformBaseBuffer extends ABaseBuffer{#q;#K;#W;#X;constructor(i,m,g,x,_=""){super(i,m,g),this.#K=x.byteLength,this.#q={size:this.#K,usage:this.usage,label:_};try{this.#X=i.gpuDevice.createBuffer(this.#q)}catch(i){console.error("GPU 버퍼 생성에 실패했습니다:",i)}i.gpuDevice.queue.writeBuffer(this.#X,0,x)}get gpuBuffer(){return this.#X}get data(){return this.#W}get size(){return this.#K}get uniformBufferDescriptor(){return this.#q}destroy(){const i=this.#X;i&&(this.#X=null,this.__fireListenerList(!0),basicUnregisterResource(this),i&&i.destroy())}writeBuffers(i){const{gpuDevice:m}=this.redGPUContext;let g=i.length;for(;g--;){const[x,_]=i[g];m.queue.writeBuffer(this.gpuBuffer,x.uniformOffset,new x.View("number"==typeof _?[_]:_))}}writeBuffer(i,m){this.redGPUContext.gpuDevice.queue.writeBuffer(this.gpuBuffer,i.uniformOffset,new i.View("number"==typeof m?[m]:m))}}const getCacheBufferFromResourceState=(i,m)=>{const{targetResourceManagedState:g}=i,x=((i,m)=>{if(!m)return;let g;const x=i.table;for(const i in x)if(x[i].label===m){g=x[i];break}return g})(g,m);return x?g.table[i.uuid].buffer:null};class UniformBuffer extends AUniformBaseBuffer{constructor(i,m,g="",x=""){super(i,"managedUniformBufferState",GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,m,g);const _=getCacheBufferFromResourceState(this,x);if(_)return _;x&&(this.name=x),basicRegisterResource(this,new ResourceStateUniformBuffer(this))}}Object.freeze(UniformBuffer);const getFileExtension=i=>{if(!i||0===i.trim().length)throw new Error("URL must not be empty or undefined");const m=i.split("/"),g=m[m.length-1],x=g.lastIndexOf(".");return-1===x?"":g.substring(x+1).toLowerCase()},getFileName=(i,m=!0)=>{const g=i.substring(i.lastIndexOf("/")+1);return m?g:g.split(".").slice(0,-1).join(".")},getFilePath=i=>{if(!i||0===i.trim().length)throw new Error("URL must not be empty or undefined");return i.substring(0,i.lastIndexOf("/")+1)},calculateNormals=(i,m)=>{let g,x,_=[];for(g=0;g<i.length;g+=3)_[g+0]=0,_[g+1]=0,_[g+2]=0;for(g=0;g<m.length;g+=3){let b,y,T,w,P=[],$=[],H=[];for(b=3*m[g],y=3*m[g+1],T=3*m[g+2],P[0]=i[T+0]-i[y+0],P[1]=i[T+1]-i[y+1],P[2]=i[T+2]-i[y+2],$[0]=i[b+0]-i[y+0],$[1]=i[b+1]-i[y+1],$[2]=i[b+2]-i[y+2],H[0]=P[1]*$[2]-P[2]*$[1],H[1]=P[2]*$[0]-P[0]*$[2],H[2]=P[0]*$[1]-P[1]*$[0],x=0;x<3;x++)w=3*m[g+x],_[w+0]=_[w+0]+H[0],_[w+1]=_[w+1]+H[1],_[w+2]=_[w+2]+H[2]}for(g=0;g<i.length;g+=3){let i=[];i[0]=_[g+0],i[1]=_[g+1],i[2]=_[g+2];let m=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);0===m&&(m=1),i[0]=i[0]/m,i[1]=i[1]/m,i[2]=i[2]/m,_[g+0]=i[0],_[g+1]=i[1],_[g+2]=i[2]}return _};function calculateTextureByteSize(i){return function(i){switch(i){case"r8unorm":case"r8snorm":case"r8uint":case"r8sint":return 1;case"r16uint":case"r16sint":case"r16float":case"rg8unorm":case"rg8snorm":case"rg8uint":case"rg8sint":case"depth16unorm":return 2;case"r32uint":case"r32sint":case"r32float":case"rg16uint":case"rg16sint":case"rg16float":case"rgba8unorm":case"rgba8unorm-srgb":case"rgba8snorm":case"rgba8uint":case"rgba8sint":case"bgra8unorm":case"bgra8unorm-srgb":case"depth24plus":case"depth32float":return 4;case"rg32uint":case"rg32sint":case"rg32float":case"rgba16uint":case"rgba16sint":case"rgba16float":return 8;case"rgba32uint":case"rgba32sint":case"rgba32float":return 16;default:throw new Error(`Unrecognized texture format:${i}`)}}(i.format)*(i.size[0]*i.size[1]*(i.size[2]||1))*(i.sampleCount?i.sampleCount:1)}const pn=create$5(),computeViewFrustumPlanes=(i,m)=>{multiply$5(pn,i,m);const g=[[pn[3]-pn[0],pn[7]-pn[4],pn[11]-pn[8],pn[15]-pn[12]],[pn[3]+pn[0],pn[7]+pn[4],pn[11]+pn[8],pn[15]+pn[12]],[pn[3]+pn[1],pn[7]+pn[5],pn[11]+pn[9],pn[15]+pn[13]],[pn[3]-pn[1],pn[7]-pn[5],pn[11]-pn[9],pn[15]-pn[13]],[pn[3]-pn[2],pn[7]-pn[6],pn[11]-pn[10],pn[15]-pn[14]],[pn[3]+pn[2],pn[7]+pn[6],pn[11]+pn[10],pn[15]+pn[14]]];for(let i=0;i<6;i++){const m=g[i],x=Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]);m[0]/=x,m[1]/=x,m[2]/=x,m[3]/=x}return g},formatBytes=(i,m=2)=>{if(("number"!=typeof i||i<0||Number.isNaN(i)||!Number.isInteger(i))&&consoleAndThrowError("Invalid input:'bytes' must be a uint"),0===i)return"0 Bytes";const g=m<0?0:m,x=Math.floor(Math.log(i)/Math.log(1024));return parseFloat((i/Math.pow(1024,x)).toFixed(g))+" "+["Bytes","KB","MB","GB"][x]},getMipLevelCount=(i,m)=>Math.floor(Math.log2(Math.max(i,m)))+1,gn=create$5(),xn={x:0,y:0,z:0,w:0},getScreenPoint=(i,m)=>{"View"!==i?.constructor?.name&&consoleAndThrowError("allow only View3D instance"),identity$2(gn);const{projectionMatrix:g,rawCamera:x,pixelRectArray:_}=i;return multiply$5(gn,g,x.modelMatrix),multiply$5(gn,gn,m),xn.z=gn[14],xn.w=gn[15],xn.x=.5*gn[12]/xn.w+.5,xn.y=.5*gn[13]/xn.w+.5,[(_[0]+xn.x*_[2])/window.devicePixelRatio,(_[1]+(1-xn.y)*_[3])/window.devicePixelRatio]},_n=create$5(),localToWorld=(i,m,g,x)=>(validateNumber(m),validateNumber(g),validateNumber(x),identity$2(_n),translate$1(_n,_n,[m,g,x]),multiply$5(_n,i,_n),[_n[12],_n[13],_n[14]]),quaternionToRotationMat4=(i,m)=>{let g=i[0],x=i[1],_=i[2],b=i[3],y=g+g,T=x+x,w=_+_,P=g*y,$=g*T,H=g*w,z=x*T,q=x*w,W=_*w,ye=b*y,Ge=b*T,Ke=b*w;return m[0]=1-(z+W),m[4]=$-Ke,m[8]=H+Ge,m[1]=$+Ke,m[5]=1-(P+W),m[9]=q-ye,m[2]=H-Ge,m[6]=q+ye,m[10]=1-(P+z),m[3]=0,m[7]=0,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,m};let vn,bn,yn,Tn,Sn,wn,Mn=create$4(),Rn=create$5(),Pn=create$5();function sortTransparentObjects(i,m){const g={},{x:x,y:_,z:b}=i;return m.sort((i,m)=>{if(!g[i.uuid]){const m=i.x-x,y=i.y-_,T=i.z-b;g[i.uuid]=m*m+y*y+T*T}if(!g[m.uuid]){const i=m.x-x,y=m.y-_,T=m.z-b;g[m.uuid]=i*i+y*y+T*T}return g[m.uuid]-g[i.uuid]})}const Cn=create$5(),In=create$5(),worldToLocal=(i,m,g,x)=>(validateNumber(m),validateNumber(g),validateNumber(x),identity$2(Cn),identity$2(In),translate$1(Cn,Cn,[m,g,x]),multiply$5(In,Cn,i),[In[0]*m+In[1]*g+In[2]*x+In[3],In[4]*m+In[5]*g+In[6]*x+In[7],In[8]*m+In[9]*g+In[10]*x+In[11]]),En=console.log.bind(console);var Ln=Object.freeze({__proto__:null,calculateGeometryAABB:calculateGeometryAABB,calculateMeshAABB:calculateMeshAABB,calculateMeshOBB:calculateMeshOBB,calculateNormals:calculateNormals,calculateTextureByteSize:calculateTextureByteSize,computeViewFrustumPlanes:computeViewFrustumPlanes,convertHexToRgb:convertHexToRgb,convertRgbToHex:convertRgbToHex,createUUID:createUUID,formatBytes:formatBytes,getFileExtension:getFileExtension,getFileName:getFileName,getFilePath:getFilePath,getMipLevelCount:getMipLevelCount,getScreenPoint:getScreenPoint,keepLog:En,localToWorld:localToWorld,matToEuler:mat4ToEuler,quaternionToRotationMat4:quaternionToRotationMat4,screenToWorld:(i,m)=>{const{rawCamera:g}=m;return vn=2*i[0]/i[2]-1,bn=-2*i[1]/i[3]+1,yn=1,multiply$5(Pn,m.projectionMatrix,g.modelMatrix),wn=clone$5(Pn),invert$2(wn,wn),Mn=fromValues$4(vn,bn,1),identity$2(Rn),translate$1(Rn,Rn,Mn),multiply$5(wn,wn,Rn),Mn[0]=wn[12],Mn[1]=wn[13],Mn[2]=wn[14],Tn=Pn[12]*vn+Pn[13]*bn+Pn[15],0!==Tn&&(Sn=1/Tn,Mn[0]/=Sn,Mn[1]/=Sn,Mn[2]/=Sn,Mn[0]=Mn[0]+g.x,Mn[1]=Mn[1]+g.y,Mn[2]=Mn[2]+g.z),[Mn[0],Mn[1],Mn[2]]},sortTransparentObjects:sortTransparentObjects,uuidToUint:uuidToUint,worldToLocal:worldToLocal});const imageBitmapToGPUTexture=(i,m,g,x=!0)=>{const _=i.createTexture(g);for(let b=0;b<m.length;b++){const y=m[b],T={source:y},w={texture:_,origin:[0,0,b],premultipliedAlpha:x};g.format.includes("srgb")&&(w.colorSpace="srgb");const P=[y.width,y.height];i.queue.copyExternalImageToTexture(T,w,P)}return _};async function loadAndCreateBitmapImage(i,m="none",g="premultiply"){const x=await fetch(i),_=await x.blob();return createImageBitmap(_,{colorSpaceConversion:m,premultiplyAlpha:g})}class CubeTexture extends ManagedResourceBase{static defaultViewDescriptor={dimension:"cube",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:6};#j;#Y;#Z;#J;#Q;#ee;#te=0;#re;#ne;#ie;constructor(i,m,g=!0,x,_,b){super(i,"managedCubeTextureState"),this.#ne=x,this.#ie=_,this.#Q=g,this.#re=b||navigator.gpu.getPreferredCanvasFormat(),this.#Y=m,this.#Z=m?.toString();const{table:y}=this.targetResourceManagedState;let T;for(const i in y)if(y[i].cacheKey===this.#Z){T=y[i];break}if(T){const i=y[T.uuid].texture;this.#ne?.(i)}else this.srcList=m,this.#ae()}get viewDescriptor(){return{...CubeTexture.defaultViewDescriptor,mipLevelCount:this.#J}}get cacheKey(){return this.#Z}get videoMemorySize(){return this.#te}get gpuTexture(){return this.#j}get mipLevelCount(){return this.#J}get srcList(){return this.#Y}set srcList(i){this.#Y=i,this.#Z=i?.toString()||createUUID(),this.#Y?.length&&this.#se(this.#Y)}get useMipmap(){return this.#Q}set useMipmap(i){this.#Q=i,this.#oe()}destroy(){const i=this.#j;this.#ue(null),this.__fireListenerList(!0),this.#Y=null,this.#Z=null,this.#le(),i&&i.destroy()}setGPUTextureDirectly(i,m,g=!0){this.#j&&(this.#j.destroy(),this.targetResourceManagedState.videoMemory-=this.#te),En("gpuTexture",i),this.#j=i,this.#Q=g,this.#J=i.mipLevelCount,this.#Z=m||`direct_${this.uuid}`;const x={size:[i.width,i.height,i.depthOrArrayLayers],format:i.format,usage:i.usage,mipLevelCount:this.#J};this.#te=calculateTextureByteSize(x),this.targetResourceManagedState.videoMemory+=this.#te,this.__fireListenerList()}#ue(i){this.#j=i,i||(this.#ee=null),this.__fireListenerList()}#ae(){basicRegisterResource(this,new ResourceStateCubeTexture(this))}#le(){basicUnregisterResource(this)}#oe(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext,{mipmapGenerator:g}=m;this.#j&&(this.#j.destroy(),this.#j=null),this.#J=1;{const m=this.#ee,x=m[0],{width:_,height:b}=x,y={size:[_,b,6],format:this.#re,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:`cubeTexture_${this.#Y?.toString()||this.uuid}`};this.#Q&&(this.#J=getMipLevelCount(_,b),y.mipLevelCount=this.#J,y.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const T=imageBitmapToGPUTexture(i,m,y);this.targetResourceManagedState.videoMemory-=this.#te,this.#te=calculateTextureByteSize(y),this.targetResourceManagedState.videoMemory+=this.#te,this.#Q&&g.generateMipmap(T,y),this.#ue(T)}}async#se(i){this.#ee=await async function(i){const m=i.map(i=>loadAndCreateBitmapImage(i));return await Promise.all(m)}(i);try{this.#oe(),this.#ne?.(this)}catch(i){console.error(i),this.#ie?.(i)}}}Object.freeze(CubeTexture);class PackedTexture{#_;#ce;#he;#j;#v;constructor(i){this.#_=i,this.#v=i.gpuDevice,this.#ce=this.#fe(),this.#he=this.#de()}get gpuTexture(){return this.#j}async packing(i,m,g,x,_){const b={r:"r",g:"g",b:"b",a:"a",..._},y={size:[m,g,1],format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,label:x||`packedTexture_${createUUID()}'`};this.#j&&(this.#j.destroy(),this.#j=null);const T=this.#v.createTexture(y),w=this.#v.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),P=new Uint32Array([["r","g","b","a"].indexOf(b.r),["r","g","b","a"].indexOf(b.g),["r","g","b","a"].indexOf(b.b),["r","g","b","a"].indexOf(b.a)]);this.#v.queue.writeBuffer(w,0,P);const $=[{binding:0,resource:i.r?i.r.createView({label:i.r.label}):this.#_.resourceManager.emptyBitmapTextureView},{binding:1,resource:i.g?i.g.createView({label:i.g.label}):this.#_.resourceManager.emptyBitmapTextureView},{binding:2,resource:i.b?i.b.createView({label:i.b.label}):this.#_.resourceManager.emptyBitmapTextureView},{binding:3,resource:i.a?i.a.createView({label:i.a.label}):this.#_.resourceManager.emptyBitmapTextureView},{binding:4,resource:this.#he},{binding:5,resource:{buffer:w}}],H=this.#v.createBindGroup({layout:this.#ce.getBindGroupLayout(0),entries:$}),z=this.#v.createCommandEncoder(),q=z.beginRenderPass({colorAttachments:[{view:T.createView({label:T.label}),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0]}]});q.setPipeline(this.#ce),q.setBindGroup(0,H),q.draw(6,1,0,0),q.end(),this.#v.queue.submit([z.finish()]),this.#j=T,w.destroy()}#fe(){const i="\n\tstruct VertexOut {@builtin(position) position:vec4<f32>,@location(0) uv:vec2<f32>,\n\t};\n\n\t@vertex\n\tfn vertexMain(@builtin(vertex_index) VertexIndex:u32) -> VertexOut {var pos=array<vec2<f32>,6>(vec2(-1.0,-1.0),vec2( 1.0,-1.0),vec2(-1.0, 1.0),vec2(-1.0, 1.0),vec2( 1.0,-1.0),vec2( 1.0, 1.0));\nvar uv=array<vec2<f32>,6>(vec2(0.0,1.0),vec2(1.0,1.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(1.0,1.0),vec2(1.0,0.0));\nvar output:VertexOut;output.position=vec4(pos[VertexIndex],0.0,1.0);output.uv=uv[VertexIndex];return output;\n\t}\n\n\tstruct ComponentMapping {r_component:u32,g_component:u32,b_component:u32,a_component:u32,\n\t};\n\n\t@group(0) @binding(0) var textureR:texture_2d<f32>;\n\t@group(0) @binding(1) var textureG:texture_2d<f32>;\n\t@group(0) @binding(2) var textureB:texture_2d<f32>;\n\t@group(0) @binding(3) var textureA:texture_2d<f32>;\n\t@group(0) @binding(4) var sampler0:sampler;\n\t@group(0) @binding(5) var<uniform> mapping:ComponentMapping;\n\n\tfn getComponent(color:vec4<f32>,componentIndex:u32) -> f32 {switch componentIndex {case 0u:{ return color.r;}case 1u:{ return color.g;}case 2u:{ return color.b;}case 3u:{ return color.a;}default:{ return 0.0;}}\n\t}\n\n\t@fragment\n\tfn main(input:VertexOut) -> @location(0) vec4<f32> {let colorR=textureSample(textureR,sampler0,input.uv);let colorG=textureSample(textureG,sampler0,input.uv);let colorB=textureSample(textureB,sampler0,input.uv);let colorA=textureSample(textureA,sampler0,input.uv);\nlet r=getComponent(colorR,mapping.r_component);let g=getComponent(colorG,mapping.g_component);let b=getComponent(colorB,mapping.b_component);let a=getComponent(colorA,mapping.a_component);\nreturn vec4(r,g,b,a);\n\t}\n\t";return this.#v.createRenderPipeline({layout:"auto",vertex:{module:this.#v.createShaderModule({code:i}),entryPoint:"vertexMain"},fragment:{module:this.#v.createShaderModule({code:i}),entryPoint:"main",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"}})}#de(){return this.#v.createSampler({magFilter:"linear",minFilter:"linear"})}}const Bn={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DARKEN:6,OVERLAY:7,COLOR_DODGE:8,COLOR_BURN:9,HARD_LIGHT:10,SOFT_LIGHT:11,DIFFERENCE:12,EXCLUSION:13,DIVIDE:14,VIVID_LIGHT:15,LINEAR_BURN:16,PIN_LIGHT:17,SATURATION:18,HUE:19,LUMINOSITY:20,COLOR:21,NEGATION:22},getBindGroupLayoutDescriptorFromShaderInfo=(i,m,g,x=!0)=>{const{textures:_,samplers:b,uniforms:y,storage:T}=i,w=[];for(const i in T){const x=T[i],{binding:_,name:b,group:y,type:P}=x;if(x.access){const i={write:"write-only-storage",read:"read-only-storage",read_write:"read-write-storage"}[x.access];m===y&&w.push({binding:_,visibility:g,buffer:{type:i}})}else if(m===y){const{access:i,format:m}=P,x={write:"write-only",read:"read-only",read_write:"read-write"}[i],b=m.name;w.push({binding:_,visibility:g,storageTexture:{access:x,format:b}})}}for(const i in _){const b=_[i],{binding:y,name:T,group:P,type:$}=b,{name:H}=$;m===P&&w.push({binding:y,visibility:g,texture:"texture_depth_2d"===H||"texture_depth_multisampled_2d"===H?{viewDimension:"2d",sampleType:"depth",multisampled:x}:"texture_cube"===H?{viewDimension:"cube"}:{}})}for(const i in b){const x=b[i],{binding:_,name:y,group:T}=x;m===T&&w.push({binding:_,visibility:g,sampler:{type:"filtering"}})}for(const i in y){const x=y[i],{binding:_,name:b,group:T}=x;m===T&&w.push({binding:_,visibility:g,buffer:{type:"uniform"}})}return{entries:w}},getFragmentBindGroupLayoutDescriptorFromShaderInfo=(i,m)=>getBindGroupLayoutDescriptorFromShaderInfo(i,m,GPUShaderStage.FRAGMENT),getVertexBindGroupLayoutDescriptorFromShaderInfo=(i,m)=>getBindGroupLayoutDescriptorFromShaderInfo(i,m,GPUShaderStage.VERTEX),getComputeBindGroupLayoutDescriptorFromShaderInfo=(i,m,g)=>getBindGroupLayoutDescriptorFromShaderInfo(i,m,GPUShaderStage.COMPUTE,g);class ABaseMaterial extends ResourceBase{gpuRenderInfo;dirtyPipeline=!1;transparent=!1;#me=GPUColorWrite.ALL;#pe;#ge;#xe;#_e;#ve;#be;#ye;#Te;#Se;#we;#Me;#Re;#Pe;#Ce;#Ie;#Ee;#Le=Bn.MULTIPLY;constructor(i,m,g,x){super(i),this.#Ie=m,this.#ye=`FRAGMENT_MODULE_${this.#Ie}`,this.#Te=`FRAGMENT_BIND_GROUP_DESCRIPTOR_${m}`,this.#Se=`FRAGMENT_BIND_GROUP_LAYOUT_${m}`,this.#we=g,this.#Me=g?.storage,this.#Re=g?.uniforms.uniforms,this.#Pe=g?.textures,this.#Ce=g?.samplers,this.#Ee=i.resourceManager.getGPUBindGroupLayout(this.#Se)||i.resourceManager.createBindGroupLayout(this.#Se,getFragmentBindGroupLayoutDescriptorFromShaderInfo(g,x)),this.#pe=new BlendState(this,cn.SRC_ALPHA,cn.ONE_MINUS_SRC_ALPHA,hn.ADD),this.#ge=new BlendState(this,cn.SRC_ALPHA,cn.ONE_MINUS_SRC_ALPHA,hn.ADD),this.#xe=i.resourceManager,this.#_e=this.#xe.basicSampler.gpuSampler,this.#ve=this.#xe.emptyBitmapTextureView,this.#be=this.#xe.emptyCubeTextureView}get tintBlendMode(){const i=Object.entries(Bn).find(([,i])=>i===this.#Le);if(!i)throw new Error(`Invalid tint mode value:${this.#Le}`);return i[0]}set tintBlendMode(i){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=this.gpuRenderInfo;let x;if("string"==typeof i){if(!(i in Bn))throw new Error(`Invalid tint mode key:${i}`);x=Bn[i]}else{if("number"!=typeof i||!Object.values(Bn).includes(i))throw new Error(`Invalid tint mode:${i}`);x=i}g.writeBuffer(m.members.tintBlendMode,x),this.#Le=x}get MODULE_NAME(){return this.#Ie}get FRAGMENT_SHADER_MODULE_NAME(){return this.#ye}get FRAGMENT_BIND_GROUP_DESCRIPTOR_NAME(){return this.#Te}get STORAGE_STRUCT(){return this.#Me}get UNIFORM_STRUCT(){return this.#Re}get blendColorState(){return this.#pe}get blendAlphaState(){return this.#ge}get writeMaskState(){return this.#me}set writeMaskState(i){this.#me=i}initGPURenderInfos(){const{redGPUContext:i}=this,{resourceManager:m}=i,g=m.createGPUShaderModule(this.#ye,{code:this.#we.shaderSource}),x=new ArrayBuffer(Math.max(this.#Re.arrayBufferByteLength,16)),_=new UniformBuffer(i,x,`UniformBuffer_${this.#Ie}_${this.uuid}`);this.gpuRenderInfo=new FragmentGPURenderInfo(g,this.#Re,this.#Ee,_,null,null),this._updateBaseProperty(),this._updateFragmentState()}_updateFragmentState(){const{gpuDevice:i}=this.redGPUContext,m=[];for(const i in this.#Pe){const g=this.#Pe[i],{binding:x,name:_,group:b,type:y}=g,{name:T}=y;let w;w="texture_cube"===T?this.getGPUResourceCubeTextureView(this[_]):this[_]instanceof PackedTexture?this[_].gpuTexture?this[_].gpuTexture.createView({}):this.#ve:this.getGPUResourceBitmapTextureView(this[_])||this.#ve,2===b&&m.push({binding:x,resource:w})}for(const i in this.#Ce){const g=this.#Ce[i],{binding:x,name:_,group:b}=g;2===b&&m.push({binding:x,resource:this.getGPUResourceSampler(this[_])})}this.#Re&&m.push({binding:this.#Re.binding,resource:{buffer:this.gpuRenderInfo.fragmentUniformBuffer.gpuBuffer,offset:0,size:this.gpuRenderInfo.fragmentUniformBuffer.size}});const g={layout:this.gpuRenderInfo.fragmentBindGroupLayout,label:this.#Te,entries:m},x=i.createBindGroup(g);this.gpuRenderInfo.fragmentState=this.getFragmentRenderState(),this.gpuRenderInfo.fragmentUniformBindGroup=x}getFragmentRenderState(i="main"){return{module:this.gpuRenderInfo.fragmentShaderModule,entryPoint:i,targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:this.blendColorState.state,alpha:this.blendAlphaState.state},writeMask:this.writeMaskState}]}}_updateBaseProperty(){const{fragmentUniformInfo:i,fragmentUniformBuffer:m}=this.gpuRenderInfo,{members:g}=i;for(const x in g){const g=this[x];g instanceof ColorRGBA?m.writeBuffer(i.members[x],g.rgbaNormal):g instanceof ColorRGB?m.writeBuffer(i.members[x],g.rgbNormal):Dn.test(x)||(this[x]=g)}}getGPUResourceBitmapTextureView(i){return i?.gpuTexture?.createView({label:i.src})||this.#ve}getGPUResourceCubeTextureView(i,m){return i?.gpuTexture?.createView(m||i.viewDescriptor||CubeTexture.defaultViewDescriptor)||this.#be}getGPUResourceSampler(i){return i?.gpuSampler||this.#_e}}const Dn=/^use\w+Texture$/;Br.defineByPreset(ABaseMaterial,[Br.PRESET_POSITIVE_NUMBER.OPACITY]),Br.defineBoolean(ABaseMaterial,[["useTint",!1]]),Br.defineColorRGBA(ABaseMaterial,["tint","#ff0000"]),Object.freeze(ABaseMaterial);const Un=parseWGSL("#redgpu_include drawPicking;\r\n#redgpu_include calcTintBlendMode;\r\nstruct Uniforms {\rcolor:vec3<f32>,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n};\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r@location(12) combinedOpacity:f32,\r@location(15) pickingId:vec4<f32>,\r\n}\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\rvar finalColor=vec4<f32>( uniforms.color.r,uniforms.color.g,uniforms.color.b,uniforms.opacity * inputData.combinedOpacity);\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\rreturn finalColor;\r\n}\r\n\r\n\r\n");class ColorMaterial extends ABaseMaterial{constructor(i,m="#fff"){super(i,"COLOR_MATERIAL",Un,2),this.initGPURenderInfos(),this.color.setColorByHEX(m)}}Br.defineByPreset(ColorMaterial,[Br.PRESET_COLOR_RGB.COLOR]),Object.freeze(ColorMaterial);class InterleaveType{static get float32(){return{numElements:1,stride:Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32",offset:0}}static get float32x2(){return{numElements:2,stride:2*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x2",offset:0}}static get float32x3(){return{numElements:3,stride:3*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x3",offset:0}}static get float32x4(){return{numElements:4,stride:4*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x4",offset:0}}}Object.freeze(InterleaveType);class InterleavedStructElement{attributeName;attributeStride;interleaveType;constructor(i,m,g){this.attributeName=i,this.attributeStride=m,this.interleaveType=g}}class InterleavedStruct{#Be;#a="";#De=[];#Ue=0;constructor(i,m=""){this.#a=m,this.#Ae(i),this.#ke()}get label(){return this.#a}get attributes(){return this.#De}get arrayStride(){return this.#Ue}get define(){return{...this.#Be}}#Ae(i){let m={};for(const g in i){const x=i[g],_=x.stride;m[g]=new InterleavedStructElement(g,_,x),_%4!=0&&consoleAndThrowError(`Invalid attribute stride:${_}`)}this.#Be=m}#ke(){this.#Ue=0,this.#De=[];for(const[i,{attributeStride:m,interleaveType:g}]of Object.entries(this.#Be))this.#De.push({attributeName:i,shaderLocation:this.#De.length,offset:this.#Ue,format:g.gpuVertexFormat}),this.#Ue+=m}}class ResourceStateVertexBuffer{static dirtyList=[];buffer;label;uuid;#$=0;constructor(i){this.buffer=i,this.label=i.name,this.uuid=i.uuid}get useNum(){return this.#$}set useNum(i){this.#$=i,ResourceStateVertexBuffer.dirtyList.push(this)}}class VertexBuffer extends ABaseBuffer{#Oe=0;#Ne=0;#Fe;#W;#Ge=0;#X;constructor(i,m,g,x=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,_=""){super(i,"managedVertexBufferState",x);const b=getCacheBufferFromResourceState(this,_);if(b)return b;this.#Fe=g,_&&(this.name=_),this.changeData(m,this.#Fe),basicRegisterResource(this,new ResourceStateVertexBuffer(this))}get gpuBuffer(){return this.#X}get stride(){return this.#Ne}get data(){return this.#W}get size(){return this.#W.byteLength||0}get interleavedStruct(){return this.#Fe}get vertexCount(){return this.#Oe}get triangleCount(){return this.#Ge}destroy(){const i=this.#X;i&&(this.#X=null,this.__fireListenerList(!0),basicUnregisterResource(this),i&&i.destroy())}updateAllData(i){const{gpuDevice:m}=this;m.queue.writeBuffer(this.#X,0,this.#W)}changeData(i,m){const{gpuDevice:g}=this;if(Array.isArray(i)&&(i=new Float32Array(i)),this.#W=i,m&&this.#Ve(m),this.#X){this.targetResourceManagedState.videoMemory-=this.#W.byteLength||0;let i=this.#X;requestAnimationFrame(()=>{i.destroy()}),this.#X=null}this.targetResourceManagedState.videoMemory+=this.#W.byteLength;const x={size:this.#W.byteLength,usage:this.usage,label:this.name};this.#X=g.createBuffer(x),this.#Ge=this.#W.length/this.#Ne,g.queue.writeBuffer(this.#X,0,this.#W)}#Ve(i){this.#Fe=i,this.#Oe=0,this.#Ne=0;for(const i in this.#Fe.define){const m=this.#Fe.define[i].attributeStride/Float32Array.BYTES_PER_ELEMENT;this.#Oe+=m,this.#Ne+=m}this.#Oe=this.#W.length/this.#Oe}}Object.freeze(VertexBuffer);class DrawDebuggerMesh{#_;#$e;#T;#He;#ze;#qe="OBB";#Ke;#We;#Xe=null;#je=null;constructor(i,m){this.#_=i,this.#$e=m;const g=this.#Ye(i);this.#T=g.vertexBuffer,this.#He=new ColorMaterial(i),this.#He.color.setColorByRGB(255,0,0),this.#ze=new Mesh(i,g,this.#He),this.#ze.primitiveState.cullMode="none",this.#ze.primitiveState.topology=yr.LINE_LIST,this.#ze.depthStencilState.depthWriteEnabled=!1;const x=this.#Ye(i);this.#Ke=new ColorMaterial(i),this.#Ke.color.setColorByRGB(0,255,0),this.#We=new Mesh(i,x,this.#Ke),this.#We.primitiveState.cullMode="none",this.#We.primitiveState.topology=yr.LINE_LIST,this.#We.depthStencilState.depthWriteEnabled=!1}get debugMode(){return this.#qe}set debugMode(i){this.#qe=i,"OBB"===i?this.#He.color.setColorByRGB(255,0,0):"AABB"===i?this.#He.color.setColorByRGB(0,255,0):"BOTH"===i&&(this.#He.color.setColorByRGB(255,0,0),this.#Ke.color.setColorByRGB(0,255,0)),this.#Xe=null,this.#je=null}#Ye(i){const m=new Float32Array(192),g=new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexNormal:InterleaveType.float32x3,texcoord:InterleaveType.float32x2},`wireframeBoxStruct_${Math.random()}`),x=new VertexBuffer(i,m,g);return new Geometry(i,x)}#Ze(i){if(!this.#Xe)return!0;const m=this.#Xe;return m.center[0]!==i.center[0]||m.center[1]!==i.center[1]||m.center[2]!==i.center[2]||m.halfExtents[0]!==i.halfExtents[0]||m.halfExtents[1]!==i.halfExtents[1]||m.halfExtents[2]!==i.halfExtents[2]||!this.#Je(m.orientation,i.orientation)}#Qe(i){if(!this.#je)return!0;const m=this.#je;return m.minX!==i.minX||m.maxX!==i.maxX||m.minY!==i.minY||m.maxY!==i.maxY||m.minZ!==i.minZ||m.maxZ!==i.maxZ}#Je(i,m){if(i.length!==m.length)return!1;for(let g=0;g<i.length;g++)if(Math.abs(i[g]-m[g])>1e-4)return!1;return!0}#et(i){this.#Xe={center:[i.center[0],i.center[1],i.center[2]],halfExtents:[i.halfExtents[0],i.halfExtents[1],i.halfExtents[2]],orientation:new Float32Array(i.orientation)}}#tt(i){this.#je={...i}}#rt(i,m){const{center:g,halfExtents:x,orientation:_}=i,b=[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]].map(i=>{const m=[i[0]*x[0],i[1]*x[1],i[2]*x[2]],b=[_[0]*m[0]+_[4]*m[1]+_[8]*m[2],_[1]*m[0]+_[5]*m[1]+_[9]*m[2],_[2]*m[0]+_[6]*m[1]+_[10]*m[2]];return[b[0]+g[0],b[1]+g[1],b[2]+g[2]]});this.#M(b,m)}#nt(i,m){const{minX:g,maxX:x,minY:_,maxY:b,minZ:y,maxZ:T}=i,w=[[g,_,y],[x,_,y],[x,b,y],[g,b,y],[g,_,T],[x,_,T],[x,b,T],[g,b,T]];this.#M(w,m)}render(i){if(!this.#$e.enableDebugger)return;const m=this.#$e.volumeOBB,g=this.#$e.volumeAABB;m&&g&&("OBB"===this.#qe?(this.#Ze(m)&&(this.#rt(m,this.#T),this.#et(m)),this.#ze.setPosition(0,0,0),this.#ze.setRotation(0,0,0),this.#ze.setScale(1,1,1),this.#ze.render(i)):"AABB"===this.#qe?(this.#Qe(g)&&(this.#nt(g,this.#T),this.#tt(g)),this.#ze.setPosition(0,0,0),this.#ze.setRotation(0,0,0),this.#ze.setScale(1,1,1),this.#ze.render(i)):"BOTH"===this.#qe&&(this.#Ze(m)&&(this.#rt(m,this.#T),this.#et(m)),this.#ze.setPosition(0,0,0),this.#ze.setRotation(0,0,0),this.#ze.setScale(1,1,1),this.#ze.render(i),this.#Qe(g)&&(this.#nt(g,this.#We.geometry.vertexBuffer),this.#tt(g)),this.#We.setPosition(0,0,0),this.#We.setRotation(0,0,0),this.#We.setScale(1,1,1),this.#We.render(i)))}#M(i,m){const g=m.data;let x=0;[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]].forEach(([m,_])=>{g[x++]=i[m][0],g[x++]=i[m][1],g[x++]=i[m][2],g[x++]=0,g[x++]=0,g[x++]=1,g[x++]=0,g[x++]=0,g[x++]=i[_][0],g[x++]=i[_][1],g[x++]=i[_][2],g[x++]=0,g[x++]=0,g[x++]=1,g[x++]=0,g[x++]=0}),m.updateAllData(g)}}Object.freeze(DrawDebuggerMesh);const An={CLAMP_TO_EDGE:"clamp-to-edge",REPEAT:"repeat",MIRRORED_REPEAT:"mirror-repeat"};Object.freeze(An);const kn={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(kn);const On={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(On);const Nn=new Map,Fn=Object.values(kn),Gn=Object.values(An),Vn=Object.values(On);class Sampler extends ResourceBase{#it;#at=kn.LINEAR;#st=kn.LINEAR;#ot=On.LINEAR;#ut=An.REPEAT;#lt=An.REPEAT;#ct=An.REPEAT;#ht;#ft;#dt;#mt=1;constructor(i,m){super(i),this.#pt(m)}get addressModeU(){return this.#ut}set addressModeU(i){this.#gt(i,"addressModeU")}get addressModeV(){return this.#lt}set addressModeV(i){this.#gt(i,"addressModeV")}get addressModeW(){return this.#ct}set addressModeW(i){this.#gt(i,"addressModeW")}get mipmapFilter(){return this.#ot}set mipmapFilter(i){this.#xt(i,Vn,"mipmapFilter")}get gpuSampler(){return this.#it}get magFilter(){return this.#at}set magFilter(i){this.#xt(i,Fn,"magFilter")}get minFilter(){return this.#st}set minFilter(i){this.#xt(i,Fn,"minFilter")}get maxAnisotropy(){return this.#mt}set maxAnisotropy(i){validateUintRange(i,1,16),this.#mt=i,this.#pt()}get isAnisotropyValid(){return!this.#mt||"linear"===this.#at&&"linear"===this.#st&&"linear"===this.#ot}#_t(){this.__fireListenerList()}#gt(i,m){if(Gn.includes(i)){switch(m){case"addressModeU":this.#ut=i;break;case"addressModeV":this.#lt=i;break;case"addressModeW":this.#ct=i}this.#pt()}else consoleAndThrowError(`Invalid ${m} value. Must be one of ${Gn.join(",")},but received:${i}.`)}#xt(i,m,g){if(m.includes(i)||null===i){switch(g){case"mipmapFilter":this.#ot=i;break;case"magFilter":this.#at=i;break;case"minFilter":this.#st=i}this.#pt()}else consoleAndThrowError(`Invalid ${g} value. Must be one of ${m.join(",")},but received:${i}.`)}#vt(){return`${this.#at}:${this.#st}:${this.#ot}:${this.#ut}:${this.#lt}:${this.#ct}:${this.#ht}:${this.#ft}:${this.#dt}:${this.#mt}`}#pt(i){i&&(i.magFilter&&(this.#at=i.magFilter),i.minFilter&&(this.#st=i.minFilter),i.mipmapFilter&&(this.#ot=i.mipmapFilter),i.addressModeU&&(this.#ut=i.addressModeU),i.addressModeV&&(this.#lt=i.addressModeV),i.addressModeW&&(this.#ct=i.addressModeW),void 0!==i.lodMinClamp&&(this.#ht=i.lodMinClamp),void 0!==i.lodMaxClamp&&(this.#ft=i.lodMaxClamp),i.compare&&(this.#dt=i.compare),i.maxAnisotropy&&(this.#mt=i.maxAnisotropy)),this.isAnisotropyValid||1===this.#mt||(console.warn(`Invalid maxAnisotropy setting (${this.#mt}) detected:magFilter(${this.#at}),minFilter(${this.#st}),mipmapFilter(${this.#ot}) must all be set to 'linear' for anisotropic filtering to work. Falling back to default (1).`),this.#mt=1);const m=this.#vt();if(!Nn.has(m)){let i={};this.#at&&(i.magFilter=this.#at),this.#st&&(i.minFilter=this.#st),this.#ot&&(i.mipmapFilter=this.#ot),this.#ut&&(i.addressModeU=this.#ut),this.#lt&&(i.addressModeV=this.#lt),this.#ct&&(i.addressModeW=this.#ct),void 0!==this.#ht&&(i.lodMinClamp=this.#ht),void 0!==this.#ft&&(i.lodMaxClamp=this.#ft),this.#dt&&(i.compare=this.#dt),this.#mt&&(i.maxAnisotropy=this.#mt),Nn.set(m,this.redGPUContext.gpuDevice.createSampler(i))}this.#it=Nn.get(m),this.#_t()}}Object.freeze(Sampler);class BitmapTexture extends ManagedResourceBase{#j;#bt;#Z;#J;#Q;#yt;#te=0;#Tt=!0;#re;#ne;#ie;constructor(i,m,g=!0,x,_,b,y=!0){if(super(i,"managedBitmapTextureState"),this.#ne=x,this.#ie=_,this.#Tt=y,this.#Q=g,this.#re=b||navigator.gpu.getPreferredCanvasFormat(),m){this.#bt=m?.src||m,this.#Z=m?.cacheKey||m||this.uuid;const{table:i}=this.targetResourceManagedState;let g;for(const m in i)if(i[m].cacheKey===this.#Z){g=i[m];break}if(g)return this.#ne?.(this),i[g.uuid].texture;this.src=m,this.#ae()}}get usePremultiplyAlpha(){return this.#Tt}get cacheKey(){return this.#Z}get videoMemorySize(){return this.#te}get gpuTexture(){return this.#j}get mipLevelCount(){return this.#J}get src(){return this.#bt}set src(i){this.#bt=i?.src||i,this.#Z=i?.cacheKey||i||this.uuid,this.#bt&&this.#se(this.#bt)}get useMipmap(){return this.#Q}set useMipmap(i){this.#Q=i,this.#oe()}destroy(){const i=this.#j;this.#ue(null),this.__fireListenerList(!0),this.#bt=null,this.#Z=null,this.#le(),i&&i.destroy()}#ue(i){this.#j=i,i||(this.#yt=null),this.__fireListenerList()}#ae(){basicRegisterResource(this,new mn(this))}#le(){basicUnregisterResource(this)}#oe(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext,{mipmapGenerator:g}=m;this.#j&&(this.#j.destroy(),this.#j=null),this.targetResourceManagedState.videoMemory-=this.#te,this.#te=0;const{width:x,height:_}=this.#yt;this.#J=1;const b={size:[x,_],format:this.#re,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:this.#bt};this.#Q&&(this.#J=getMipLevelCount(x,_),b.mipLevelCount=this.#J,b.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const y=imageBitmapToGPUTexture(i,[this.#yt],b,this.#Tt);this.#te=calculateTextureByteSize(b),this.targetResourceManagedState.videoMemory+=this.#te,this.#Q&&g.generateMipmap(y,b),this.#ue(y)}async#St(i){return new Promise((m,g)=>{const x=new Image;x.src=i,x.onload=()=>{const i=document.createElement("canvas");i.width=x.width||512,i.height=x.height||512;const _=i.getContext("2d");_?(_.fillStyle="rgba(0,0,0,0)",_.fillRect(0,0,i.width,i.height),_.drawImage(x,0,0,i.width,i.height),createImageBitmap(i,{colorSpaceConversion:"none",premultiplyAlpha:this.#Tt?"premultiply":"none"}).then(m).catch(g)):g(new Error("Canvas context could not be created."))},x.onerror=i=>{g(new Error(`Failed to load SVG:${i}`))}})}async#se(i){try{i.endsWith(".svg")?this.#yt=await this.#St(i):this.#yt=await loadAndCreateBitmapImage(i,"none",this.#Tt?"premultiply":"none"),this.#oe(),this.#ne?.(this)}catch(i){console.error(i),this.#ie?.(i)}}}Object.freeze(BitmapTexture);const $n={LOAD:"load",CLEAR:"clear"};Object.freeze($n);const Hn={STORE:"store",DISCARD:"discard"};Object.freeze(Hn);class MipmapGenerator{#_;#he;#wt;#Mt;#Ee;#Rt;#Pt=new Map;#Ct=new Map;constructor(i){this.#_=i,this.#he=new Sampler(i,{minFilter:"linear"}).gpuSampler,this.#Mt={}}getTextureView(i,m,g){this.#Pt.has(i)||this.#Pt.set(i,new Map);const x=this.#Pt.get(i);x.has(m)||x.set(m,new Map);const _=x.get(m);if(!_.has(g)){const x=i.createView({baseMipLevel:m,mipLevelCount:1,dimension:"2d",baseArrayLayer:g,arrayLayerCount:1,label:`mipmap_${m}_${g}_${i.label}`});_.set(g,x)}return _.get(g)}getBindGroup(i){if(!this.#Ct.has(i)){const{gpuDevice:m}=this.#_,g=m.createBindGroup({layout:this.#Ee,entries:[{binding:0,resource:this.#he},{binding:1,resource:i}]});this.#Ct.set(i,g)}return this.#Ct.get(i)}clearCaches(i){if(i){if(this.#Pt.has(i)){const m=this.#Pt.get(i);for(const i of m.values())for(const m of i.values())this.#Ct.delete(m);this.#Pt.delete(i)}}else this.#Pt.clear(),this.#Ct.clear()}getMipmapPipeline(i){const{gpuDevice:m,resourceManager:g}=this.#_;let x=this.#Mt[i];return x||(this.#Rt||(this.#Rt=g.createGPUShaderModule("MODULE_MIP_MAP",{code:"\r\nvar<private> pos:array<vec2<f32>,3>=array<vec2<f32>,3>(\rvec2<f32>(-1.0,-1.0),\rvec2<f32>(-1.0,3.0),\rvec2<f32>(3.0,-1.0)\r\n);\r\n\r\n\r\nstruct VertexOutput {\r@builtin(position)\rposition:vec4<f32>,\r\n\r@location(0)\rtexCoord:vec2<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn vertexMain(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput {\rvar output:VertexOutput;\routput.texCoord=pos[vertexIndex] * vec2<f32>(0.5,-0.5) + vec2<f32>(0.5);\routput.position=vec4<f32>(pos[vertexIndex],0.0,1.0);\rreturn output;\r\n}\r\n\r\n\r\n@group(0) @binding(0)\r\nvar imgSampler:sampler;\r\n\r\n@group(0) @binding(1)\r\nvar img:texture_2d<f32>;\r\n\r\n\r\n@fragment\r\nfn fragmentMain(@location(0) texCoord:vec2<f32>) -> @location(0) vec4<f32> {\rreturn textureSample(img,imgSampler,texCoord);\r\n}\r\n"}),this.#Ee=g.createBindGroupLayout("FRAGMENT_BIND_GROUP_LAYOUT_NAME_MIP_MAP",{entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]}),this.#wt=g.createGPUPipelineLayout("PIPELINE_DESCRIPTOR_FINAL_MIP_MAP",{bindGroupLayouts:[this.#Ee]})),x=m.createRenderPipeline({layout:this.#wt,vertex:{module:this.#Rt,entryPoint:"vertexMain"},fragment:{module:this.#Rt,entryPoint:"fragmentMain",targets:[{format:i}]}}),this.#Mt[i]=x),x}generateMipmap(i,m){const{gpuDevice:g}=this.#_,x=this.getMipmapPipeline(m.format);if("3d"==m.dimension||"1d"==m.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let _=i;const b=m.size[0],y=m.size[1],T=m.size[2]||1,w=m.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!w){const i={size:{width:Math.max(1,b>>>1),height:Math.max(1,y>>>1),depthOrArrayLayers:T},format:m.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:m.mipLevelCount-1};_=g.createTexture(i)}const P=g.createCommandEncoder({});for(let g=0;g<T;++g){let b=this.getTextureView(i,0,g),y=w?1:0;for(let i=1;i<m.mipLevelCount;++i){const i=this.getTextureView(_,y++,g),m=P.beginRenderPass({colorAttachments:[{view:i,clearValue:{r:0,g:0,b:0,a:0},loadOp:$n.CLEAR,storeOp:Hn.STORE}]}),T=this.getBindGroup(b);m.setPipeline(x),m.setBindGroup(0,T),m.draw(3,1,0,0),m.end(),b=i}}if(!w){const g={width:Math.max(1,b>>>1),height:Math.max(1,y>>>1),depthOrArrayLayers:T};for(let x=1;x<m.mipLevelCount;++x)P.copyTextureToTexture({texture:_,mipLevel:x-1},{texture:i,mipLevel:x},g),g.width=Math.max(1,g.width>>>1),g.height=Math.max(1,g.height>>>1)}return g.queue.submit([P.finish()]),w||(this.clearCaches(_),_.destroy()),i}}Object.freeze(MipmapGenerator);class ResourceState{table={};videoMemory=0;length=0;constructor(){}}var zn;Object.freeze(ResourceState),function(i){i.GPUShaderModule="GPUShaderModule",i.GPUBindGroupLayout="GPUBindGroupLayout",i.GPUPipelineLayout="GPUPipelineLayout"}(zn||(zn={}));class ResourceManager extends ResourceBase{static PRESET_GPUBindGroupLayout_System="PRESET_GPUBindGroupLayout_System";static PRESET_VERTEX_GPUBindGroupLayout_Instancing="PRESET_VERTEX_GPUBindGroupLayout_Instancing";static PRESET_VERTEX_GPUBindGroupLayout="PRESET_VERTEX_GPUBindGroupLayout";static PRESET_VERTEX_GPUBindGroupLayout_SKIN="PRESET_VERTEX_GPUBindGroupLayout_SKIN";#It=new ImmutableKeyMap([[zn.GPUShaderModule,new Map],[zn.GPUBindGroupLayout,new Map],[zn.GPUPipelineLayout,new Map]]);#Et=new ResourceState;#Lt=new ResourceState;#Bt=new ResourceState;#Dt=new ResourceState;#Ut=new ResourceState;#At=new ResourceState;#kt=new ResourceState;#Ot={};#Nt;#be;#Ft;#Gt;constructor(i){super(i),this.#Ft=new MipmapGenerator(i),this.#Vt()}get basicSampler(){return this.#Gt}get mipmapGenerator(){return this.#Ft}get cachedBufferState(){return this.#Ot}get emptyBitmapTextureView(){return this.#Nt}get emptyCubeTextureView(){return this.#be}get managedBitmapTextureState(){return this.#Et}get managedCubeTextureState(){return this.#Lt}get managedHDRTextureState(){return this.#Bt}get managedUniformBufferState(){return this.#Dt}get managedVertexBufferState(){return this.#Ut}get managedIndexBufferState(){return this.#At}get managedStorageBufferState(){return this.#kt}get resources(){return this.#It}createGPUShaderModule(i,m){return this.#$t(i,m,m=>this.#Ht(i,m),zn.GPUShaderModule)}getGPUShaderModule(i){return this.#zt(i,zn.GPUShaderModule)}deleteGPUShaderModule(i){this.#qt(i,zn.GPUShaderModule)}createBindGroupLayout(i,m){return this.#$t(i,m,m=>(m.label||(m.label=i),this.redGPUContext.gpuDevice.createBindGroupLayout(m)),zn.GPUBindGroupLayout)}getGPUBindGroupLayout(i){return this.#zt(i,zn.GPUBindGroupLayout)}deleteGPUBindGroupLayout(i){this.#qt(i,zn.GPUBindGroupLayout)}createGPUPipelineLayout(i,m){return this.#$t(i,m,m=>(m.label||(m.label=i),this.redGPUContext.gpuDevice.createPipelineLayout(m)),zn.GPUPipelineLayout)}getGPUPipelineLayout(i){return this.#zt(i,zn.GPUPipelineLayout)}deleteGPUPipelineLayout(i){this.#qt(i,zn.GPUPipelineLayout)}#Vt(){const{gpuDevice:i}=this.redGPUContext;{const m=i.createTexture({size:{width:1,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:"emptyBitmapTexture"});this.#Nt=m.createView({label:m.label});const g=new Uint8Array([0,0,0,0]);i.queue.writeTexture({texture:m},g,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});const x=i.createTexture({size:{width:1,height:1,depthOrArrayLayers:6},format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:"emptyCubeTexture"});this.#be=x.createView(CubeTexture.defaultViewDescriptor);const _=new Uint8Array([0,0,0,0]);for(let m=0;m<6;m++)i.queue.writeTexture({texture:x,origin:{x:0,y:0,z:m}},_,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});this.#Gt=new Sampler(this.redGPUContext)}this.createBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:5,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:7,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:8,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:9,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:10,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:11,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}},{binding:3,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}}]})}#Kt(i){return this.#It.get(i)}#Ht(i,m){const{code:g}=m,x=parseIncludeWGSL(g),_=this.redGPUContext.gpuDevice.createShaderModule({...m,code:x});return this.#Kt(zn.GPUShaderModule).set(i,_),_}#Wt(i,m){if(!i)throw new Error("Name is required");return this.#Kt(m)}#$t(i,m,g,x){const _=this.#Wt(i,x);if(_.has(i))return _.get(i);m.label||(m.label=i);const b=g(m);return _.set(i,b),b}#zt(i,m){return this.#Wt(i,m).get(i)}#qt(i,m){const g=this.#Wt(i,m);if(!g.has(i))throw new Error(`${m} with name ${i} doesn't exist.`);g.delete(i)}}Object.freeze(BitmapTexture);class ImmutableKeyMap extends Map{constructor(i=[]){super(),i?.forEach(([i,m])=>super.set(i,m))}set(i,m){if(this.has(i))throw new Error("Cannot change the value of an existing key");return super.set(i,m)}}const createMeshVertexUniformBuffers=(i,m=!1)=>{const{gpuRenderInfo:g,redGPUContext:x}=i,{resourceManager:_}=x,b=_.getGPUBindGroupLayout(m?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout),y=new ArrayBuffer(g.vertexUniformInfo.arrayBufferByteLength),T=new UniformBuffer(x,y,i.name);g.vertexBindGroupLayout=b,g.vertexUniformBuffer=T};class ABitmapBaseMaterial extends ABaseMaterial{__packingList;constructor(i,m,g,x){super(i,m,g,x)}updateTexture(i,m){i&&i.__removeDirtyPipelineListener(this.#Xt),m&&m.__addDirtyPipelineListener(this.#Xt),this.#Xt()}updateSampler(i,m){i&&i.__removeDirtyPipelineListener(this.#Xt),m&&m.__addDirtyPipelineListener(this.#Xt),this.#Xt()}#Xt=()=>{this.dirtyPipeline=!0;{let i=(this.__packingList||[]).length;for(;i--;)this.__packingList[i]()}this.gpuRenderInfo?.fragmentShaderModule?this._updateFragmentState():this.initGPURenderInfos()}}Object.freeze(ABitmapBaseMaterial);const qn=[{textureList:["baseColorTexture"],vec4List:[["baseColorFactor",[1,1,1,1]]]},{textureList:["normalTexture"]},{textureList:["metallicRoughnessTexture"],positiveNumberList:["metallicFactor","roughnessFactor"]},{textureList:["emissiveTexture"],vec3List:["emissiveFactor"]},{textureList:["occlusionTexture"],positiveNumberList:["occlusionStrength"]},{extensionName:"KHR_materials_clearcoat",textureList:["KHR_clearcoatTexture","KHR_clearcoatNormalTexture","KHR_clearcoatRoughnessTexture"],positiveNumberList:[["KHR_clearcoatFactor",0],["KHR_clearcoatRoughnessFactor",0],"KHR_clearcoatNormalScale"]},{extensionName:"KHR_materials_sheen",textureList:["KHR_sheenColorTexture","KHR_sheenRoughnessTexture"],positiveNumberList:[["KHR_sheenRoughnessFactor",0]],vec3List:[["KHR_sheenColorFactor",[0,0,0]]]},{extensionName:"KHR_materials_specular",textureList:["KHR_specularTexture","KHR_specularColorTexture"],positiveNumberList:["KHR_specularFactor"],vec3List:[["KHR_specularColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_transmission",textureList:["KHR_transmissionTexture"],positiveNumberList:[["KHR_transmissionFactor",0]]},{extensionName:"KHR_materials_volume",textureList:["KHR_thicknessTexture"],positiveNumberList:[["KHR_thicknessFactor",0],["KHR_attenuationDistance",1]],vec3List:[["KHR_attenuationColor",[1,1,1]]]},{extensionName:"KHR_materials_diffuse_transmission",textureList:["KHR_diffuseTransmissionTexture","KHR_diffuseTransmissionColorTexture"],positiveNumberList:[["KHR_diffuseTransmissionFactor",0]],vec3List:[["KHR_diffuseTransmissionColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_anisotropy",textureList:["KHR_anisotropyTexture"],positiveNumberList:[["KHR_anisotropyStrength",0],["KHR_anisotropyRotation",0]]},{extensionName:"KHR_materials_iridescence",textureList:["KHR_iridescenceTexture","KHR_iridescenceThicknessTexture"],positiveNumberList:[["KHR_iridescenceFactor",0],["KHR_iridescenceIor",1.3],["KHR_iridescenceThicknessMinimum",100],["KHR_iridescenceThicknessMaximum",400]]}],Kn=parseWGSL((i=>{const m=qn.map(i=>{const{textureList:m,positiveNumberList:g}=i,x=m?.map(i=>`use${i.charAt(0).toUpperCase()+i.slice(1)}:u32,${i}_texCoord_index:u32,use_${i}_KHR_texture_transform:u32,${i}_KHR_texture_transform_offset:vec2<f32>,${i}_KHR_texture_transform_scale:vec2<f32>,${i}_KHR_texture_transform_rotation:f32,`).join("");return[x].join("\n")}).join("");return i.replace(/#redgpu_include KHR_texture_transform/g,m)})("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcDirectionalShadowVisibility;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include normalFunctions;\r\n#redgpu_include drawPicking;\r\nstruct Uniforms {\ruseVertexColor:u32,\ruseCutOff:u32,\rcutOff:f32,\ralphaBlend:u32,\r\n\r\rdoubleSided:u32,\ruseVertexTangent:u32,\r\n\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n\r\rbaseColorFactor:vec4<f32>,\r\remissiveFactor:vec3<f32>,\remissiveStrength:f32,\r\rocclusionStrength:f32,\r\rmetallicFactor:f32,\rroughnessFactor:f32,\r\rnormalScale:f32,\r\n\r\r\ruseKHR_materials_unlit:u32,\r\rKHR_materials_ior:f32,\r\r\ruseKHR_materials_transmission:u32,\rKHR_transmissionFactor:f32,\r\n\r\ruseKHR_materials_diffuse_transmission:u32,\rKHR_diffuseTransmissionFactor:f32,\rKHR_diffuseTransmissionColorFactor:vec3<f32>,\r\n\r\rKHR_dispersion:f32,\r\ruseKHR_materials_volume:u32,\rKHR_thicknessFactor:f32,\rKHR_attenuationDistance:f32,\rKHR_attenuationColor:vec3<f32>,\r\n\r\ruseKHR_materials_specular:u32,\rKHR_specularFactor:f32,\rKHR_specularColorFactor:vec3<f32>,\r\n\r\ruseKHR_materials_anisotropy:u32,\rKHR_anisotropyStrength:f32,\rKHR_anisotropyRotation:f32,\r\n\r\ruseKHR_materials_iridescence:u32,\rKHR_iridescenceFactor:f32,\rKHR_iridescenceIor:f32,\rKHR_iridescenceThicknessMinimum:f32,\rKHR_iridescenceThicknessMaximum:f32,\r\n\r\ruseKHR_materials_sheen:u32,\rKHR_sheenColorFactor:vec3<f32>,\rKHR_sheenRoughnessFactor:f32,\r\n\r\ruseKHR_materials_clearcoat:u32,\rKHR_clearcoatFactor:f32,\rKHR_clearcoatRoughnessFactor:f32,\rKHR_clearcoatNormalScale:f32,\r\r#redgpu_include KHR_texture_transform\r\n\r\n};\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n\r\n\r\n@group(2) @binding(1) var baseColorTextureSampler:sampler;\r\n@group(2) @binding(2) var baseColorTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(3) var emissiveTextureSampler:sampler;\r\n@group(2) @binding(4) var emissiveTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(5) var normalTextureSampler:sampler;\r\n@group(2) @binding(6) var normalTexture:texture_2d<f32>;\r\n\r\n\r\n\r\n@group(2) @binding(7) var packedORMTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(8) var KHR_specularTextureSampler:sampler;\r\n@group(2) @binding(9) var KHR_specularTexture:texture_2d<f32>;\r\n@group(2) @binding(10) var KHR_specularColorTextureSampler:sampler;\r\n@group(2) @binding(11) var KHR_specularColorTexture:texture_2d<f32>;\r\n\r\n\r\n\r\n\r\n\r\n@group(2) @binding(12) var KHR_clearcoatNormalTexture:texture_2d<f32>;\r\n@group(2) @binding(13) var packedKHR_clearcoatTexture_transmission:texture_2d<f32>;\r\n\r\n\r\n\r\n@group(2) @binding(14) var packedKHR_diffuse_transmission:texture_2d<f32>;\r\n\r\n@group(2) @binding(15) var packedKHR_sheen:texture_2d<f32>;\r\n\r\n@group(2) @binding(16) var KHR_anisotropyTexture:texture_2d<f32>;\r\n\r\n@group(2) @binding(17) var packedKHR_iridescence:texture_2d<f32>;\r\n\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r\r@location(4) vertexColor_0:vec4<f32>,\r\r@location(5) vertexTangent:vec4<f32>,\r@location(6) shadowPos:vec3<f32>,\r@location(7) receiveShadow:f32,\r@location(8) pickingId:vec4<f32>,\r@location(9) ndcPosition:vec3<f32>,\r@location(10) localNodeScale:f32,\r@location(11) volumeScale:f32,\r\n}\r\n\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\rlet input_vertexNormal=(inputData.vertexNormal.xyz);\rlet input_vertexPosition=inputData.vertexPosition.xyz;\rlet input_vertexColor_0=inputData.vertexColor_0;\rlet input_vertexTangent=inputData.vertexTangent;\rlet input_ndcPosition=inputData.ndcPosition;\rlet input_uv=inputData.uv;\rlet input_uv1=inputData.uv1;\r\r\rlet u_ambientLight=systemUniforms.ambientLight;\rlet u_ambientLightColor=u_ambientLight.color;\rlet u_ambientLightIntensity=u_ambientLight.intensity;\r\n\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_shadowDepthTextureSize=systemUniforms.shadowDepthTextureSize;\rlet u_bias=systemUniforms.bias;\r\n\rlet u_useIblTexture=systemUniforms.useIblTexture==1u;\r\rlet receiveShadowYn=inputData.receiveShadow !=.0;\r\n\r\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\rlet u_opacity=uniforms.opacity;\rlet u_doubleSided=uniforms.doubleSided==1u;\rlet u_useCutOff=uniforms.useCutOff==1u;\rlet u_cutOff=uniforms.cutOff;\rlet u_useVertexColor=uniforms.useVertexColor==1u;\rlet u_useVertexTangent=uniforms.useVertexTangent==1u;\r\n\r\rlet u_baseColorFactor=uniforms.baseColorFactor;\rlet u_useBaseColorTexture=uniforms.useBaseColorTexture==1u;\r\n\r\rlet u_metallicFactor=uniforms.metallicFactor;\rlet u_roughnessFactor=uniforms.roughnessFactor;\rlet u_useMetallicRoughnessTexture=uniforms.useMetallicRoughnessTexture==1u;\r\n\r\rlet u_useNormalTexture=uniforms.useNormalTexture==1u;\rlet u_normalScale=uniforms.normalScale;\r\n\r\rlet u_useOcclusionTexture=uniforms.useOcclusionTexture==1u;\rlet u_occlusionStrength=uniforms.occlusionStrength;\r\n\r\rlet u_useEmissiveTexture=uniforms.useEmissiveTexture==1u;\rlet u_emissiveFactor=uniforms.emissiveFactor;\rlet u_emissiveStrength=uniforms.emissiveStrength;\r\n\r\rlet u_useKHR_materials_unlit=uniforms.useKHR_materials_unlit==1u;\rlet u_KHR_materials_ior=uniforms.KHR_materials_ior;\rlet u_KHR_dispersion=uniforms.KHR_dispersion;\r\n\r\r\rlet u_useKHR_materials_transmission=uniforms.useKHR_materials_transmission==1u;\rlet u_KHR_transmissionFactor=uniforms.KHR_transmissionFactor;\rlet u_useKHR_transmissionTexture=uniforms.useKHR_transmissionTexture==1u;\r\n\r\rvar u_useKHR_materials_volume=uniforms.useKHR_materials_volume==1u;\rvar u_KHR_thicknessFactor=uniforms.KHR_thicknessFactor;\rvar u_KHR_attenuationColor=uniforms.KHR_attenuationColor;\rvar u_KHR_attenuationDistance=uniforms.KHR_attenuationDistance;\rvar u_useKHR_thicknessTexture=uniforms.useKHR_thicknessTexture==1u;\r\n\r\rlet u_useKHR_materials_diffuse_transmission=uniforms.useKHR_materials_diffuse_transmission==1u;\rlet u_KHR_diffuseTransmissionFactor=uniforms.KHR_diffuseTransmissionFactor;\rlet u_KHR_diffuseTransmissionColorFactor=uniforms.KHR_diffuseTransmissionColorFactor;\rlet u_useKHR_diffuseTransmissionTexture=uniforms.useKHR_diffuseTransmissionTexture==1u;\rlet u_useKHR_diffuseTransmissionColorTexture=uniforms.useKHR_diffuseTransmissionColorTexture==1u;\r\n\r\rlet u_useKHR_materials_specular=uniforms.useKHR_materials_specular==1u;\rlet u_KHR_specularFactor=uniforms.KHR_specularFactor;\rlet u_KHR_specularColorFactor=uniforms.KHR_specularColorFactor;\rlet u_useKHR_specularTexture=uniforms.useKHR_specularTexture==1u;\rlet u_useKHR_specularColorTexture=uniforms.useKHR_specularColorTexture==1u;\r\n\r\rlet u_useKHR_materials_anisotropy=uniforms.useKHR_materials_anisotropy==1u;\rlet u_KHR_anisotropyStrength=uniforms.KHR_anisotropyStrength;\rlet u_KHR_anisotropyRotation=uniforms.KHR_anisotropyRotation;\rlet u_useKHR_anisotropyTexture=uniforms.useKHR_anisotropyTexture==1u;\r\n\r\rlet u_useKHR_materials_sheen=uniforms.useKHR_materials_sheen==1u;\rlet u_useKHR_sheenColorTexture=uniforms.useKHR_sheenColorTexture==1u;\rlet u_useKHR_sheenRoughnessTexture=uniforms.useKHR_sheenRoughnessTexture==1u;\rlet u_KHR_sheenColorFactor=uniforms.KHR_sheenColorFactor;\rlet u_KHR_sheenRoughnessFactor=uniforms.KHR_sheenRoughnessFactor;\r\n\r\rlet u_useKHR_materials_iridescence=uniforms.useKHR_materials_iridescence==1u;\rlet u_useKHR_iridescenceTexture=uniforms.useKHR_iridescenceTexture==1u;\rlet u_useKHR_iridescenceThicknessTexture=uniforms.useKHR_iridescenceThicknessTexture==1u;\rlet u_KHR_iridescenceFactor=uniforms.KHR_iridescenceFactor;\rlet u_KHR_iridescenceIor=uniforms.KHR_iridescenceIor;\rlet u_KHR_iridescenceThicknessMinimum=uniforms.KHR_iridescenceThicknessMinimum;\rlet u_KHR_iridescenceThicknessMaximum=uniforms.KHR_iridescenceThicknessMaximum;\r\n\r\rlet u_useKHR_materials_clearcoat=uniforms.useKHR_materials_clearcoat==1u;\rlet u_KHR_clearcoatFactor=uniforms.KHR_clearcoatFactor;\rlet u_useKHR_clearcoatTexture=uniforms.useKHR_clearcoatTexture==1u;\rlet u_KHR_clearcoatRoughnessFactor=uniforms.KHR_clearcoatRoughnessFactor;\rlet u_useKHR_clearcoatRoughnessTexture=uniforms.useKHR_clearcoatRoughnessTexture==1u;\rlet u_useKHR_clearcoatNormalTexture=uniforms.useKHR_clearcoatNormalTexture==1u;\rlet u_KHR_clearcoatNormalScale=uniforms.KHR_clearcoatNormalScale;\r\n\r\n\r\r\n\r\rlet diffuseUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.baseColorTexture_texCoord_index,\runiforms.use_baseColorTexture_KHR_texture_transform,\runiforms.baseColorTexture_KHR_texture_transform_offset,\runiforms.baseColorTexture_KHR_texture_transform_rotation,\runiforms.baseColorTexture_KHR_texture_transform_scale\r);\r\n\rlet emissiveUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.emissiveTexture_texCoord_index,\runiforms.use_emissiveTexture_KHR_texture_transform,\runiforms.emissiveTexture_KHR_texture_transform_offset,\runiforms.emissiveTexture_KHR_texture_transform_rotation,\runiforms.emissiveTexture_KHR_texture_transform_scale\r);\r\n\rlet occlusionUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.occlusionTexture_texCoord_index,\runiforms.use_occlusionTexture_KHR_texture_transform,\runiforms.occlusionTexture_KHR_texture_transform_offset,\runiforms.occlusionTexture_KHR_texture_transform_rotation,\runiforms.occlusionTexture_KHR_texture_transform_scale\r);\r\n\rlet metallicRoughnessUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.metallicRoughnessTexture_texCoord_index,\runiforms.use_metallicRoughnessTexture_KHR_texture_transform,\runiforms.metallicRoughnessTexture_KHR_texture_transform_offset,\runiforms.metallicRoughnessTexture_KHR_texture_transform_rotation,\runiforms.metallicRoughnessTexture_KHR_texture_transform_scale\r);\r\n\rlet normalUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.normalTexture_texCoord_index,\runiforms.use_normalTexture_KHR_texture_transform,\runiforms.normalTexture_KHR_texture_transform_offset,\runiforms.normalTexture_KHR_texture_transform_rotation,\runiforms.normalTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_clearcoatUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_clearcoatTexture_texCoord_index,\runiforms.use_KHR_clearcoatTexture_KHR_texture_transform,\runiforms.KHR_clearcoatTexture_KHR_texture_transform_offset,\runiforms.KHR_clearcoatTexture_KHR_texture_transform_rotation,\runiforms.KHR_clearcoatTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_clearcoatNormalUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_clearcoatNormalTexture_texCoord_index,\runiforms.use_KHR_clearcoatNormalTexture_KHR_texture_transform,\runiforms.KHR_clearcoatNormalTexture_KHR_texture_transform_offset,\runiforms.KHR_clearcoatNormalTexture_KHR_texture_transform_rotation,\runiforms.KHR_clearcoatNormalTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_clearcoatRoughnessUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_clearcoatRoughnessTexture_texCoord_index,\runiforms.use_KHR_clearcoatRoughnessTexture_KHR_texture_transform,\runiforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_offset,\runiforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_rotation,\runiforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_sheenColorUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_sheenColorTexture_texCoord_index,\runiforms.use_KHR_sheenColorTexture_KHR_texture_transform,\runiforms.KHR_sheenColorTexture_KHR_texture_transform_offset,\runiforms.KHR_sheenColorTexture_KHR_texture_transform_rotation,\runiforms.KHR_sheenColorTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_sheenRoughnessUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_sheenRoughnessTexture_texCoord_index,\runiforms.use_KHR_sheenRoughnessTexture_KHR_texture_transform,\runiforms.KHR_sheenRoughnessTexture_KHR_texture_transform_offset,\runiforms.KHR_sheenRoughnessTexture_KHR_texture_transform_rotation,\runiforms.KHR_sheenRoughnessTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_specularTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_specularTexture_texCoord_index,\runiforms.use_KHR_specularTexture_KHR_texture_transform,\runiforms.KHR_specularTexture_KHR_texture_transform_offset,\runiforms.KHR_specularTexture_KHR_texture_transform_rotation,\runiforms.KHR_specularTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_specularColorTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_specularColorTexture_texCoord_index,\runiforms.use_KHR_specularColorTexture_KHR_texture_transform,\runiforms.KHR_specularColorTexture_KHR_texture_transform_offset,\runiforms.KHR_specularColorTexture_KHR_texture_transform_rotation,\runiforms.KHR_specularColorTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_iridescenceTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_iridescenceTexture_texCoord_index,\runiforms.use_KHR_iridescenceTexture_KHR_texture_transform,\runiforms.KHR_iridescenceTexture_KHR_texture_transform_offset,\runiforms.KHR_iridescenceTexture_KHR_texture_transform_rotation,\runiforms.KHR_iridescenceTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_iridescenceThicknessTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_iridescenceThicknessTexture_texCoord_index,\runiforms.use_KHR_iridescenceThicknessTexture_KHR_texture_transform,\runiforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_offset,\runiforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_rotation,\runiforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_transmissionUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_transmissionTexture_texCoord_index,\runiforms.use_KHR_transmissionTexture_KHR_texture_transform,\runiforms.KHR_transmissionTexture_KHR_texture_transform_offset,\runiforms.KHR_transmissionTexture_KHR_texture_transform_rotation,\runiforms.KHR_transmissionTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_diffuseTransmissionUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_diffuseTransmissionTexture_texCoord_index,\runiforms.use_KHR_diffuseTransmissionTexture_KHR_texture_transform,\runiforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_offset,\runiforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_rotation,\runiforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_diffuseTransmissionColorUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_diffuseTransmissionColorTexture_texCoord_index,\runiforms.use_KHR_diffuseTransmissionColorTexture_KHR_texture_transform,\runiforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_offset,\runiforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_rotation,\runiforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_anisotropyUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_anisotropyTexture_texCoord_index,\runiforms.use_KHR_anisotropyTexture_KHR_texture_transform,\runiforms.KHR_anisotropyTexture_KHR_texture_transform_offset,\runiforms.KHR_anisotropyTexture_KHR_texture_transform_rotation,\runiforms.KHR_anisotropyTexture_KHR_texture_transform_scale\r);\r\n\r\n\r\r\rvar N:vec3<f32>=normalize(input_vertexNormal.xyz);\rvar backFaceYn:bool=false;\rif(u_doubleSided) {\rvar fdx:vec3<f32>=dpdx(input_vertexPosition);\rvar fdy:vec3<f32>=dpdy(input_vertexPosition);\rvar faceNormal:vec3<f32>=normalize(cross(fdy,fdx));\rif (dot(N,faceNormal) < 0.0) {\rN=-N;\rbackFaceYn=true;\r};\r}\rlet N2=N;\rif(u_useNormalTexture){\rvar targetUv=select(normalUV,1.0 - normalUV,backFaceYn);\rlet normalSamplerColor=textureSample(normalTexture,normalTextureSampler,normalUV).rgb;\rN=perturb_normal(\rN,\rinput_vertexPosition,\rtargetUv,\rvec3<f32>(normalSamplerColor.r,1.0 - normalSamplerColor.g,normalSamplerColor.b),\ru_normalScale\r);\rN=select(N,select(N,-N,backFaceYn),u_useVertexTangent);\r}else{\rN=N * u_normalScale;\r}\r\r\rlet V:vec3<f32>=normalize(u_cameraPosition - input_vertexPosition);\rlet NdotV=max(dot(N,V),0.04);\rlet VdotN=max(dot(V,N),0.0);\r\r\n\rvar visibility:f32=1.0;\rvisibility=calcDirectionalShadowVisibility(\rdirectionalShadowMap,\rdirectionalShadowMapSampler,\ru_shadowDepthTextureSize,\ru_bias,\rinputData.shadowPos\r);\r\n\rif(!receiveShadowYn){\rvisibility=1.0;\r}\r\r\n\r\rvar finalColor:vec4<f32>;\rvar ior:f32=u_KHR_materials_ior;\rvar baseColor=u_baseColorFactor;\rvar resultAlpha:f32=u_opacity * baseColor.a;\r\rbaseColor *=select(vec4<f32>(1.0),input_vertexColor_0,u_useVertexColor);\r\rif(u_useBaseColorTexture){\rlet diffuseSampleColor= (textureSample(baseColorTexture,baseColorTextureSampler,diffuseUV));\rbaseColor *=diffuseSampleColor;\rresultAlpha *=diffuseSampleColor.a;\r}\rlet albedo:vec3<f32>=baseColor.rgb;\r\n\r\rif(u_useKHR_materials_unlit){\rreturn baseColor;\r}\r\n\r\rvar occlusionParameter:f32=1;\rif(u_useOcclusionTexture){\rocclusionParameter=textureSample(packedORMTexture,packedTextureSampler,occlusionUV).r * u_occlusionStrength;\r}\r\n\r\rvar metallicParameter:f32=u_metallicFactor;\rvar roughnessParameter:f32=u_roughnessFactor;\rif (u_useMetallicRoughnessTexture) {\rlet metallicRoughnessSample=(textureSample(packedORMTexture,packedTextureSampler,metallicRoughnessUV));\rmetallicParameter=metallicRoughnessSample.b * metallicParameter;\rroughnessParameter=metallicRoughnessSample.g * roughnessParameter;\r}\rroughnessParameter=max(roughnessParameter,0.045);\rif (abs(ior - 1.0) < 0.0001) {\rroughnessParameter=0;\r}\r\n\r\rvar clearcoatParameter=u_KHR_clearcoatFactor;\rvar clearcoatRoughnessParameter=u_KHR_clearcoatRoughnessFactor;\rvar clearcoatNormal:vec3<f32>=N;\rif(u_useKHR_materials_clearcoat){\rif(clearcoatParameter==0.0){\r}else{\rif(u_useKHR_clearcoatTexture){\rlet clearcoatSample= textureSample(packedKHR_clearcoatTexture_transmission,packedTextureSampler,KHR_clearcoatUV);\rclearcoatParameter *=clearcoatSample.r;\r}\r\n\rif(u_useKHR_clearcoatRoughnessTexture){\rlet clearcoatRoughnesstSample= textureSample(packedKHR_clearcoatTexture_transmission,packedTextureSampler,KHR_clearcoatRoughnessUV);\rclearcoatRoughnessParameter *=clearcoatRoughnesstSample.g;\r}\r\n\rvar clearcoatNormalSampler= textureSample(KHR_clearcoatNormalTexture,baseColorTextureSampler,KHR_clearcoatNormalUV);\rif(u_useKHR_clearcoatNormalTexture){\rvar targetUv=KHR_clearcoatNormalUV;\rif(backFaceYn){\rtargetUv=1.0 - targetUv;\r}\rclearcoatNormal=clearcoatNormalSampler.rgb;\rclearcoatNormal=perturb_normal(\rN,\rinput_vertexPosition,\rtargetUv,\rclearcoatNormal,\ru_normalScale\r);\rif(u_useVertexTangent){\rif(backFaceYn ){ clearcoatNormal=-clearcoatNormal;}\r}\rclearcoatNormal=normalize(clearcoatNormal);\r}\r}\r}\r\n\r\rvar specularParameter=u_KHR_specularFactor;\rvar specularColor=u_KHR_specularColorFactor;\r\n\rif(u_useKHR_materials_specular){\rif(u_useKHR_specularColorTexture){\rlet specularColorTextureSample=textureSample(\rKHR_specularColorTexture,\rKHR_specularColorTextureSampler,\rKHR_specularColorTextureUV\r);\rspecularColor *=specularColorTextureSample.rgb;\r};\r\n\rif(u_useKHR_specularTexture){\rlet specularTextureSample=textureSample(\rKHR_specularTexture,\rKHR_specularTextureSampler,\rKHR_specularTextureUV\r);\rspecularParameter *=specularTextureSample.a;\r};\r}\r\rvar transmissionParameter:f32=u_KHR_transmissionFactor;\rif (u_useKHR_transmissionTexture) {\r\rlet transmissionSample:vec4<f32>=textureSample(\rpackedKHR_clearcoatTexture_transmission,\rpackedTextureSampler,\rKHR_transmissionUV\r);\rtransmissionParameter *=transmissionSample.b;\r}\r\rvar thicknessParameter:f32=u_KHR_thicknessFactor;\rif (u_useKHR_thicknessTexture) {\rlet thicknessSample:vec4<f32>=textureSample(\rpackedKHR_clearcoatTexture_transmission,\rpackedTextureSampler,\rKHR_transmissionUV\r);\rthicknessParameter *=thicknessSample.a;\r}\r\rvar diffuseTransmissionColor:vec3<f32>=u_KHR_diffuseTransmissionColorFactor;\rvar diffuseTransmissionParameter:f32=u_KHR_diffuseTransmissionFactor;\rif(u_useKHR_materials_diffuse_transmission){\rif(u_useKHR_diffuseTransmissionTexture){\rlet transmissionSample= textureSample(\rpackedKHR_diffuse_transmission,\rpackedTextureSampler,\rKHR_diffuseTransmissionUV\r);\rdiffuseTransmissionParameter *=transmissionSample.a;\r}\rif(u_useKHR_diffuseTransmissionColorTexture){\rlet transmissionSample= textureSample(\rpackedKHR_diffuse_transmission,\rpackedTextureSampler,\rKHR_diffuseTransmissionColorUV\r);\rdiffuseTransmissionColor *=transmissionSample.rgb;\r}\r}\r\n\r\rvar sheenColor=u_KHR_sheenColorFactor;\rvar sheenRoughnessParameter=u_KHR_sheenRoughnessFactor;\rif(u_useKHR_materials_sheen){\rif(u_useKHR_sheenColorTexture){\rlet sheenColorSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenColorUV));\rsheenColor *=sheenColorSample.rgb;\r}\rif(u_useKHR_sheenRoughnessTexture){\rlet sheenRoughnessSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenRoughnessUV));\rsheenRoughnessParameter *=sheenRoughnessSample.a;\r}\r}\r\rvar iridescenceParameter=u_KHR_iridescenceFactor;\rvar iridescenceThickness=u_KHR_iridescenceThicknessMaximum;\rif(u_useKHR_materials_iridescence){\rif (u_useKHR_iridescenceTexture) {\rlet iridescenceTextureSample:vec4<f32>=textureSample(\rpackedKHR_iridescence,\rpackedTextureSampler,\rKHR_iridescenceTextureUV\r);\riridescenceParameter *=iridescenceTextureSample.r;\r}\rif(u_useKHR_iridescenceThicknessTexture){\rlet iridescenceTextureSample:vec4<f32>=textureSample(\rpackedKHR_iridescence,\rpackedTextureSampler,\rKHR_iridescenceThicknessTextureUV\r);\riridescenceThickness= mix(u_KHR_iridescenceThicknessMinimum,u_KHR_iridescenceThicknessMaximum,iridescenceTextureSample.g);\r}\r}\r\rvar anisotropy:f32=u_KHR_anisotropyStrength;\rvar anisotropicT:vec3<f32>;\rvar anisotropicB:vec3<f32>;\r\n\rif (u_useKHR_materials_anisotropy) {\rvar anisotropicDirection:vec2<f32>=vec2<f32>(1.0,0.0);\rif(u_useKHR_anisotropyTexture){\rlet anisotropyTex=textureSample(KHR_anisotropyTexture,baseColorTextureSampler,KHR_anisotropyUV).rgb;\ranisotropicDirection=anisotropyTex.rg * 2.0 - vec2<f32>(1.0,1.0);\rvar anisotropyRotation:vec2<f32>;\rif(u_KHR_anisotropyRotation < 0.0001){\ranisotropyRotation=vec2<f32>(1.0,0.0);\r}else{\ranisotropyRotation=vec2<f32>( cos(u_KHR_anisotropyRotation),sin(u_KHR_anisotropyRotation) );\r}\r\n\rlet rotationMtx:mat2x2<f32>=mat2x2<f32>(\ranisotropyRotation.x,anisotropyRotation.y,\r-anisotropyRotation.y,anisotropyRotation.x\r);\r\n\ranisotropicDirection=rotationMtx * normalize(anisotropicDirection);\ranisotropy *=anisotropyTex.b;\r}\rvar T:vec3<f32>;\rvar B:vec3<f32>;\rif (u_useVertexTangent) {\rif (length(input_vertexTangent.xyz) > 0.0) {\rT=normalize(input_vertexTangent.xyz);\rB=normalize(cross(T,N) * input_vertexTangent.w);\r} else {\rT=vec3<f32>(1.0,0.0,0.0);\rB=normalize(cross(T,N) * 1.0);\r}\r} else {\rT=vec3<f32>(1.0,0.0,0.0);\rB=normalize(cross(T,N) * 1.0);\r}\r\rlet TBN:mat3x3<f32>=mat3x3<f32>(T,B,N);\ranisotropicT=normalize(TBN * vec3<f32>(anisotropicDirection,0.0));\ranisotropicB=normalize(cross(N,anisotropicT));\r}\r\n\r\rvar prePathBackground=vec3<f32>(0.0);\rif(u_useKHR_materials_transmission) {\rprePathBackground=calcPrePathBackground(\ru_useKHR_materials_volume,thicknessParameter * inputData.volumeScale,u_KHR_dispersion,u_KHR_attenuationDistance,u_KHR_attenuationColor,\rior,roughnessParameter,albedo,\rsystemUniforms.projectionCameraMatrix,input_vertexPosition,input_ndcPosition,\rV,N,\rrenderPath1ResultTexture,renderPath1ResultTextureSampler\r);\r}\r\rlet F0_dielectric:vec3<f32>= vec3(pow((1.0 - ior)/(1.0 + ior),2.0));\rlet F0_metal=baseColor.rgb;\rvar F0=mix(F0_dielectric,F0_metal,metallicParameter);\rif(u_useKHR_materials_iridescence){\rF0=mix(\riridescent_fresnel( 1.0,u_KHR_iridescenceIor,F0_dielectric,iridescenceThickness,iridescenceParameter,NdotV),\riridescent_fresnel( 1.0,u_KHR_iridescenceIor,F0_metal,iridescenceThickness,iridescenceParameter,NdotV),\rmetallicParameter\r);\r}\r\n\r\rvar totalDirectLighting=vec3<f32>(0.0);\rfor (var i=0u;i < u_directionalLightCount;i++) {\rtotalDirectLighting +=calcLight(\ru_directionalLights[i].color,u_directionalLights[i].intensity * visibility,\rN,V,-normalize(u_directionalLights[i].direction),\rVdotN,\rroughnessParameter,metallicParameter,albedo,\rF0,ior,\rprePathBackground,\rspecularColor,specularParameter,\ru_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor,\rtransmissionParameter,\rsheenColor,sheenRoughnessParameter,\ranisotropy,anisotropicT,anisotropicB,\rclearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal\r);\r}\r\n\r\r{\rlet clusterIndex=getClusterLightClusterIndex(inputData.position);\rlet lightOffset =clusterLightGroup.lights[clusterIndex].offset;\rlet lightCount:u32 =clusterLightGroup.lights[clusterIndex].count;\r\n\rfor (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) {\rlet i=clusterLightGroup.indices[lightOffset + lightIndex];\rlet targetLight=clusterLightList.lights[i];\rlet u_clusterLightPosition=targetLight.position;\rlet u_clusterLightRadius=targetLight.radius;\rlet u_isSpotLight=targetLight.isSpotLight;\r\n\rlet lightDistance=length(u_clusterLightPosition - input_vertexPosition);\r\n\r\n\rif (lightDistance > u_clusterLightRadius) {\rcontinue;\r}\r\n\rlet lightDir=normalize(u_clusterLightPosition - input_vertexPosition);\rlet attenuation=clamp(1.0 - (lightDistance * lightDistance)/(u_clusterLightRadius * u_clusterLightRadius),0.0,1.0);\r\n\r\n\rvar finalAttenuation=attenuation;\r\n\r\rif (u_isSpotLight > 0.0) {\rlet u_clusterLightDirection=normalize(vec3<f32>(\rtargetLight.directionX,\rtargetLight.directionY,\rtargetLight.directionZ\r));\rlet u_clusterLightInnerAngle=targetLight.innerCutoff;\rlet u_clusterLightOuterCutoff=targetLight.outerCutoff;\r\n\r\rlet lightToVertex=normalize(-lightDir);\rlet cosTheta=dot(lightToVertex,u_clusterLightDirection);\r\n\rlet cosOuter=cos(radians(u_clusterLightOuterCutoff));\rlet cosInner=cos(radians(u_clusterLightInnerAngle));\r\n\r\rif (cosTheta < cosOuter) {\rcontinue;\r}\r\n\r\rlet epsilon=cosInner - cosOuter;\rlet spotIntensity=clamp((cosTheta - cosOuter)/epsilon,0.0,1.0);\r\n\rfinalAttenuation *=spotIntensity;\r}\r\n\r\rtotalDirectLighting +=calcLight(\rtargetLight.color,targetLight.intensity * finalAttenuation,\rN,V,lightDir,\rVdotN,\rroughnessParameter,metallicParameter,albedo,\rF0,ior,\rprePathBackground,\rspecularColor,specularParameter,\ru_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor,\rtransmissionParameter,\rsheenColor,sheenRoughnessParameter,\ranisotropy,anisotropicT,anisotropicB,\rclearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal\r);\r}\r}\r\n\r\rif (u_useIblTexture) {\rlet R=normalize(reflect(-V,N));\rlet NdotV=max(dot(N,V),0.04);\rlet NdotV_fresnel=max(dot(N,V),0.04);\r\n\r\n\r\n\r\rlet F_IBL_dielectric=F0_dielectric + (vec3<f32>(1.0) - F0_dielectric) * pow(1.0 - NdotV_fresnel,5.0);\rlet F_IBL_metal=F0_metal + (vec3<f32>(1.0) - F0_metal) * pow(1.0 - NdotV_fresnel,5.0);\rvar F_IBL=F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - NdotV_fresnel,5.0);\rvar F_IBL_iridescence=F_IBL;\rvar F_metal_iridescent=vec3<f32>(1.0);\rif (iridescenceParameter > 0.0) {\r\rlet F_iridescent=iridescent_fresnel(\r1.0, \ru_KHR_iridescenceIor, \rF0_dielectric, \riridescenceThickness, \riridescenceParameter, \rNdotV \r);\rlet F_metal_iridescent=iridescent_fresnel(\r1.0, \ru_KHR_iridescenceIor, \rbaseColor.rgb, \riridescenceThickness, \riridescenceParameter, \rNdotV \r);\rF_IBL=mix(F_iridescent,F_metal_iridescent,metallicParameter);\r}\r\n\rlet K=(roughnessParameter + 1.0) * (roughnessParameter + 1.0)/8.0;\rlet G=NdotV/(NdotV * (1.0 - K) + K);\rlet a2=roughnessParameter * roughnessParameter;\rlet G_smith=NdotV/(NdotV * (1.0 - a2) + a2);\r\rlet iblMipmapCount:f32=f32(textureNumLevels(ibl_environmentTexture) - 1);\r\n\r\n\r\n\r\n\rlet mipLevel=pow(roughnessParameter,0.4) * iblMipmapCount;\r\n\r\n\r\n\r\rvar reflectedColor=textureSampleLevel(ibl_environmentTexture,iblTextureSampler,R,mipLevel).rgb;\r\n\r\rlet effectiveTransmission=transmissionParameter * (1.0 - metallicParameter);\r\n\r\n\rlet iblDiffuseColor=textureSampleLevel(ibl_irradianceTexture,iblTextureSampler,N,0).rgb;\rvar envIBL_DIFFUSE:vec3<f32>=albedo * iblDiffuseColor * (vec3<f32>(1.0) - F_IBL_dielectric);\r\n\r\rif (u_useKHR_materials_diffuse_transmission && diffuseTransmissionParameter > 0.0) {\r\rvar backScatteringColor=textureSampleLevel(ibl_environmentTexture,iblTextureSampler,-N,mipLevel).rgb;\rlet transmittedIBL=backScatteringColor * diffuseTransmissionColor * (vec3<f32>(1.0) - F_IBL);\r\renvIBL_DIFFUSE=mix(envIBL_DIFFUSE,transmittedIBL,diffuseTransmissionParameter);\r}\r\n\r\rvar envIBL_SPECULAR:vec3<f32>;\rlet specularColorCorrected=max(vec3<f32>(0.16),specularColor);\rif (u_useKHR_materials_anisotropy) {\rvar bentNormal=cross(anisotropicB,V);\rbentNormal=normalize(cross(bentNormal,anisotropicB));\rlet temp=1.0 - anisotropy * (1.0 - roughnessParameter);\rlet tempSquared=temp * temp;\rvar a=tempSquared * tempSquared;\rbentNormal=normalize(mix(bentNormal,N,a));\rvar reflectVec=reflect(-V,bentNormal);\rreflectVec=normalize(mix(reflectVec,bentNormal,roughnessParameter * roughnessParameter));\r\n\rlet roughnessT=roughnessParameter * (1.0 + anisotropy);\rlet roughnessB=roughnessParameter * (1.0 - anisotropy);\r\n\rlet TdotR=dot(anisotropicT,reflectVec);\rlet BdotR=dot(anisotropicB,reflectVec);\r\n\rlet TdotV=dot(anisotropicT,V);\rlet BdotV=dot(anisotropicB,V);\r\n\rlet anisotropicR=normalize(reflectVec - anisotropy * (TdotR * anisotropicT - BdotR * anisotropicB));\r\n\rlet VdotN=max(0.04,dot(V,N));\rlet oneMinusVdotN=1.0 - VdotN;\rlet directionFactor=oneMinusVdotN * oneMinusVdotN * oneMinusVdotN;\r\n\rlet VdotT_abs=abs(TdotV);\rlet VdotB_abs=abs(BdotV);\rlet totalWeight=max(0.0001,VdotT_abs + VdotB_abs);\r\n\rlet weightedRoughness=(roughnessT * VdotT_abs + roughnessB * VdotB_abs)/totalWeight;\r\n\rlet anisotropyFactor=max(0.0,min(1.0,anisotropy));\rlet finalRoughness=mix( roughnessParameter,weightedRoughness,anisotropyFactor * directionFactor );\rlet anistropyMipmap=pow(finalRoughness,0.4) * iblMipmapCount;\rreflectedColor=textureSampleLevel( ibl_environmentTexture,iblTextureSampler,anisotropicR,anistropyMipmap ).rgb;\r\n\rlet a2=finalRoughness * finalRoughness;\rlet G_smith=NdotV/(NdotV * (1.0 - a2) + a2);\renvIBL_SPECULAR=reflectedColor * G_smith * specularColorCorrected * F_IBL * specularParameter;\r} else {\renvIBL_SPECULAR=reflectedColor * G_smith * specularColorCorrected * F_IBL * specularParameter;\r\n\r}\r\n\r\rvar envIBL_SPECULAR_BTDF=vec3<f32>(0.0);\rif (u_useKHR_materials_transmission) {\rvar refractedDir:vec3<f32>;\rlet eta=1.0/ior;\rif (abs(ior - 1.0) < 0.0001) {\rrefractedDir=V;\r} else {\rrefractedDir=refract(-V,-N,eta);\r}\r\n\rif(length(refractedDir) > 0.0001) {\rlet NdotT=abs(dot(N,normalize(refractedDir)));\rlet F_transmission=vec3<f32>(1.0) - F_IBL_dielectric;\r\n\rvar attenuatedBackground=prePathBackground;\rif (u_useKHR_materials_volume) {\rlet localNodeScale=inputData.localNodeScale;\rlet volumeScale=inputData.volumeScale;\r\n\rlet scaledThickness=thicknessParameter * localNodeScale;\r\rlet safeAttenuationColor=clamp(u_KHR_attenuationColor,vec3<f32>(0.0001),vec3<f32>(1.0));\rlet safeAttenuationDistance=max(u_KHR_attenuationDistance,0.0001);\r\n\r\rlet attenuationCoefficient=-log(safeAttenuationColor)/safeAttenuationDistance;\rlet cosTheta=max(NdotT,0.001);\rlet pathLength=scaledThickness/cosTheta;\rlet transmittance=exp(-attenuationCoefficient * pathLength);\rattenuatedBackground *=transmittance;\r}else{\rattenuatedBackground *=albedo;\r}\r\n\renvIBL_SPECULAR_BTDF=attenuatedBackground * F_transmission * transmissionParameter + reflectedColor * G_smith * F_IBL * NdotT;\r}\r}\r\n\r\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rlet envIBL_DIELECTRIC=envIBL_DIFFUSE * (1.0-transmissionParameter) + envIBL_SPECULAR_BTDF + envIBL_SPECULAR;\r\n\r\rvar envIBL_SHEEN=vec3<f32>(0.0);\rvar sheen_albedo_scaling:f32=1.0;\rlet maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z));\r\n\rif (u_useKHR_materials_sheen) {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rlet NdotV=max(dot(N,V),0.0001);\rlet sheenRoughnessAlpha=sheenRoughnessParameter * sheenRoughnessParameter;\r\rlet R=reflect(-V,N);\rlet sheenLobe=sheenRoughnessParameter * sheenRoughnessParameter;\rlet sheenSamplingDir=normalize(mix(R,N,sheenLobe));\r\n\rvar sheenMipLevel=log2(sheenRoughnessParameter) * 1.2 + iblMipmapCount - 1.0;\rsheenMipLevel=clamp(sheenMipLevel,0.0,iblMipmapCount - 1.0);\rlet sheenRadiance=textureSampleLevel(ibl_environmentTexture,iblTextureSampler,sheenSamplingDir,sheenMipLevel).rgb;\r\n\r\r\rlet F0=0.04;\rlet sheenFresnel=F0 + (1.0 - F0) * pow(1.0 - NdotV,5.0);\r\n\r\n\r\rlet E_VdotN=1.0 - pow(1.0 - NdotV,5.0);\rsheen_albedo_scaling=max(1.0 - maxSheenColor * E_VdotN,0.04);\r\n\renvIBL_SHEEN= sheenColor * sheenFresnel;\r\n\r}\r\n\r\rlet envIBL_METAL=select(reflectedColor * max(baseColor.rgb,vec3<f32>(0.04)),reflectedColor * F_IBL,iridescenceParameter>0.0);\r\n\r\n\r\rlet metallicPart=envIBL_METAL * metallicParameter * sheen_albedo_scaling;\rlet dielectricPart=envIBL_DIELECTRIC * (1.0 - metallicParameter);\rvar indirectLighting=metallicPart + dielectricPart + envIBL_SHEEN;\r\n\r\rif (clearcoatParameter > 0.0) {\r\rlet clearcoatR=reflect(-V,clearcoatNormal);\rlet clearcoatNdotV=max(dot(clearcoatNormal,V),0.04);\rlet clearcoatMipLevel=pow(clearcoatRoughnessParameter,0.4) * iblMipmapCount;\rlet clearcoatPrefilteredColor=textureSampleLevel(ibl_environmentTexture,iblTextureSampler,clearcoatR,clearcoatMipLevel).rgb;\rlet clearcoatF0=F0;\rlet clearcoatF=clearcoatF0 + (vec3<f32>(1.0) - clearcoatF0) * pow(1.0 - clearcoatNdotV,5.0);\rlet clearcoatK=(clearcoatRoughnessParameter + 1.0) * (clearcoatRoughnessParameter + 1.0)/8.0;\rlet clearcoatG=clearcoatNdotV/(clearcoatNdotV * (1.0 - clearcoatK) + clearcoatK);\rlet clearcoatBRDF=clearcoatF * clearcoatG;\rlet clearcoatSpecularIBL=clearcoatPrefilteredColor * clearcoatBRDF * clearcoatParameter;\rlet clearcoatFresnel=clearcoatF;\rindirectLighting=clearcoatSpecularIBL + (vec3<f32>(1.0) - clearcoatFresnel) * indirectLighting;\r}\r\n\r\rlet environmentIntensity=1.0;\rlet surfaceColor=totalDirectLighting + indirectLighting * environmentIntensity * occlusionParameter;\r\n\r\rfinalColor=vec4<f32>(surfaceColor,resultAlpha);\r\n\r} else {\r\rlet ambientContribution=albedo * u_ambientLightColor * u_ambientLightIntensity * occlusionParameter;\rfinalColor=vec4<f32>(totalDirectLighting + ambientContribution,resultAlpha);\r}\r\n\r\rif (u_useEmissiveTexture) {\rlet emissiveSamplerColor:vec4<f32>=(textureSample(emissiveTexture,emissiveTextureSampler,emissiveUV));\rfinalColor +=vec4<f32>( emissiveSamplerColor.rgb * u_emissiveFactor * u_emissiveStrength,0);\r} else {\rfinalColor +=(vec4<f32>(u_emissiveFactor * u_emissiveStrength,0));\r}\r\n\r\rfinalColor=linear_to_srgb(finalColor);\r\n\r\rif (u_useCutOff) {\rif (resultAlpha <=u_cutOff) {\rdiscard;\r}\r}\r\n\rreturn finalColor;\r\n};\r\nfn calcPrePathBackground(\ru_useKHR_materials_volume:bool,thicknessParameter:f32,u_KHR_dispersion:f32,u_KHR_attenuationDistance:f32,u_KHR_attenuationColor:vec3<f32>,\rior:f32,roughnessParameter:f32,albedo:vec3<f32>,\rprojectionCameraMatrix:mat4x4<f32>,input_vertexPosition:vec3<f32>,input_ndcPosition:vec3<f32>,\rV:vec3<f32>,N:vec3<f32>,\rrenderPath1ResultTexture:texture_2d<f32>,renderPath1ResultTextureSampler:sampler\r\n) -> vec3<f32> {\rvar prePathBackground=vec3<f32>(0.0);\rlet transmissionMipLevel:f32=roughnessParameter * f32(textureNumLevels(renderPath1ResultTexture) - 1);\r\n\rif(u_useKHR_materials_volume){\rvar iorR:f32=ior;\rvar iorG:f32=ior;\rvar iorB:f32=ior;\rif(u_KHR_dispersion>0.0){\rlet halfSpread:f32=(ior - 1.0) * 0.025 * u_KHR_dispersion;\riorR=ior + halfSpread;\riorG=ior;\riorB=ior - halfSpread;\r}\rlet refractedVecR:vec3<f32>=refract(-V,N,1.0/iorR);\rlet refractedVecG:vec3<f32>=refract(-V,N,1.0/iorG);\rlet refractedVecB:vec3<f32>=refract(-V,N,1.0/iorB);\r\n\r\rlet worldPosR:vec3<f32>=input_vertexPosition + refractedVecR * thicknessParameter;\rlet worldPosG:vec3<f32>=input_vertexPosition + refractedVecG * thicknessParameter;\rlet worldPosB:vec3<f32>=input_vertexPosition + refractedVecB * thicknessParameter;\r\n\r\rlet clipPosR:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosR,1.0);\rlet clipPosG:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosG,1.0);\rlet clipPosB:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosB,1.0);\r\n\rlet ndcR:vec2<f32>=clipPosR.xy/clipPosR.w * 0.5 + 0.5;\rlet ndcG:vec2<f32>=clipPosG.xy/clipPosG.w * 0.5 + 0.5;\rlet ndcB:vec2<f32>=clipPosB.xy/clipPosB.w * 0.5 + 0.5;\r\n\r\rlet finalUV_R:vec2<f32>=vec2<f32>(ndcR.x,1.0 - ndcR.y);\rlet finalUV_G:vec2<f32>=vec2<f32>(ndcG.x,1.0 - ndcG.y);\rlet finalUV_B:vec2<f32>=vec2<f32>(ndcB.x,1.0 - ndcB.y);\r\n\r\rprePathBackground.r=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_R,transmissionMipLevel).r;\rprePathBackground.g=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_G,transmissionMipLevel).g;\rprePathBackground.b=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_B,transmissionMipLevel).b;\r\n\r} else {\rlet refractedVec:vec3<f32>=refract(-V,N,1.0/ior);\rlet worldPos:vec3<f32>=input_vertexPosition + refractedVec * thicknessParameter;\rlet clipPos:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPos,1.0);\rlet ndc:vec2<f32>=clipPos.xy/clipPos.w * 0.5 + 0.5;\rlet finalUV:vec2<f32>=vec2<f32>(ndc.x,1.0 - ndc.y);\rprePathBackground=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV,transmissionMipLevel).rgb;\r}\r\rprePathBackground *=albedo;\rreturn prePathBackground;\r\n}\r\nfn calcLight(\rlightColor:vec3<f32>,lightIntensity:f32,\rN:vec3<f32>,V:vec3<f32>,L:vec3<f32>,\rVdotN:f32,\rroughnessParameter:f32,metallicParameter:f32,albedo:vec3<f32>,\rF0:vec3<f32>,ior:f32,\r\n\rprePathBackground:vec3<f32>,\rspecularColor:vec3<f32>,specularParameter:f32,\ru_useKHR_materials_diffuse_transmission:bool,diffuseTransmissionParameter:f32,diffuseTransmissionColor:vec3<f32>,\rtransmissionParameter:f32,\rsheenColor:vec3<f32>,sheenRoughnessParameter:f32,\ranisotropy:f32,anisotropicT:vec3<f32>,anisotropicB:vec3<f32>,\rclearcoatParameter:f32,clearcoatRoughnessParameter:f32,clearcoatNormal:vec3<f32>\r\n) -> vec3<f32>{\rlet dLight=lightColor * lightIntensity;\r\n\rlet NdotL=max(dot(N,L),0.04);\rlet NdotV=max(dot(N,V),0.04);\rlet H=normalize(L + V);\rlet LdotH=max(dot(L,H),0.0);\rlet NdotH=max(dot(N,H),0.0);\rlet VdotH=max(dot(V,H),0.0);\r\n\r\n\rvar DIFFUSE_BRDF:vec3<f32>=diffuse_brdf_disney(NdotL,NdotV,LdotH,roughnessParameter,albedo);\rif(u_useKHR_materials_diffuse_transmission && diffuseTransmissionParameter > 0.0){\rDIFFUSE_BRDF=mix(DIFFUSE_BRDF,diffuse_btdf(N,L,diffuseTransmissionColor),diffuseTransmissionParameter);\r}\r\n\rvar SPECULAR_BRDF:vec3<f32>;\rif (anisotropy > 0.0) {\rvar TdotL=dot(anisotropicT,L);\rvar TdotV=dot(anisotropicT,V);\rvar BdotL=dot(anisotropicB,L);\rvar TdotH=dot(anisotropicT,H);\rvar BdotH=dot(anisotropicB,H);\rvar BdotV=dot(anisotropicB,V);\rSPECULAR_BRDF= BRDF_specularAnisotropicGGX(\ralbedo,\rvec3<f32>(1.0),\rroughnessParameter * roughnessParameter,\rVdotH,NdotL,NdotV,NdotH,BdotV,TdotV,TdotL,BdotL,TdotH,BdotH,\ranisotropy\r);\r}else{\rSPECULAR_BRDF=specular_brdf( albedo,roughnessParameter,NdotH,NdotV,NdotL,LdotH);\r}\rlet METAL_BRDF=conductor_fresnel( albedo,SPECULAR_BRDF,VdotH);;\r\n\rlet transmissionWeight=transmissionParameter * (vec3<f32>(1.0) - F0);\rvar SPECULAR_BTDF= vec3<f32>(0.0);\rif(transmissionParameter > 0.0){\rSPECULAR_BTDF=specular_btdf( NdotV,NdotL,NdotH,VdotH,LdotH,roughnessParameter,albedo,ior);\r}\r\rlet DIELECTRIC_BRDF=fresnel_mix(\rF0,\rspecularParameter,\rmix(DIFFUSE_BRDF,SPECULAR_BTDF,transmissionParameter),\rSPECULAR_BRDF,\rVdotH\r);\r\n\r\n\rvar SHEEN_BRDF:vec3<f32>=vec3<f32>(0.0);\rvar sheen_albedo_scaling:f32=1.0;\rlet maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z));\rif(sheenRoughnessParameter > 0.0 && maxSheenColor > 0.001 && dot(N,V) > 0) {\rlet NdotV=dot(N,V);\rlet sheenRoughnessAlpha=sheenRoughnessParameter * sheenRoughnessParameter;\rlet invR=1/sheenRoughnessAlpha;\rlet cos2h=NdotH * NdotH;\rlet sin2h=1 - cos2h;\rlet sheenDistribution=(2 + invR) * pow(sin2h,invR * 0.5)/(2 * pi);\rlet sheen_visibility= 1.0/((1.0 + lambda_sheen(NdotV,sheenRoughnessAlpha) + lambda_sheen(NdotL,sheenRoughnessAlpha)) * (4.0 * NdotV * NdotL));\rlet LdotN=max(dot(L,N),0.04);\rlet E_LdotN=1.0 - pow(1.0 - LdotN,5.0);\rlet E_VdotN=1.0 - pow(1.0 - VdotN,5.0);\r\n\r\n\rsheen_albedo_scaling=max(min(1.0 - maxSheenColor * E_VdotN,1.0 - maxSheenColor * E_LdotN),0.04);\r\n\rSHEEN_BRDF=sheenColor * sheenDistribution * sheen_visibility;\r}\r\n\r\r\rlet metallicPart=METAL_BRDF * metallicParameter * sheen_albedo_scaling ;\rlet dielectricPart=DIELECTRIC_BRDF * sheen_albedo_scaling;\r\n\r\n\rlet sheenPart=SHEEN_BRDF;\rvar directLighting=(metallicPart + dielectricPart + sheenPart);\rif(transmissionParameter > 0.0) {\r\r\rdirectLighting=mix(directLighting,prePathBackground,transmissionWeight);\r}\r\rif(clearcoatParameter > 0.0){\rlet clearcoatNdotL=max(dot(clearcoatNormal,L),0.04);\rlet clearcoatNdotV=max(dot(clearcoatNormal,V),0.04);\rlet clearcoatNdotH=max(dot(clearcoatNormal,H),0.0);\rlet CLEARCOAT_BRDF=specular_brdf( F0,clearcoatRoughnessParameter,clearcoatNdotH,clearcoatNdotV,clearcoatNdotL,LdotH);\rdirectLighting=fresnel_coat(clearcoatNdotV,ior,clearcoatParameter,directLighting,CLEARCOAT_BRDF);\r}\rvar lightDirection:f32;\rif (u_useKHR_materials_diffuse_transmission && diffuseTransmissionParameter > 0.0) {\rlightDirection=mix(abs(dot(N,L)),1.0,diffuseTransmissionParameter);\r} else {\r\rlightDirection=NdotL;\r}\r\n\rlet lightContribution=directLighting * dLight * lightDirection;\r\rreturn lightContribution;\r\n}\r\nconst pi:f32=3.14159265359;\r\nfn BRDF_specularAnisotropicGGX( f0:vec3<f32>,f90:vec3<f32>,alphaRoughness:f32,VdotH:f32,NdotL:f32,NdotV:f32,NdotH:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,TdotH:f32,BdotH:f32,anisotropy:f32 ) -> vec3<f32> {\rvar at=mix(alphaRoughness,1.0,anisotropy * anisotropy);\rvar ab=alphaRoughness;\rvar F:vec3<f32>=fresnel_schlick(VdotH,f0);\rvar V:f32=V_GGX_anisotropic(NdotL,NdotV,BdotV,TdotV,TdotL,BdotL,at,ab);\rvar D:f32=D_GGX_anisotropic(NdotH,TdotH,BdotH,at,ab);\rreturn F * (V * D);\r\n}\r\nfn D_GGX_anisotropic( NdotH:f32,TdotH:f32,BdotH:f32,at:f32,ab:f32 ) -> f32 {\rlet a2:f32=at * ab;\rlet f:vec3<f32>=vec3<f32>(ab * TdotH,at * BdotH,a2 * NdotH);\rlet denominator:f32=dot(f,f);\r\n\r\n\r\n\rlet w2:f32=a2/denominator;\rreturn a2 * w2 * w2/pi;\r\n}\r\nfn V_GGX_anisotropic( NdotL:f32,NdotV:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,at:f32,ab:f32 ) -> f32 {\rlet GGXV=NdotL * length(vec3<f32>(at * TdotV,ab * BdotV,NdotV));\rlet GGXL=NdotV * length(vec3<f32>(at * TdotL,ab * BdotL,NdotL));\rlet v=0.5/(GGXV + GGXL);\rreturn clamp(v,0.0,1.0);\r\n}\r\nfn iridescent_fresnel(outside_ior:f32,iridescence_ior:f32,base_f0:vec3<f32>,\riridescence_thickness:f32,iridescence_factor:f32,cos_theta1:f32) -> vec3<f32> {\r\rif (iridescence_thickness <=0.0 || iridescence_factor <=0.0) {\rreturn base_f0;\r}\r\n\r\rlet cos_theta1_abs=abs(cos_theta1);\r\n\r\r\r\rlet min_ior=1.01;\rlet safe_iridescence_ior=max(iridescence_ior,min_ior);\r\n\r\rlet sin_theta1=sqrt(max(0.0,1.0 - cos_theta1_abs * cos_theta1_abs));\rlet sin_theta2=(outside_ior/safe_iridescence_ior) * sin_theta1;\r\n\r\rif (sin_theta2 >=1.0) {\rlet total_reflection=vec3<f32>(1.0);\rreturn base_f0 + iridescence_factor * (total_reflection - base_f0);\r\n\r}\r\n\rlet cos_theta2=sqrt(max(0.0,1.0 - sin_theta2 * sin_theta2));\r\n\r\rlet wavelengths=vec3<f32>(650.0,510.0,475.0);\r\n\r\r\rlet min_thickness=10.0;\rlet effective_thickness=max(iridescence_thickness,min_thickness);\r\n\r\r\rlet ior_scale=max(1.0,1.5 - 0.5 * (safe_iridescence_ior/1.5));\rlet optical_thickness=2.0 * effective_thickness * safe_iridescence_ior * cos_theta2 * ior_scale;\r\n\r\rlet phase=(2.0 * 3.14159265359 * optical_thickness)/wavelengths;\r\n\r\r\rlet r12_s=((outside_ior * cos_theta1_abs) - (safe_iridescence_ior * cos_theta2))/\r((outside_ior * cos_theta1_abs) + (safe_iridescence_ior * cos_theta2));\r\n\rlet r12_p=((safe_iridescence_ior * cos_theta1_abs) - (outside_ior * cos_theta2))/\r((safe_iridescence_ior * cos_theta1_abs) + (outside_ior * cos_theta2));\r\n\rlet t12_s=2.0 * outside_ior * cos_theta1_abs/\r((outside_ior * cos_theta1_abs) + (safe_iridescence_ior * cos_theta2));\r\n\rlet t12_p=2.0 * outside_ior * cos_theta1_abs/\r((safe_iridescence_ior * cos_theta1_abs) + (outside_ior * cos_theta2));\r\n\r\r\rlet n3=vec3<f32>(\r(1.0 + sqrt(clamp(base_f0.r,0.01,0.99)))/(1.0 - sqrt(clamp(base_f0.r,0.01,0.99))),\r(1.0 + sqrt(clamp(base_f0.g,0.01,0.99)))/(1.0 - sqrt(clamp(base_f0.g,0.01,0.99))),\r(1.0 + sqrt(clamp(base_f0.b,0.01,0.99)))/(1.0 - sqrt(clamp(base_f0.b,0.01,0.99)))\r);\r\n\r\rlet safe_n3=max(n3,vec3<f32>(1.2));\r\n\rlet r23_s=vec3<f32>(\r((safe_iridescence_ior * cos_theta2) - (safe_n3.r * cos_theta1_abs))/\r((safe_iridescence_ior * cos_theta2) + (safe_n3.r * cos_theta1_abs)),\r((safe_iridescence_ior * cos_theta2) - (safe_n3.g * cos_theta1_abs))/\r((safe_iridescence_ior * cos_theta2) + (safe_n3.g * cos_theta1_abs)),\r((safe_iridescence_ior * cos_theta2) - (safe_n3.b * cos_theta1_abs))/\r((safe_iridescence_ior * cos_theta2) + (safe_n3.b * cos_theta1_abs))\r);\r\n\rlet r23_p=vec3<f32>(\r((safe_n3.r * cos_theta2) - (safe_iridescence_ior * cos_theta1_abs))/\r((safe_n3.r * cos_theta2) + (safe_iridescence_ior * cos_theta1_abs)),\r((safe_n3.g * cos_theta2) - (safe_iridescence_ior * cos_theta1_abs))/\r((safe_n3.g * cos_theta2) + (safe_iridescence_ior * cos_theta1_abs)),\r((safe_n3.b * cos_theta2) - (safe_iridescence_ior * cos_theta1_abs))/\r((safe_n3.b * cos_theta2) + (safe_iridescence_ior * cos_theta1_abs))\r);\r\n\r\rlet cos_phase=vec3<f32>(cos(phase.r),cos(phase.g),cos(phase.b));\rlet sin_phase=vec3<f32>(sin(phase.r),sin(phase.g),sin(phase.b));\r\n\r\r\rlet numerator_s_real=vec3<f32>(\rr12_s + r23_s.r * cos_phase.r,\rr12_s + r23_s.g * cos_phase.g,\rr12_s + r23_s.b * cos_phase.b\r);\r\n\rlet numerator_s_imag=vec3<f32>(\rr23_s.r * sin_phase.r,\rr23_s.g * sin_phase.g,\rr23_s.b * sin_phase.b\r);\r\n\r\rlet denominator_s_real=vec3<f32>(\r1.0 + r12_s * r23_s.r * cos_phase.r,\r1.0 + r12_s * r23_s.g * cos_phase.g,\r1.0 + r12_s * r23_s.b * cos_phase.b\r);\r\n\rlet denominator_s_imag=vec3<f32>(\rr12_s * r23_s.r * sin_phase.r,\rr12_s * r23_s.g * sin_phase.g,\rr12_s * r23_s.b * sin_phase.b\r);\r\n\r\r\rlet denom_s_squared=vec3<f32>(\rdenominator_s_real.r * denominator_s_real.r + denominator_s_imag.r * denominator_s_imag.r,\rdenominator_s_real.g * denominator_s_real.g + denominator_s_imag.g * denominator_s_imag.g,\rdenominator_s_real.b * denominator_s_real.b + denominator_s_imag.b * denominator_s_imag.b\r);\r\n\r\rlet epsilon=0.001;\r\n\r\rlet r_s_real=vec3<f32>(\r(numerator_s_real.r * denominator_s_real.r + numerator_s_imag.r * denominator_s_imag.r)/\r(denom_s_squared.r + epsilon),\r(numerator_s_real.g * denominator_s_real.g + numerator_s_imag.g * denominator_s_imag.g)/\r(denom_s_squared.g + epsilon),\r(numerator_s_real.b * denominator_s_real.b + numerator_s_imag.b * denominator_s_imag.b)/\r(denom_s_squared.b + epsilon)\r);\r\n\r\rlet r_s_imag=vec3<f32>(\r(numerator_s_imag.r * denominator_s_real.r - numerator_s_real.r * denominator_s_imag.r)/\r(denom_s_squared.r + epsilon),\r(numerator_s_imag.g * denominator_s_real.g - numerator_s_real.g * denominator_s_imag.g)/\r(denom_s_squared.g + epsilon),\r(numerator_s_imag.b * denominator_s_real.b - numerator_s_real.b * denominator_s_imag.b)/\r(denom_s_squared.b + epsilon)\r);\r\n\r\r\rlet numerator_p_real=vec3<f32>(\rr12_p + r23_p.r * cos_phase.r,\rr12_p + r23_p.g * cos_phase.g,\rr12_p + r23_p.b * cos_phase.b\r);\r\n\rlet numerator_p_imag=vec3<f32>(\rr23_p.r * sin_phase.r,\rr23_p.g * sin_phase.g,\rr23_p.b * sin_phase.b\r);\r\n\r\rlet denominator_p_real=vec3<f32>(\r1.0 + r12_p * r23_p.r * cos_phase.r,\r1.0 + r12_p * r23_p.g * cos_phase.g,\r1.0 + r12_p * r23_p.b * cos_phase.b\r);\r\n\rlet denominator_p_imag=vec3<f32>(\rr12_p * r23_p.r * sin_phase.r,\rr12_p * r23_p.g * sin_phase.g,\rr12_p * r23_p.b * sin_phase.b\r);\r\n\r\rlet denom_p_squared=vec3<f32>(\rdenominator_p_real.r * denominator_p_real.r + denominator_p_imag.r * denominator_p_imag.r,\rdenominator_p_real.g * denominator_p_real.g + denominator_p_imag.g * denominator_p_imag.g,\rdenominator_p_real.b * denominator_p_real.b + denominator_p_imag.b * denominator_p_imag.b\r);\r\n\r\rlet r_p_real=vec3<f32>(\r(numerator_p_real.r * denominator_p_real.r + numerator_p_imag.r * denominator_p_imag.r)/\r(denom_p_squared.r + epsilon),\r(numerator_p_real.g * denominator_p_real.g + numerator_p_imag.g * denominator_p_imag.g)/\r(denom_p_squared.g + epsilon),\r(numerator_p_real.b * denominator_p_real.b + numerator_p_imag.b * denominator_p_imag.b)/\r(denom_p_squared.b + epsilon)\r);\r\n\r\rlet r_p_imag=vec3<f32>(\r(numerator_p_imag.r * denominator_p_real.r - numerator_p_real.r * denominator_p_imag.r)/\r(denom_p_squared.r + epsilon),\r(numerator_p_imag.g * denominator_p_real.g - numerator_p_real.g * denominator_p_imag.g)/\r(denom_p_squared.g + epsilon),\r(numerator_p_imag.b * denominator_p_real.b - numerator_p_real.b * denominator_p_imag.b)/\r(denom_p_squared.b + epsilon)\r);\r\n\r\rlet Rs=vec3<f32>(\rr_s_real.r * r_s_real.r + r_s_imag.r * r_s_imag.r,\rr_s_real.g * r_s_real.g + r_s_imag.g * r_s_imag.g,\rr_s_real.b * r_s_real.b + r_s_imag.b * r_s_imag.b\r);\r\n\rlet Rp=vec3<f32>(\rr_p_real.r * r_p_real.r + r_p_imag.r * r_p_imag.r,\rr_p_real.g * r_p_real.g + r_p_imag.g * r_p_imag.g,\rr_p_real.b * r_p_real.b + r_p_imag.b * r_p_imag.b\r);\r\n\r\rlet reflectance=0.5 * (Rs + Rp);\r\n\r\r\rlet ior_influence=smoothstep(1.0,2.0,safe_iridescence_ior);\rlet enhanced_reflectance=mix(\r\rpow(reflectance,vec3<f32>(0.8)) * 1.2,\r\rreflectance,\rior_influence\r);\r\n\r\rlet clamped_reflectance=clamp(enhanced_reflectance,vec3<f32>(0.0),vec3<f32>(1.0));\r\n\r\rreturn mix(base_f0,clamped_reflectance,iridescence_factor);\r\n}\r\nfn specular_btdf(\rNdotV:f32,\rNdotL:f32,\rNdotH:f32,\rVdotH:f32,\rLdotH:f32,\rroughness:f32,\rF0:vec3<f32>,\rior:f32\r\n) -> vec3<f32> {\rlet eta:f32=1.0/ior;\r\n\r\r\rlet D_rough:f32=distribution_ggx(NdotH,roughness * roughness);\r\n\r\r\rlet t:f32=clamp((ior - 1.0) * 100.0,0.0,1.0);\rlet D:f32=mix(1.0,D_rough,t);\r\n\r\rlet G:f32=min(1.0,min((2.0 * NdotH * NdotV)/VdotH,(2.0 * NdotH * NdotL)/VdotH));\r\n\r\rlet F:vec3<f32>=fresnel_schlick(VdotH,F0);\r\n\rlet denom:f32=(eta * VdotH + LdotH) * (eta * VdotH + LdotH);\r\n\r\rlet btdf:vec3<f32>=\r(vec3<f32>(1.0) - F) * \rabs(VdotH * LdotH) * \r(eta * eta) * \rD * \rG/ \r(NdotV * denom + 0.001);\r\n\rreturn btdf;\r\n}\r\n\r\nfn lambda_sheen_calc_l(x:f32,alpha_g:f32) -> f32 {\rlet one_minus_alpha_sq=(1.0 - alpha_g) * (1.0 - alpha_g);\r\n\rlet a=mix(21.5473,25.3245,one_minus_alpha_sq);\rlet b=mix(3.82987,3.32435,one_minus_alpha_sq);\rlet c=mix(0.19823,0.16801,one_minus_alpha_sq);\rlet d=mix(-1.97760,-1.27393,one_minus_alpha_sq);\rlet e=mix(-4.32054,-4.85967,one_minus_alpha_sq);\r\n\rreturn a/(1.0 + b * pow(x,c)) + d * x + e;\r\n}\r\nfn lambda_sheen(cos_theta:f32,alpha_g:f32) -> f32 {\rif (abs(cos_theta) < 0.5) {\rreturn exp(lambda_sheen_calc_l(cos_theta,alpha_g));\r} else {\rreturn exp(2.0 * lambda_sheen_calc_l(0.5,alpha_g) - lambda_sheen_calc_l(1.0 - cos_theta,alpha_g));\r}\r\n}\r\n\r\nfn fresnel_coat(NdotV:f32,ior:f32,weight:f32,base:vec3<f32>,layer:vec3<f32>) -> vec3<f32> {\rlet f0:f32=pow((1.0 - ior)/(1.0 + ior),2.0);\rlet fr:f32=f0 + (1.0 - f0) * pow(1.0 - abs(NdotV),5.0);\rreturn mix(base,layer,weight * fr);\r\n}\r\nfn conductor_fresnel(F0:vec3<f32>,bsdf:vec3<f32>,VdotH:f32) -> vec3<f32> {\rlet fresnel=F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - abs(VdotH),5.0);\rreturn bsdf * fresnel;\r\n}\r\nfn fresnel_mix(\rF0:vec3<f32>,\rweight:f32,\rbase:vec3<f32>,\rlayer:vec3<f32>,\rVdotH:f32\r\n) -> vec3<f32> {\rvar f0=F0;\rf0=min(f0,vec3<f32>(1.0));\rlet fr=f0 + (1.0 - f0) * pow(1.0 - abs(VdotH),5.0);\rreturn (1 - weight * max(max(fr.x,fr.y),fr.z)) * base + weight * fr * layer;\r\n}\r\nfn fresnel_mix_ibl(\rF0:vec3<f32>,\rweight:f32,\rbase:vec3<f32>,\rlayer:vec3<f32>,\rNdotV:f32\r\n) -> vec3<f32> {\rvar f0=F0;\rf0=min(f0,vec3<f32>(1.0));\r\rlet fr=f0 + (1.0 - f0) * pow(1.0 - max(NdotV,0.0),5.0);\r\n\r\rreturn base * (1.0 - fr * weight) + layer * fr * weight;\r\n}\r\n\r\nfn diffuse_brdf_disney(NdotL:f32,NdotV:f32,LdotH:f32,roughness:f32,albedo:vec3<f32>) -> vec3<f32> {\rif (NdotL <=0.0) { return vec3<f32>(0.0);}\r\n\r\rlet energyBias=mix(0.0,0.5,roughness);\rlet energyFactor=mix(1.0,1.0/1.51,roughness);\rlet fd90=energyBias + 2.0 * LdotH * LdotH * roughness;\rlet f0=1.0;\rlet lightScatter=f0 + (fd90 - f0) * pow(1.0 - NdotL,5.0);\rlet viewScatter=f0 + (fd90 - f0) * pow(1.0 - NdotV,5.0);\r\n\rreturn albedo * NdotL * lightScatter * viewScatter * energyFactor/pi;\r\n}\r\n\r\nfn diffuse_brdf(NdotL:f32,albedo:vec3<f32>) -> vec3<f32> {\rreturn albedo * NdotL/pi;\r\n}\r\nfn diffuse_btdf(N:vec3<f32>,L:vec3<f32>,Albedo:vec3<f32>) -> vec3<f32> {\r\rlet cos_theta=max(-dot(N,L),0.0);\rreturn Albedo * cos_theta/pi;\r\n}\r\n\r\nfn specular_brdf(\rF0:vec3<f32>,\rroughness:f32,\rNdotH:f32,\rNdotV:f32,\rNdotL:f32,\rLdotH:f32\r\n) -> vec3<f32> {\r\n\r\rlet D=distribution_ggx(NdotH,roughness);\r\n\r\rlet G=geometry_smith(NdotV,NdotL,roughness);\r\n\r\rlet F=fresnel_schlick(LdotH,F0);\r\n\r\rlet numerator=D * G * F;\rlet denominator=4.0 * NdotV * NdotL + 0.04;\r\n\rreturn (numerator/denominator);\r\n}\r\n\r\n\r\nfn distribution_ggx(NdotH:f32,roughness:f32) -> f32 {\rlet alpha=roughness * roughness;\rlet alpha2=alpha * alpha;\rlet NdotH2=NdotH * NdotH;\r\n\rlet nom=alpha2;\rlet denom=(NdotH2 * (alpha2 - 1.0) + 1.0);\rlet denom_squared=denom * denom;\r\n\rreturn nom/(denom_squared * 3.14159265359);\r\n}\r\n\r\n\r\nfn geometry_smith(NdotV:f32,NdotL:f32,roughness:f32) -> f32 {\rlet alpha=roughness * roughness;\rlet k=alpha/2.0; \r\n\rlet ggx1=NdotV/(NdotV * (1.0 - k) + k);\rlet ggx2=NdotL/(NdotL * (1.0 - k) + k);\r\n\rreturn ggx1 * ggx2;\r\n}\r\n\r\n\r\nfn fresnel_schlick(cosTheta:f32,F0:vec3<f32>) -> vec3<f32> {\rreturn F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - cosTheta,5.0);\r\n}\r\n\r\nfn get_transformed_uv(\rinput_uv:vec2<f32>,\rinput_uv1:vec2<f32>,\rtexCoord_index:u32,\ruse_transform:u32,\rtransform_offset:vec2<f32>,\rtransform_rotation:f32,\rtransform_scale:vec2<f32>\r\n) -> vec2<f32> {\r\rvar result_uv=select(input_uv,input_uv1,texCoord_index==1);\r\n\r\rif (use_transform==1) {\r\rlet translation=mat3x3<f32>(\r1.0,0.0,0.0,\r0.0,1.0,0.0,\rtransform_offset.x,transform_offset.y,1.0\r);\r\n\rlet cos_rot=cos(transform_rotation);\rlet sin_rot=sin(transform_rotation);\rlet rotation_matrix=mat3x3<f32>(\rcos_rot,-sin_rot,0.0,\rsin_rot,cos_rot,0.0,\r0.0,0.0,1.0\r);\r\n\rlet scale_matrix=mat3x3<f32>(\rtransform_scale.x,0.0,0.0,\r0.0,transform_scale.y,0.0,\r0.0,0.0,1.0\r);\r\n\rlet result_matrix=translation * rotation_matrix * scale_matrix;\rresult_uv=(result_matrix * vec3<f32>(result_uv,1.0)).xy;\r}\r\n\rreturn result_uv;\r\n}\r\n\r\nfn linear_to_srgb(linearColor:vec4<f32>) -> vec4<f32> {\rlet cutoff=vec4<f32>(0.0031308);\rlet higher=vec4<f32>(1.055) * pow(linearColor,vec4<f32>(1.0/2.4)) - vec4<f32>(0.055);\rlet lower=linearColor * vec4<f32>(12.92);\r\n\rreturn vec4<f32>(\rmix(higher.r,lower.r,step(linearColor.r,cutoff.r)),\rmix(higher.g,lower.g,step(linearColor.g,cutoff.g)),\rmix(higher.b,lower.b,step(linearColor.b,cutoff.b)),\rlinearColor.a \r);\r\n}\r\n"));class PBRMaterial extends ABitmapBaseMaterial{#jt;#Yt;#Zt;#Jt;#Qt;constructor(i){super(i,"PBR_MATERIAL",Kn,2),this.initGPURenderInfos(),this.#jt=new PackedTexture(i),this.#Qt=new PackedTexture(i),this.#Yt=new PackedTexture(i),this.#Zt=new PackedTexture(i),this.#Jt=new PackedTexture(i),this.__packingList=[()=>{this.setupPackORMTexture(),this.setupPackedKHR_clearcoatTexture_transmission(),this.setupPackedKHR_diffuse_transmission(),this.setupPackedKHR_sheen(),this.setupPackedKHR_iridescence()}]}get packedKHR_clearcoatTexture_transmission(){return this.#Qt}get packedKHR_iridescence(){return this.#Jt}get packedORMTexture(){return this.#jt}get packedKHR_sheen(){return this.#Zt}get packedKHR_diffuse_transmission(){return this.#Yt}async setupPackORMTexture(){const i=Math.max(this.occlusionTexture?.gpuTexture.width||1,this.metallicRoughnessTexture?.gpuTexture.width||1),m=Math.max(this.occlusionTexture?.gpuTexture.height||1,this.metallicRoughnessTexture?.gpuTexture.height||1);await this.#jt.packing({r:this.occlusionTexture?.gpuTexture,g:this.metallicRoughnessTexture?.gpuTexture,b:this.metallicRoughnessTexture?.gpuTexture},i,m,"packedORMTexture")}async setupPackedKHR_clearcoatTexture_transmission(){const i=Math.max(this.KHR_clearcoatTexture?.gpuTexture.width||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture.width||1),m=Math.max(this.KHR_clearcoatTexture?.gpuTexture.height||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture.height||1),g=Math.max(this.KHR_transmissionTexture?.gpuTexture.width||1,this.KHR_thicknessTexture?.gpuTexture.width||1),x=Math.max(this.KHR_transmissionTexture?.gpuTexture.height||1,this.KHR_thicknessTexture?.gpuTexture.height||1),_=Math.max(i,g),b=Math.max(m,x);await this.#Qt.packing({r:this.KHR_clearcoatTexture?.gpuTexture,g:this.KHR_clearcoatRoughnessTexture?.gpuTexture,b:this.KHR_transmissionTexture?.gpuTexture,a:this.KHR_thicknessTexture?.gpuTexture},_,b,"packedKHR_clearcoatTexture_transmission",{b:"r",a:"g"})}async setupPackedKHR_diffuse_transmission(){const i=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture.width||1,this.KHR_diffuseTransmissionTexture?.gpuTexture.width||1),m=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture.height||1,this.KHR_diffuseTransmissionTexture?.gpuTexture.height||1);await this.#Yt.packing({r:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,g:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,b:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,a:this.KHR_diffuseTransmissionTexture?.gpuTexture},i,m,"packedKHR_diffuse_transmission")}async setupPackedKHR_sheen(){const i=Math.max(this.KHR_sheenColorTexture?.gpuTexture.width||1,this.KHR_sheenRoughnessTexture?.gpuTexture.width||1),m=Math.max(this.KHR_sheenColorTexture?.gpuTexture.height||1,this.KHR_sheenRoughnessTexture?.gpuTexture.height||1);await this.#Zt.packing({r:this.KHR_sheenColorTexture?.gpuTexture,g:this.KHR_sheenColorTexture?.gpuTexture,b:this.KHR_sheenColorTexture?.gpuTexture,a:this.KHR_sheenRoughnessTexture?.gpuTexture},i,m,"packedKHR_sheen")}async setupPackedKHR_iridescence(){const i=Math.max(this.KHR_iridescenceTexture?.gpuTexture.width||1,this.KHR_iridescenceThicknessTexture?.gpuTexture.width||1),m=Math.max(this.KHR_iridescenceTexture?.gpuTexture.height||1,this.KHR_iridescenceThicknessTexture?.gpuTexture.height||1);await this.#Jt.packing({r:this.KHR_iridescenceTexture?.gpuTexture,g:this.KHR_iridescenceThicknessTexture?.gpuTexture},i,m,"packedKHR_iridescence")}}Br.defineByPreset(PBRMaterial,[Br.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,Br.PRESET_POSITIVE_NUMBER.NORMAL_SCALE]);qn.forEach(i=>{const{extensionName:m,textureList:g,useSampler:x}=i,{positiveNumberList:_,vec3List:b,vec4List:y}=i;m&&Br.defineBoolean(PBRMaterial,[`use${m}`]),((i,m)=>{i?.forEach(i=>{Br.defineBoolean(PBRMaterial,[`use_${i}`]),Br.definePositiveNumber(PBRMaterial,[[`${i}_KHR_texture_transform_rotation`,0]]),Br.defineBoolean(PBRMaterial,[`use_${i}_KHR_texture_transform`]),Br.defineVec2(PBRMaterial,[`${i}_KHR_texture_transform_offset`,[`${i}_KHR_texture_transform_scale`,[1,1]]]),Br.defineUint(PBRMaterial,[`${i}_texCoord_index`]),Br.defineTexture(PBRMaterial,[i]),m&&Br.defineSampler(PBRMaterial,[`${i}Sampler`])})})(g,!x),_?.forEach(i=>{Br.definePositiveNumber(PBRMaterial,[i])}),b?.forEach(i=>{Br.defineVec3(PBRMaterial,[i])}),y?.forEach(i=>{Br.defineVec4(PBRMaterial,[i])})}),Br.definePositiveNumber(PBRMaterial,[["cutOff",0],["KHR_materials_ior",1.5],["KHR_dispersion",0]]),Br.defineUint(PBRMaterial,["alphaBlend"]),Br.defineBoolean(PBRMaterial,["doubleSided","useCutOff","useVertexColor","useVertexTangent","useKHR_materials_unlit"]),Object.freeze(PBRMaterial);var Wn="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include drawDirectionalShadowDepth;\r\n#redgpu_include calcDisplacements;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t useDisplacementTexture:u32,\r\n\t displacementScale:f32,\r\n\t receiveShadow:f32,\rcombinedOpacity:f32,\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_resolution=systemUniforms.resolution;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\rlet u_displacementScale=vertexUniforms.displacementScale;\rlet u_useDisplacementTexture=vertexUniforms.useDisplacementTexture==1u;\rlet u_receiveShadow=vertexUniforms.receiveShadow;\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\rposition=u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_cameraPosition);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacedPosition=calcDisplacementPosition(input_position,input_vertexNormal,displacementTexture,displacementTextureSampler,u_displacementScale,input_uv,mipLevel);\rlet displacedNormal=calcDisplacementNormal(input_vertexNormal,displacementTexture,displacementTextureSampler,u_displacementScale,input_uv,mipLevel);\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\rnormalPosition=u_normalModelMatrix * vec4<f32>(displacedNormal,1.0);\r} else {\rnormalPosition=u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\r}\r\n\r\n\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\rvar posFromLight= u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0);\r\r\routput.shadowPos=vec3(\rposFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),\rposFromLight.z\r);\routput.receiveShadow=u_receiveShadow;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\r\n\r\n\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet input_position=inputData.position;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rvar position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n",Xn="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include drawDirectionalShadowDepth;\r\n#redgpu_include calcDisplacements;\r\nstruct VertexUniforms {\rpickingId:u32,\rlocalMatrix:mat4x4<f32>,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseDisplacementTexture:u32,\rdisplacementScale:f32,\rreceiveShadow:f32\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexWeight:vec4<f32>,\r@location(6) vertexJoint:vec4<f32>,\r@location(7) vertexTangent:vec4<f32>,\r\n};\r\n\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexTangent:vec4<f32>,\r@location(6) shadowPos:vec3<f32>,\r@location(7) receiveShadow:f32,\r@location(8) pickingId:vec4<f32>,\r@location(9) ndcPosition:vec3<f32>,\r@location(10) localNodeScale:f32,\r@location(11) volumeScale:f32,\r\n};\r\n@vertex\r\nfn main(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_localMatrix=vertexUniforms.localMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_receiveShadow=vertexUniforms.receiveShadow;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition= u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition= u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\r\n\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=inputData.uv;\routput.uv1=inputData.uv1;\routput.vertexColor_0=inputData.vertexColor_0;\routput.vertexTangent=u_normalModelMatrix * inputData.vertexTangent;\r\n\rlet viewDirection=normalize(position.xyz - u_cameraPosition);\r\n\r\n\rvar posFromLight= u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0);\r\r\routput.shadowPos=vec3(\rposFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),\rposFromLight.z\r);\routput.receiveShadow=u_receiveShadow;\routput.ndcPosition=output.position.xyz/output.position.w;\r\n\r\nlet nodeScaleX:f32=length(u_localMatrix[0].xyz);\r\nlet nodeScaleY:f32=length(u_localMatrix[1].xyz);\r\nlet nodeScaleZ=length(u_localMatrix[2].xyz);\r\noutput.localNodeScale=pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0);\r\n\r\nlet volumeScaleX:f32=length(u_modelMatrix[0].xyz);\r\nlet volumeScaleY:f32=length(u_modelMatrix[1].xyz);\r\nlet volumeScaleZ=length(u_modelMatrix[2].xyz);\r\noutput.volumeScale=pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0);\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet input_position=inputData.position;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rvar position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";class ResourceStateStorageBuffer{static dirtyList=[];buffer;uuid;#$=0;constructor(i){this.buffer=i,this.uuid=i.uuid}get useNum(){return this.#$}set useNum(i){this.#$=i,ResourceStateStorageBuffer.dirtyList.push(this)}}class StorageBuffer extends AUniformBaseBuffer{constructor(i,m,g="",x=""){super(i,"managedStorageBufferState",GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,m,g);const _=getCacheBufferFromResourceState(this,x);if(_)return _;x&&(this.name=x),basicRegisterResource(this,new ResourceStateStorageBuffer(this))}}Object.freeze(StorageBuffer);const getBasicMeshVertexBindGroupDescriptor=(i,m=!1)=>{const{redGPUContext:g,gpuRenderInfo:x,material:_}=i,{resourceManager:b}=g,{vertexUniformBuffer:y,vertexBindGroupLayout:T}=x,{basicSampler:w,emptyBitmapTextureView:P,emptyCubeTextureView:$}=b,{gpuSampler:H}=w;return{layout:T,label:m?"VERTEX_BIND_GROUP_DESCRIPTOR_MESH_SKIN":"VERTEX_BIND_GROUP_DESCRIPTOR_MESH",entries:m?[{binding:0,resource:{buffer:y.gpuBuffer,offset:0,size:y.size}},{binding:1,resource:getGPUResourceSampler(_?.displacementTextureSampler)||H},{binding:2,resource:getGPUResourceBitmapTextureView(_?.displacementTexture)||P},{binding:3,resource:{buffer:i.animationInfo.skinInfo.vertexStorageBuffer.gpuBuffer,offset:0,size:i.animationInfo.skinInfo.vertexStorageBuffer.size}}]:[{binding:0,resource:{buffer:y.gpuBuffer,offset:0,size:y.size}},{binding:1,resource:getGPUResourceSampler(_?.displacementTextureSampler)||H},{binding:2,resource:getGPUResourceBitmapTextureView(_?.displacementTexture)||P}]}},getGPUResourceBitmapTextureView=i=>i?.gpuTexture?.createView({label:i.src}),getGPUResourceSampler=i=>i?.gpuSampler,jn=parseWGSL(Xn),Yn=jn.uniforms.vertexUniforms,Zn=parseWGSL(Wn),Jn=Zn.uniforms.vertexUniforms,createMeshVertexShaderModule=i=>{const{material:m}=i;let g;return g=m instanceof PBRMaterial?i.animationInfo.skinInfo?((i,m)=>{const{redGPUContext:g,currentShaderModuleName:x}=m,{resourceManager:_}=g,{gpuRenderInfo:b}=m,y=`${m.animationInfo.skinInfo.joints.length}`,T=`${i}_${y}`,w="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcDisplacements;\r\nstruct VertexUniforms {\rpickingId:u32,\rlocalMatrix:mat4x4<f32>,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseDisplacementTexture:u32,\rdisplacementScale:f32,\rreceiveShadow:f32\r\n};\r\nstruct VertexStorages {\rjointMatrix:array<mat4x4<f32>,#JOINT_NUM>,\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n@group(1) @binding(3) var<storage,read> vertexStorages:VertexStorages;\r\nstruct InputDataSkin {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexWeight:vec4<f32>,\r@location(6) vertexJoint:vec4<f32>,\r@location(7) vertexTangent:vec4<f32>,\r\n};\r\nstruct OutputDataSkin {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexTangent:vec4<f32>,\r@location(6) shadowPos:vec3<f32>,\r@location(7) receiveShadow:f32,\r@location(8) pickingId:vec4<f32>,\r\n\r@location(9) ndcPosition:vec3<f32>,\r@location(10) localNodeScale:f32,\r@location(11) volumeScale:f32,\r\n};\r\n\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputDataSkin ) -> OutputDataSkin {\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\r\rlet u_localMatrix=vertexUniforms.localMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_receiveShadow=vertexUniforms.receiveShadow;\r\n\rvar output:OutputDataSkin;\rvar skinMat:mat4x4<f32>;\rlet vertexJoint:vec4<f32>=inputData.vertexJoint;\rlet vertexWeight:vec4<f32>=inputData.vertexWeight;\rlet jointMatrix=vertexStorages.jointMatrix;\rskinMat=vertexWeight.x * jointMatrix[ u32(vertexJoint.x) ]+\rvertexWeight.y * jointMatrix[ u32(vertexJoint.y) ]+\rvertexWeight.z * jointMatrix[ u32(vertexJoint.z) ]+\rvertexWeight.w * jointMatrix[ u32(vertexJoint.w) ];\r\n\r\n\rlet position= u_modelMatrix * skinMat * vec4<f32>(inputData.position,1.0);\rlet normalPosition= u_normalModelMatrix * skinMat * vec4<f32>(inputData.vertexNormal,1.0);\r\n\routput.position=u_projectionCameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=inputData.uv;\routput.uv1=inputData.uv1;\routput.vertexColor_0=inputData.vertexColor_0;\r\n\routput.vertexTangent=u_normalModelMatrix * inputData.vertexTangent;\r\n\rvar posFromLight= u_directionalLightProjectionViewMatrix * position;\r\r\routput.shadowPos=vec3<f32>(\rposFromLight.xy * vec2<f32>(0.5,-0.5) + vec2<f32>(0.5),\rposFromLight.z\r);\routput.receiveShadow=u_receiveShadow;\r\n\rlet nodeScaleX:f32=length(u_localMatrix[0].xyz);\rlet nodeScaleY:f32=length(u_localMatrix[1].xyz);\rlet nodeScaleZ:f32=length(u_localMatrix[2].xyz);\routput.localNodeScale=pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0);\r\n\rlet volumeScaleX:f32=length(u_modelMatrix[0].xyz);\rlet volumeScaleY:f32=length(u_modelMatrix[1].xyz);\rlet volumeScaleZ:f32=length(u_modelMatrix[2].xyz);\routput.volumeScale=pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0);\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputDataSkin ) -> OutputShadowData {\rvar output:OutputShadowData;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet input_position=inputData.position;\rvar position:vec4<f32>;\r\n\rvar skinMat:mat4x4<f32>=mat4x4<f32>(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);\rvar vertexJoint:vec4<f32>=inputData.vertexJoint;\rvar vertexWeight:vec4<f32>=inputData.vertexWeight;\rvar jointMatrix=vertexStorages.jointMatrix;\rskinMat=\r\n\rvertexWeight.x * jointMatrix[ u32(vertexJoint.x) ]+\rvertexWeight.y * jointMatrix[ u32(vertexJoint.y) ]+\rvertexWeight.z * jointMatrix[ u32(vertexJoint.z) ]+\rvertexWeight.w * jointMatrix[ u32(vertexJoint.w) ];\r\n\rposition= u_modelMatrix * skinMat * vec4<f32>(input_position,1.0);\routput.position=u_directionalLightProjectionViewMatrix * position;\rreturn output;\r\n}\r\n@vertex\r\nfn picking(inputData:InputDataSkin) -> OutputDataSkin {\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\rvar output:OutputDataSkin;\rvar skinMat:mat4x4<f32>=mat4x4<f32>(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);\rvar vertexJoint:vec4<f32>=inputData.vertexJoint;\rvar vertexWeight:vec4<f32>=inputData.vertexWeight;\rvar jointMatrix=vertexStorages.jointMatrix;\rskinMat=\r\n\rvertexWeight.x * jointMatrix[ u32(vertexJoint.x) ]+\rvertexWeight.y * jointMatrix[ u32(vertexJoint.y) ]+\rvertexWeight.z * jointMatrix[ u32(vertexJoint.z) ]+\rvertexWeight.w * jointMatrix[ u32(vertexJoint.w) ];\r\n\r\n\rvar position:vec4<f32>;\rposition= u_modelMatrix * skinMat * vec4<f32>(inputData.position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n",P={code:w};if(x===T)return _.getGPUShaderModule(T);if(P.code=w.replaceAll("#JOINT_NUM",y),b.vertexUniformInfo=parseWGSL(P.code).uniforms.vertexUniforms,m.animationInfo.skinInfo){createMeshVertexUniformBuffers(m,!0),m.animationInfo.skinInfo.vertexStorageInfo=parseWGSL(P.code).storage.vertexStorages;const i=new ArrayBuffer(m.animationInfo.skinInfo.vertexStorageInfo.arrayBufferByteLength);m.animationInfo.skinInfo.vertexStorageBuffer=new StorageBuffer(m.redGPUContext,i,m.name),b.vertexUniformBindGroup=g.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(m,!0))}else createMeshVertexUniformBuffers(m),b.vertexUniformBindGroup=g.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(m));return _.createGPUShaderModule(T,P)})("VERTEX_MODULE_MESH_PBR_SKIN",i):i.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_MESH_PBR",jn,Yn,Xn):i.createCustomMeshVertexShaderModule?i.createCustomMeshVertexShaderModule():i.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_MESH",Zn,Jn,Wn),i.currentShaderModuleName=g.label,g},Qn={NEVER:"never",LESS:"less",EQUAL:"equal",LESS_EQUAL:"less-equal",GREATER:"greater",NOT_EQUAL:"not-equal",GREATER_EQUAL:"greater-equal",ALWAYS:"always"};Object.freeze(Qn);const ei="shadow",ti="picking",createBasePipeline=(i,m,g,x)=>{const{redGPUContext:_}=i,{gpuDevice:b}=_,y=i.material.gpuRenderInfo;let T,w;switch(x){case ei:T="drawDirectionalShadowDepth",w=`${m.label}_shadow_pipelineDescriptor`;break;case ti:T="picking",w=`${m.label}_picking_pipelineDescriptor`;break;default:T="main",w=`${m.label}_pipelineDescriptor`}const P={module:m,entryPoint:T,buffers:i.vertexStateBuffers},$=[_.resourceManager.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),g];x!==ei&&$.push(y.fragmentBindGroupLayout);const H={bindGroupLayouts:$},z={label:w,layout:b.createPipelineLayout(H),vertex:P,primitive:i.primitiveState.state};switch(x){case ei:z.depthStencil={depthWriteEnabled:!0,depthCompare:Qn.LESS_EQUAL,format:"depth32float"};break;case ti:i.material&&(z.fragment={module:i.material.gpuRenderInfo.fragmentShaderModule,entryPoint:"picking",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},z.depthStencil=i.depthStencilState.state);break;default:z.fragment=y.fragmentState,z.depthStencil=i.depthStencilState.state,z.multisample={count:_.antialiasingManager.useMSAA?4:1}}return b.createRenderPipeline(z)},updateMeshDirtyPipeline=(i,m)=>{const{material:g,gpuRenderInfo:x,redGPUContext:_}=i,{resourceManager:b}=_;i.dirtyTransform=!0,g.dirtyPipeline&&g._updateFragmentState();const y=createMeshVertexShaderModule(i),T=b.getGPUBindGroupLayout(i.animationInfo.skinInfo?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout);x.vertexShaderModule=y,x.pipeline=createBasePipeline(i,y,T),x.shadowPipeline=i.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("drawDirectionalShadowDepth")?createBasePipeline(i,y,T,ei):null,x.pickingPipeline=i.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("picking")?createBasePipeline(i,y,T,ti):null;const{vertexUniformInfo:w}=i.gpuRenderInfo,{members:P}=w;for(const m in P)"pickingId"!==m&&(i[m]=i[m]);i.gpuRenderInfo.vertexUniformInfo.members.pickingId&&i.gpuRenderInfo.vertexUniformBuffer.writeBuffer(i.gpuRenderInfo.vertexUniformInfo.members.pickingId,i.pickingId),g.dirtyPipeline=!1,i.dirtyPipeline=!1,m&&m.numDirtyPipelines++},ri=Object.values(Qn);class DepthStencilState{state;#er;#re="depth32float";#tr=["r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm-srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm-srgb","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth24plus-stencil8","depth32float","depth32float-stencil8","bc1-rgba-unorm","bc1-rgba-unorm-srgb","bc2-rgba-unorm","bc2-rgba-unorm-srgb","bc3-rgba-unorm","bc3-rgba-unorm-srgb","bc4-r-unorm","bc4-r-snorm","bc5-rg-unorm","bc5-rg-snorm","bc6h-rgb-ufloat","bc6h-rgb-float","bc7-rgba-unorm","bc7-rgba-unorm-srgb","etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","eac-r11unorm","eac-r11snorm","eac-rg11unorm","eac-rg11snorm","astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"];#rr=!0;#nr=Qn.LESS_EQUAL;#ir;#ar;#sr;#or;#ur;#lr;#cr;constructor(i){this.#er=i,this.#V()}get format(){return this.#re}set format(i){this.#tr.includes(i)?(this.#re=i,this.#V()):consoleAndThrowError(`Invalid value for format. Received ${i}. Expected one of:${this.#tr.join(",")}`)}get depthWriteEnabled(){return this.#rr}set depthWriteEnabled(i){this.#rr=i,this.#V()}get depthCompare(){return this.#nr}set depthCompare(i){ri.includes(i)?(this.#nr=i,this.#V()):consoleAndThrowError(`Invalid value for depthCompare. Received ${i}. Expected one of:${ri.join(",")}`)}get stencilFront(){return this.#ir}set stencilFront(i){this.#ir=i,this.#V()}get stencilBack(){return this.#ar}set stencilBack(i){this.#ar=i,this.#V()}get stencilReadMask(){return this.#sr}set stencilReadMask(i){this.#sr=i,this.#V()}get stencilWriteMask(){return this.#or}set stencilWriteMask(i){this.#or=i,this.#V()}get depthBias(){return this.#ur}set depthBias(i){this.#ur=i,this.#V()}get depthBiasSlopeScale(){return this.#lr}set depthBiasSlopeScale(i){this.#lr=i,this.#V()}get depthBiasClamp(){return this.#cr}set depthBiasClamp(i){this.#cr=i,this.#V()}#V(){this.state={format:this.#re,depthWriteEnabled:this.#rr,depthCompare:this.#nr,stencilFront:this.#ir,stencilBack:this.#ar,stencilReadMask:this.#sr,stencilWriteMask:this.#or,depthBias:this.#ur,depthBiasSlopeScale:this.#lr,depthBiasClamp:this.#cr},this.#er.dirtyPipeline=!0}}const ni={NONE:"none",FRONT:"front",BACK:"back"};Object.freeze(ni);const ii={CW:"cw",CCW:"ccw"};Object.freeze(ii);const ai={UINT16:"uint16",UINT32:"uint32"};Object.freeze(ai);const si=Object.values(ai),oi=Object.values(ii),ui=Object.values(ni),li=["point-list","line-list","line-strip","triangle-list","triangle-strip"];class PrimitiveState{dirtyPipeline=!1;state;#er;#hr=yr.TRIANGLE_LIST;#fr;#dr=ii.CCW;#mr=ni.BACK;#pr=!1;constructor(i){this.#er=i,this.#V()}get topology(){return this.#hr}set topology(i){li.includes(i)?(this.#hr=i,this.#V()):consoleAndThrowError(`Invalid value for topology. Received ${i}. Expected one of:${li.join(",")}`)}get stripIndexFormat(){return this.#fr}set stripIndexFormat(i){si.includes(i)?(this.#fr=i,this.#V()):consoleAndThrowError(`Invalid value for stripIndexFormat. Received ${i}. Expected one of:${si.join(",")}`)}get frontFace(){return this.#dr}set frontFace(i){oi.includes(i)?(this.#dr=i,this.#V()):consoleAndThrowError(`Invalid value for frontFace. Received ${i}. Expected one of:${oi.join(",")}`)}get cullMode(){return this.#mr}set cullMode(i){ui.includes(i)?(this.#mr=i,this.#V()):consoleAndThrowError(`Invalid value for cullMode. Received ${i}. Expected one of:${ui.join(",")}`)}get unclippedDepth(){return this.#pr}set unclippedDepth(i){"boolean"==typeof i?(this.#pr=i,this.#V()):consoleAndThrowError(`Invalid type for unclippedDepth. Received ${typeof i}. Expected type:boolean.`)}#V(){this.state={topology:this.#hr,stripIndexFormat:this.#fr,frontFace:this.#dr,cullMode:this.#mr,unclippedDepth:this.#pr},this.#er.dirtyPipeline=!0}}class Object3DContainer{modelMatrix=create$5();#gr=[];constructor(){}get children(){return this.#gr}get numChildren(){return this.#gr.length}contains(i){return this.#xr(i),this.#gr.includes(i)}addChild(i){return this.#xr(i),this.#_r(i)?(this.#gr.push(i),i.dirtyTransform=!0,i):null}addChildAt(i,m){if(validateUintRange(m),this.#gr.length<m&&(m=this.#gr.length),!(m<0||m>this.#gr.length)&&this.#_r(i))return this.#gr.splice(m,0,i),i.dirtyTransform=!0,this}getChildAt(i){if(validateUintRange(i),!(i>=this.#gr.length||i<0))return this.#gr[i]}getChildIndex(i){this.#xr(i);const m=this.#gr.indexOf(i);return-1===m?-1:m}setChildIndex(i,m){this.#xr(i),validateUintRange(m);const g=this.#gr.length,x=m>=g,_=this.#gr.indexOf(i);-1!==_?x?consoleAndThrowError(`Invalid index. Index ${m} is out of bounds. Index should be between 0 and ${g-1}.`):(this.#gr.splice(_,1),this.#gr.splice(m,0,i)):consoleAndThrowError(`The provided is not a child of the Object3DContainer.:${i}`)}swapChildren(i,m){if(this.#xr(i),this.#xr(m),i===m)return void consoleAndThrowError("Error:child1 and child2 are the same. Cannot swap a child with itself.");const g=this.#gr.indexOf(i),x=this.#gr.indexOf(m);-1!==g&&-1!==x||consoleAndThrowError(`Error:${-1===g?"child1":"child2"} is not a child of this Object3DContainer.`),this.swapChildrenAt(g,x)}swapChildrenAt(i,m){validateUintRange(i),validateUintRange(m),i===m&&consoleAndThrowError("Error:index1 and index2 are identical. Cannot swap a child with itself.");const g=this.#gr.length;(i>=g||m>=g)&&consoleAndThrowError(`Error:Both index1 and index2 should be less than the number of children. Provided index1:${i},index2:${m},number of children:${g}`);let x=this.#gr[i];this.#gr[i]=this.#gr[m],this.#gr[m]=x}removeChild(i){this.#xr(i);const m=this.#gr.indexOf(i);if(m>-1)return i.parent=null,this.#gr.splice(m,1)[0];consoleAndThrowError("Error:Child not found within parent.")}removeChildAt(i){validateUintRange(i);const m=this.#gr[i];if(m)return m.parent=null,this.#gr.splice(i,1)[0];throw new Error(`Error:No child found at provided index:${i}.`)}removeAllChildren(){let i=this.#gr.length;for(;i--;)this.#gr[i].parent=null;return this.#gr.length=0,this}#xr(i){i instanceof Object3DContainer||consoleAndThrowError("allow only Object3DContainer instance.")}#_r=i=>(this.#xr(i),i.parent?!!i.parent?.removeChild(i)&&(i.parent=this,!0):(i.parent=this,!0))}class MeshBase extends Object3DContainer{gpuRenderInfo;animationInfo={skinInfo:null,morphInfo:null,animationsList:null};gltfLoaderInfo;dirtyPipeline=!0;dirtyTransform=!0;dirtyOpacity=!0;modelMatrix=create$5();localMatrix=create$5();normalModelMatrix=create$5();#_;#v;#vr;#br;#yr;#b=[];#x=createUUID();constructor(i){super(),validateRedGPUContext(i),this.#_=i,this.#v=i.gpuDevice,this.#vr=new PrimitiveState(this),this.#br=new DepthStencilState(this)}get uuid(){return this.#x}get currentShaderModuleName(){return this.#yr}set currentShaderModuleName(i){this.#yr=i}get primitiveState(){return this.#vr}get depthStencilState(){return this.#br}get gpuDevice(){return this.#v}get redGPUContext(){return this.#_}worldToLocal(i,m,g){return worldToLocal(this.modelMatrix,i,m,g)}localToWorld(i,m,g){return localToWorld(this.modelMatrix,i,m,g)}getScreenPoint(i){return getScreenPoint(i,this.modelMatrix)}__fireListenerList(i=!1){for(const i of this.#b)i(this);i&&(this.#b.length=0)}}const ci="VERTEX_MODULE_MESH_PBR_SKIN",hi=Math.PI/180,fi=3.141592653589793,di=6.283185307179586,mi=.225,pi=1.27323954,gi=.405284735,xi=1.5707963267948966;class Mesh extends MeshBase{displacementTexture;castShadow=!1;#e;#a;#Tr;#r=0;#i=0;#n=0;#Sr=[0,0,0];#wr=0;#Mr=0;#Rr=0;#Pr;#Cr=1;#Ir=1;#Er=1;#Lr=[1,1,1];#o=0;#u=0;#l=0;#Br=[0,0,0];#Dr={};#Ur=0;#Ar=!1;#kr=1;#Or;#Nr=!1;get enableDebugger(){return this.#Nr}get drawDebugger(){return this.#Or}set enableDebugger(i){this.#Nr=i,i&&!this.#Or&&(this.#Or=new DrawDebuggerMesh(this.redGPUContext,this))}constructor(i,m,g,x){super(i),x&&(this.name=x),this._geometry=m,this._material=g,this.#Pr=uuidToUint(this.uuid)}_material;get material(){return this._material}set material(i){this._material=i,this.dirtyPipeline=!0,"blendMode"in this&&(this.blendMode=this.blendMode)}_geometry;get geometry(){return this._geometry}set geometry(i){this._geometry=i,this.dirtyPipeline=!0,this.dirtyTransform=!0}get opacity(){return this.#kr}set opacity(i){validatePositiveNumberRange(i,0,1),this.#kr=i,this.dirtyOpacity=!0}get ignoreFrustumCulling(){return this.#Ar}set ignoreFrustumCulling(i){this.#Ar=i}get pickingId(){return this.#Pr}get events(){return this.#Dr}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get vertexStateBuffers(){return this._geometry.gpuRenderInfo.buffers}get parent(){return this.#Tr}set parent(i){this.#Tr=i}get pivotX(){return this.#wr}set pivotX(i){this.#wr=i,this.dirtyTransform=!0}get pivotY(){return this.#Mr}set pivotY(i){this.#Mr=i,this.dirtyTransform=!0}get pivotZ(){return this.#Rr}set pivotZ(i){this.#Rr=i,this.dirtyTransform=!0}get x(){return this.#r}set x(i){this.#r=this.#Sr[0]=i,this.dirtyTransform=!0}get y(){return this.#n}set y(i){this.#n=this.#Sr[1]=i,this.dirtyTransform=!0}get z(){return this.#i}set z(i){this.#i=this.#Sr[2]=i,this.dirtyTransform=!0}get position(){return this.#Sr}get scaleX(){return this.#Cr}set scaleX(i){this.#Cr=this.#Lr[0]=i,this.dirtyTransform=!0}get scaleY(){return this.#Ir}set scaleY(i){this.#Ir=this.#Lr[1]=i,this.dirtyTransform=!0}get scaleZ(){return this.#Er}set scaleZ(i){this.#Er=this.#Lr[2]=i,this.dirtyTransform=!0}get scale(){return this.#Sr}get rotationX(){return this.#o}set rotationX(i){this.#o=this.#Br[0]=i,this.dirtyTransform=!0}get rotationY(){return this.#u}set rotationY(i){this.#u=this.#Br[1]=i,this.dirtyTransform=!0}get rotationZ(){return this.#l}set rotationZ(i){this.#l=this.#Br[2]=i,this.dirtyTransform=!0}get rotation(){return this.#Br}get volumeOBB(){return this._geometry?calculateMeshOBB(this):null}get volumeAABB(){return this._geometry?calculateMeshAABB(this):null}setEnableDebuggerRecursively(i=!1){"enableDebugger"in this&&(this.enableDebugger=i),this.children&&this.children.forEach(m=>{m.setEnableDebuggerRecursively(i)})}setCastShadowRecursively(i=!1){"castShadow"in this&&(this.castShadow=i),this.children&&this.children.forEach(m=>{m.setCastShadowRecursively(i)})}setReceiveShadowRecursively(i=!1){"receiveShadow"in this&&(this.receiveShadow=i),this.children&&this.children.forEach(m=>{m.setReceiveShadowRecursively(i)})}getCombinedOpacity(){if(this.is2DMeshType){const i=this.parent;return this.#kr*(i?.getCombinedOpacity?i.getCombinedOpacity():1)}return 1}addListener(i,m){this.#Dr[i]=m,this.#Ur=Object.keys(this.#Dr).length}lookAt(i,m,g){var x,_=new Float32Array([0,1,0]),b=[];b[0]=i,b[1]=m,b[2]=g,identity$2(this.localMatrix),targetTo(this.localMatrix,[this.#r,this.#n,this.#i],b,_),x=mat4ToEuler(this.localMatrix,[]),this.rotationX=180*-x[0]/Math.PI,this.rotationY=180*-x[1]/Math.PI,this.rotationZ=180*-x[2]/Math.PI}setScale(i,m,g){m=m??i,g=g??i;const x=this.#Lr;this.#Cr=x[0]=i,this.#Ir=x[1]=m,this.#Er=x[2]=g,this.dirtyTransform=!0}setPosition(i,m,g){m=m??i,g=g??i;const x=this.#Sr;this.#r=x[0]=i,this.#n=x[1]=m,this.#i=x[2]=g,this.dirtyTransform=!0}setRotation(i,m,g){m=m??i,g=g??i;const x=this.#Br;this.#o=x[0]=i,this.#u=x[1]=m,this.#l=x[2]=g,this.dirtyTransform=!0}clone(){const i=new Mesh(this.redGPUContext,this._geometry,this._material);i.setPosition(this.#r,this.#n,this.#i),i.setRotation(this.#o,this.#u,this.#l),i.setScale(this.#Cr,this.#Ir,this.#Er);let m=this.children.length;for(;m--;)i.addChild(this.children[m].clone());return i}render(i){const{redGPUContext:m}=this,{view:g,isScene2DMode:x,currentRenderPassEncoder:_,timestamp:b,frustumPlanes:y,dirtyVertexUniformFromMaterial:T,useDistanceCulling:w,cullingDistanceSquared:P,distanceCulling:$}=i,{scene:H}=g,{shadowManager:z}=H,{directionalShadowManager:q}=z,{pickingManager:W}=g,{castingList:ye}=q,Ge=this._geometry,Ke=this._material,{uuid:Xe}=Ke||{};let je,Ye;if(x&&(this.#i=0,this.#Rr=0,this.depthStencilState.depthWriteEnabled&&(this.depthStencilState.depthWriteEnabled=!1)),this.dirtyTransform){je=!0;{const{pixelRectObject:i}=g,m=this.parent,_=this.localMatrix;let b,y,T,w,P,$,H,z,q,W,ye,Ge,Ke,Xe,je,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt,vt,bt,yt,Tt,St,wt,Mt,Rt,Pt,Ct,It,Et,Lt,Bt;if(_[12]=this.#r,_[13]=this.#n,_[14]=this.#i,_[15]=1,b=this.#o*hi,y=this.#u*hi,T=this.#l*hi,ft=1,gt=0,xt=0,bt=0,yt=1,Tt=0,wt=0,Mt=0,Rt=1,Bt=b%di,Bt<-fi?Bt+=di:Bt>fi&&(Bt-=di),Bt=Bt<0?pi*Bt+gi*Bt*Bt:pi*Bt-gi*Bt*Bt,w=Bt<0?mi*(Bt*-Bt-Bt)+Bt:mi*(Bt*Bt-Bt)+Bt,Bt=(b+xi)%di,Bt<-fi?Bt+=di:Bt>fi&&(Bt-=di),Bt=Bt<0?pi*Bt+gi*Bt*Bt:pi*Bt-gi*Bt*Bt,H=Bt<0?mi*(Bt*-Bt-Bt)+Bt:mi*(Bt*Bt-Bt)+Bt,Bt=y%di,Bt<-fi?Bt+=di:Bt>fi&&(Bt-=di),Bt=Bt<0?pi*Bt+gi*Bt*Bt:pi*Bt-gi*Bt*Bt,P=Bt<0?mi*(Bt*-Bt-Bt)+Bt:mi*(Bt*Bt-Bt)+Bt,Bt=(y+xi)%di,Bt<-fi?Bt+=di:Bt>fi&&(Bt-=di),Bt=Bt<0?pi*Bt+gi*Bt*Bt:pi*Bt-gi*Bt*Bt,z=Bt<0?mi*(Bt*-Bt-Bt)+Bt:mi*(Bt*Bt-Bt)+Bt,Bt=T%di,Bt<-fi?Bt+=di:Bt>fi&&(Bt-=di),Bt=Bt<0?pi*Bt+gi*Bt*Bt:pi*Bt-gi*Bt*Bt,$=Bt<0?mi*(Bt*-Bt-Bt)+Bt:mi*(Bt*Bt-Bt)+Bt,Bt=(T+xi)%di,Bt<-fi?Bt+=di:Bt>fi&&(Bt-=di),Bt=Bt<0?pi*Bt+gi*Bt*Bt:pi*Bt-gi*Bt*Bt,q=Bt<0?mi*(Bt*-Bt-Bt)+Bt:mi*(Bt*Bt-Bt)+Bt,Xe=z*q,je=w*P*q-H*$,Ye=H*P*q+w*$,Ze=z*$,Je=w*P*$+H*q,Qe=H*P*$-w*q,et=-P,at=w*z,ht=H*z,b=this.#Cr,y=this.#Ir,T=this.#Er,this.renderTextureWidth&&(b*=this.renderTextureWidth,y*=this.renderTextureHeight),_[0]=(ft*Xe+bt*je+wt*Ye)*b,_[1]=(gt*Xe+yt*je+Mt*Ye)*b,_[2]=(xt*Xe+Tt*je+Rt*Ye)*b,_[3]=_[3]*b,_[4]=(ft*Ze+bt*Je+wt*Qe)*y,_[5]=(gt*Ze+yt*Je+Mt*Qe)*y,_[6]=(xt*Ze+Tt*Je+Rt*Qe)*y,_[7]=_[7]*y,_[8]=(ft*et+bt*at+wt*ht)*T,_[9]=(gt*et+yt*at+Mt*ht)*T,_[10]=(xt*et+Tt*at+Rt*ht)*T,_[11]=_[11]*T,(this.#wr||this.#Mr||this.#Rr)&&(ft=_[0],gt=_[1],xt=_[2],vt=_[3],bt=_[4],yt=_[5],Tt=_[6],St=_[7],wt=_[8],Mt=_[9],Rt=_[10],Pt=_[11],Ct=_[12],It=_[13],Et=_[14],Lt=_[15],W=1,ye=0,Ge=0,Ke=0,_[0]=W*ft+ye*bt+Ge*wt+Ke*Ct,_[1]=W*gt+ye*yt+Ge*Mt+Ke*It,_[2]=W*xt+ye*Tt+Ge*Rt+Ke*Et,_[3]=W*vt+ye*St+Ge*Pt+Ke*Lt,W=0,ye=1,Ge=0,Ke=0,_[4]=W*ft+ye*bt+Ge*wt+Ke*Ct,_[5]=W*gt+ye*yt+Ge*Mt+Ke*It,_[6]=W*xt+ye*Tt+Ge*Rt+Ke*Et,_[7]=W*vt+ye*St+Ge*Pt+Ke*Lt,W=0,ye=0,Ge=1,Ke=0,_[8]=W*ft+ye*bt+Ge*wt+Ke*Ct,_[9]=W*gt+ye*yt+Ge*Mt+Ke*It,_[10]=W*xt+ye*Tt+Ge*Rt+Ke*Et,_[11]=W*vt+ye*St+Ge*Pt+Ke*Lt,x?m?.modelMatrix?(W=-this.#wr,ye=-this.#Mr,Ge=-this.#Rr,Ke=1):(W=-this.#wr/b,ye=-this.#Mr/y,Ge=-this.#Rr,Ke=1):(W=-this.#wr,ye=-this.#Mr,Ge=-this.#Rr,Ke=1),_[12]=W*ft+ye*bt+Ge*wt+Ke*Ct,_[13]=W*gt+ye*yt+Ge*Mt+Ke*It,_[14]=W*xt+ye*Tt+Ge*Rt+Ke*Et,_[15]=W*vt+ye*St+Ge*Pt+Ke*Lt),m?.modelMatrix){let i=m.modelMatrix,g=this.localMatrix,x=this.modelMatrix,_=i[0],b=i[1],y=i[2],T=i[3],w=i[4],P=i[5],$=i[6],H=i[7],z=i[8],q=i[9],W=i[10],ye=i[11],Ge=i[12],Ke=i[13],Xe=i[14],je=i[15],Ye=g[0],Ze=g[1],Je=g[2],Qe=g[3];x[0]=Ye*_+Ze*w+Je*z+Qe*Ge,x[1]=Ye*b+Ze*P+Je*q+Qe*Ke,x[2]=Ye*y+Ze*$+Je*W+Qe*Xe,x[3]=Ye*T+Ze*H+Je*ye+Qe*je,Ye=g[4],Ze=g[5],Je=g[6],Qe=g[7],x[4]=Ye*_+Ze*w+Je*z+Qe*Ge,x[5]=Ye*b+Ze*P+Je*q+Qe*Ke,x[6]=Ye*y+Ze*$+Je*W+Qe*Xe,x[7]=Ye*T+Ze*H+Je*ye+Qe*je,Ye=g[8],Ze=g[9],Je=g[10],Qe=g[11],x[8]=Ye*_+Ze*w+Je*z+Qe*Ge,x[9]=Ye*b+Ze*P+Je*q+Qe*Ke,x[10]=Ye*y+Ze*$+Je*W+Qe*Xe,x[11]=Ye*T+Ze*H+Je*ye+Qe*je,Ye=g[12],Ze=g[13],Je=g[14],Qe=g[15],x[12]=Ye*_+Ze*w+Je*z+Qe*Ge,x[13]=Ye*b+Ze*P+Je*q+Qe*Ke,x[14]=Ye*y+Ze*$+Je*W+Qe*Xe,x[15]=Ye*T+Ze*H+Je*ye+Qe*je}else{const{modelMatrix:i,localMatrix:m}=this;i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]}{let i=this.normalModelMatrix,m=this.modelMatrix,g=m[0],x=m[1],_=m[2],b=m[3],y=m[4],T=m[5],w=m[6],P=m[7],$=m[8],H=m[9],z=m[10],q=m[11],W=m[12],ye=m[13],Ge=m[14],Ke=m[15],Xe=g*T-x*y,je=g*w-_*y,Ye=g*P-b*y,Ze=x*w-_*T,Je=x*P-b*T,Qe=_*P-b*w,et=$*ye-H*W,at=$*Ge-z*W,ht=$*Ke-q*W,ft=z*Ke-q*Ge,gt=H*Ke-q*ye,xt=Xe*ft-je*gt+Ye*ft+Ze*ht-Je*at+Qe*et;xt=1/xt,i[0]=(T*ft-w*gt+P*ft)*xt,i[4]=(-x*ft+_*gt-b*ft)*xt,i[8]=(ye*Qe-Ge*Je+Ke*Ze)*xt,i[12]=(-H*Qe+z*Je-q*Ze)*xt,i[1]=(-y*ft+w*ht-P*at)*xt,i[5]=(g*ft-_*ht+b*at)*xt,i[9]=(-W*Qe+Ge*Ye-Ke*je)*xt,i[13]=($*Qe-z*Ye+q*je)*xt,i[2]=(y*gt-T*ht+P*et)*xt,i[6]=(-g*gt+x*ht-b*et)*xt,i[10]=(W*Je-ye*Ye+Ke*Xe)*xt,i[14]=(-$*Je+H*Ye-q*Xe)*xt,i[3]=(-y*ft+T*at-w*et)*xt,i[7]=(g*ft-x*at+_*et)*xt,i[11]=(-W*Ze+ye*je-Ge*Xe)*xt,i[15]=($*Ze-H*je+z*Xe)*xt}}}this.gltfLoaderInfo?.activeAnimations?.length&&((i,m)=>{let g,x,_,b,y,T,w,P,$,H,z,q,W,ye,Ge=m.length;for(;Ge--;)for(w=m[Ge],T=w.targetAniTrackList,y=T.length;y--;){P=T[y];const{animationTargetMesh:m,timeAnimationInfo:Ge,aniDataAnimationInfo:Ke,weightMeshes:Xe}=P;for(g=(i-w.startTime)%(1e3*T.maxTime)/1e3,z=Ge.dataList,q=Ke.dataList,W=z.length,ye=0,H=z.length-1,$=0,x=z[H],_=z[$];ye<W;ye++){const i=z[ye];if(i<g&&(H=ye,x=z[H],$=null==z[H+1]?0:H+1,_=z[$]),0==ye&&g<i){H=W-1,x=z[H],$=ye,_=z[$],g=i;break}if(ye==W-1&&g>i){H=0,x=z[H],$=W-1,_=z[$],g=i;break}}let je,Ye,Ze,Je,Qe,et,at;switch("CUBICSPLINE"==P.interpolation?(b=_-x,"NaN"==b.toString()&&(b=0),je=(g-x)/b,"NaN"==je.toString()&&(je=0),Ye=je*je,Ze=Ye*je,et=-2*Ze+3*Ye,at=Ze-Ye,Je=1-et,Qe=at-Ye+je):(b="STEP"==P.interpolation?0:(g-x)/(_-x),"NaN"==b.toString()&&(b=0)),P.key){case"rotation":gltfAnimationLooper_rotation(P.interpolation,m,q,W,b,H,$,Je,Qe,et,at);break;case"translation":gltfAnimationLooper_transition(P.interpolation,m,q,W,b,H,$,Je,Qe,et,at);break;case"scale":gltfAnimationLooper_scale(P.interpolation,m,q,W,b,H,$,Je,Qe,et,at);break;case"weights":gltfAnimationLooper_weight(Xe,q,b,H,$)}}})(b,this.gltfLoaderInfo.activeAnimations),this.animationInfo.skinInfo&&(this.currentShaderModuleName.includes(ci)||(this.dirtyPipeline=!0),this.currentShaderModuleName===`${ci}_${this.animationInfo.skinInfo.joints?.length}`&&(this.animationInfo.skinInfo.update(m,this),je=!1));let Ze=!0;if(w&&Ge){const{rawCamera:i}=g,m=i.x-this.#r,x=i.y-this.#n,_=i.z-this.#i,b=this.modelMatrix;Ge.volume.geometryRadius;b[0],b[5],b[10];const y=m*m;if(y>P)Ze=!1;else{const i=x*x;if(y+i>P)Ze=!1;else{y+i+_*_>P&&(Ze=!1)}}}if(y&&Ze)if(Ge){const i=this.modelMatrix,m=y[0],g=y[1],x=y[2],_=y[3],b=y[4],T=y[5],w=Ge.volume.geometryRadius,P=w*i[0],$=w*i[5],H=w*i[10],z=2*Math.max(w,P,$,H),q=i[12],W=i[13],ye=i[14];(m[0]*q+m[1]*W+m[2]*ye+m[3]<=-z||g[0]*q+g[1]*W+g[2]*ye+g[3]<=-z||x[0]*q+x[1]*W+x[2]*ye+x[3]<=-z||_[0]*q+_[1]*W+_[2]*ye+_[3]<=-z||b[0]*q+b[1]*W+b[2]*ye+b[3]<=-z||T[0]*q+T[1]*W+T[2]*ye+T[3]<=-z)&&(Ze=!1)}else Ze=!1;this.#Ar&&(Ze=!0),Ge?i.num3DObjects++:i.num3DGroups++;const{displacementTexture:Je,displacementScale:Qe}=Ke||{};(this.dirtyPipeline||Ke?.dirtyPipeline||T[Xe])&&(T[Xe]=!0);const{antialiasingManager:et,gpuDevice:at}=m;if(Ge&&(et.changedMSAA&&(this.dirtyPipeline=!0),this.gpuRenderInfo||this.initGPURenderInfos(),(this.dirtyPipeline||T[Xe])&&updateMeshDirtyPipeline(this,i)),Ge&&Ze){{const{gpuRenderInfo:i}=this,{vertexUniformBuffer:m,vertexUniformInfo:g,pipeline:x}=i,{members:_}=g;void 0!==_.displacementScale&&_.displacementScale!==Qe&&at.queue.writeBuffer(m.gpuBuffer,_.displacementScale.uniformOffset,new _.displacementScale.View([Qe])),void 0!==_.useDisplacementTexture&&_.useDisplacementTexture!==Je&&at.queue.writeBuffer(m.gpuBuffer,_.useDisplacementTexture.uniformOffset,new _.useDisplacementTexture.View([Je?1:0]))}const{gpuRenderInfo:m}=this,{vertexUniformBuffer:g,vertexUniformBindGroup:x,vertexUniformInfo:b,pipeline:y}=m,{members:T}=b;if(this.dirtyTransform&&(at.queue.writeBuffer(g.gpuBuffer,T.modelMatrix.uniformOffset,new T.modelMatrix.View(this.is2DMeshType?multiply$5(create$5(),this.modelMatrix,fromValues$5(this.width,0,0,0,0,this.height,0,0,0,0,1,0,0,0,0,1)):this.modelMatrix)),at.queue.writeBuffer(g.gpuBuffer,T.normalModelMatrix.uniformOffset,new T.normalModelMatrix.View(this.normalModelMatrix)),T.localMatrix&&at.queue.writeBuffer(g.gpuBuffer,T.localMatrix.uniformOffset,new T.localMatrix.View(this.localMatrix)),je=!0,this.dirtyTransform=!1),this.dirtyOpacity&&(Ye=!0,T.combinedOpacity&&at.queue.writeBuffer(g.gpuBuffer,T.combinedOpacity.uniformOffset,new T.combinedOpacity.View([this.getCombinedOpacity()])),this.dirtyOpacity=!1),Ke.use2PathRender)i.render2PathLayer[i.render2PathLayer.length]=this;else if("particle"===this.meshType)i.particleLayer[i.particleLayer.length]=this;else if("instanceMesh"===this.meshType)i.instanceMeshLayer[i.instanceMeshLayer.length]=this;else if(Ke.transparent)i.transparentLayer[i.transparentLayer.length]=this;else if(2===Ke.alphaBlend||Ke.opacity<1||!this.depthStencilState.depthWriteEnabled)i.alphaLayer[i.alphaLayer.length]=this;else{_.setPipeline(y);const{gpuBuffer:m}=Ge.vertexBuffer,{fragmentUniformBindGroup:g}=Ke.gpuRenderInfo;if(i.prevVertexGpuBuffer!==m&&(_.setVertexBuffer(0,m),i.prevVertexGpuBuffer=m),_.setBindGroup(1,x),i.prevFragmentUniformBindGroup!==g&&(_.setBindGroup(2,g),i.prevFragmentUniformBindGroup=g),i.numDrawCalls++,Ge.indexBuffer){const{indexBuffer:m}=Ge,{indexNum:g,triangleCount:x,gpuBuffer:b}=m;_.setIndexBuffer(b,"uint32"),this.particleBuffers?_.drawIndexed(g,this.particleNum,0,0,0):_.drawIndexed(g,1,0,0,0),i.numTriangles+=x,i.numPoints+=g}else{const{vertexBuffer:m}=Ge,{vertexCount:g,triangleCount:x}=m;_.draw(g,1,0,0),i.numTriangles+=x,i.numPoints+=g}}this.#Ur&&(W.castingList[W.castingList.length]=this)}(this.castShadow||this.castShadow&&!Ge)&&(ye[ye.length]=this),this.#Nr&&this.#Or.render(i);const{children:ht}=this;let ft=0;const gt=ht.length;for(;ft<gt;ft++)je&&(ht[ft].dirtyTransform=je),Ye&&(ht[ft].dirtyOpacity=Ye),ht[ft].render(i)}initGPURenderInfos(){this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null),updateMeshDirtyPipeline(this)}createMeshVertexShaderModuleBASIC(i,m,g,x){const{redGPUContext:_}=this,{resourceManager:b}=_,{gpuRenderInfo:y}=this,T={code:x};return y.vertexUniformInfo!==g&&(y.vertexUniformInfo=g,y.vertexStructInfo=m,createMeshVertexUniformBuffers(this)),y.vertexUniformBindGroup=_.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(this)),b.createGPUShaderModule(i,T)}}Object.defineProperty(Mesh.prototype,"meshType",{value:"mesh",writable:!1}),br.defineByPreset(Mesh,[br.PRESET_BOOLEAN.RECEIVE_SHADOW]),Object.freeze(Mesh);class AController{#Fr;constructor(){}get camera(){return this.#Fr}set camera(i){this.#Fr=i}update(i,m){}getCanvasEventPoint=(i,m)=>{const g=m.htmlCanvas,x=m.detector.isMobile,_=g.getBoundingClientRect(),b="clientX",y="clientY";let T,w;if(x){const m=i.changedTouches[0];T=m[b],w=m[y]}else{const m=i;T=m[b],w=m[y]}return{x:T-_.left,y:w-_.top}}}let _i,vi=create$5();const bi=create$5(),yi=create$4();const validateNumberRange=(i,m=0,g=Number.MAX_VALUE)=>("number"!=typeof i&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof m&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof g&&consoleAndThrowError("Only numbers allowed."),(i<m||i>g)&&consoleAndThrowError(`Only numbers within the range of [${m},${g}] are allowed. input:${i}`),!0);let Ti;var Si=Object.freeze({__proto__:null,BasicController:class extends AController{#Gr;#Vr={moveForward:"w",moveBack:"s",moveLeft:"a",moveRight:"d",moveUp:"t",moveDown:"g",turnLeft:"q",turnRight:"e",turnUp:"r",turnDown:"f"};#$r=1;#Hr=.1;#zr=1;#qr=.1;#Kr=3;#Wr=0;#Xr=[0,0,0];#jr=0;#Yr=0;#Zr;constructor(i){super(),this.#Zr=new Mesh(i),this.camera=new PerspectiveCamera;const m=i.detector.isMobile,g={move:m?"touchmove":"mousemove",up:m?"touchend":"mouseup",down:m?"touchstart":"mousedown"};let x,_;const checkArea=m=>{let g=this.#Gr;if(_i&&g===_i){let x,_,b=g.pixelRectObject;const{x:y,y:T}=this.getCanvasEventPoint(m,i);if(x=y*window.devicePixelRatio*i.renderScale,_=T*window.devicePixelRatio*i.renderScale,!(b.x<x&&x<b.x+b.width))return;if(!(b.y<_&&_<b.y+b.height))return}return!0};x=0,_=0;const HD_Move=m=>{const{x:g,y:b}=this.getCanvasEventPoint(m,i),y=g-x,T=b-_;x=g,_=b,this.#jr-=y*this.#zr*.1,this.#Yr-=T*this.#zr*.1},HD_up=()=>{_i=null,i.htmlCanvas.removeEventListener(g.move,HD_Move),window.removeEventListener(g.up,HD_up)};i.htmlCanvas.addEventListener(g.down,m=>{if(_i=this.#Gr,!checkArea(m))return;const{x:b,y:y}=this.getCanvasEventPoint(m,i);x=b,_=y,i.htmlCanvas.addEventListener(g.move,HD_Move),window.addEventListener(g.up,HD_up)})}get x(){return this.#Zr.x}set x(i){validateNumber(i),this.#Zr.x=i,this.#Xr[0]=i}get y(){return this.#Zr.y}set y(i){validateNumber(i),this.#Zr.y=i,this.#Xr[1]=i}get z(){return this.#Zr.z}set z(i){validateNumber(i),this.#Zr.z=i,this.#Xr[2]=i}get tilt(){return this.#Yr}set tilt(i){validateNumber(i),this.#Zr.rotationX=i,this.#Yr=i}get pan(){return this.#jr}set pan(i){validateNumber(i),this.#Zr.rotationY=i,this.#jr=i}get keyNameMapper(){return{...this.#Vr}}setMoveForwardKey(i){this.#Vr.moveForward=i}setMoveBackKey(i){this.#Vr.moveBack=i}setMoveLeftKey(i){this.#Vr.moveLeft=i}setMoveRightKey(i){this.#Vr.moveRight=i}setMoveUpKey(i){this.#Vr.moveUp=i}setMoveDownKey(i){this.#Vr.moveDown=i}setTurnLeftKey(i){this.#Vr.turnLeft=i}setTurnRightKey(i){this.#Vr.turnRight=i}setTurnUpKey(i){this.#Vr.turnUp=i}setTurnDownKey(i){this.#Vr.turnDown=i}update(i,m){this.#Gr=i;const g=this.#Hr,x=this.#qr,_=this.#Xr,b=this.#Zr;b.rotationY+=(this.#jr-b.rotationY)*x,b.rotationX+=(this.#Yr-b.rotationX)*x,this.#Jr(i)&&(vi=b.modelMatrix,identity$2(bi),rotateY$3(bi,bi,b.rotationY*Math.PI/180),rotateX$3(bi,bi,b.rotationX*Math.PI/180),translate$1(bi,bi,yi),identity$2(vi),translate$1(vi,vi,b.position),multiply$5(vi,vi,bi),_[0]=vi[12],_[1]=vi[13],_[2]=vi[14]),b.x+=(_[0]-b.x)*g,b.y+=(_[1]-b.y)*g,b.z+=(_[2]-b.z)*g,b.rotationY+=(this.#jr-b.rotationY)*x,b.rotationX+=(this.#Yr-b.rotationX)*x,vi=b.modelMatrix,identity$2(vi),translate$1(vi,vi,b.position),rotateY$3(vi,vi,b.rotationY*Math.PI/180),rotateX$3(vi,vi,b.rotationX*Math.PI/180);const y=clone$5(vi);translate$1(y,y,[0,0,.01]),this.camera.setPosition(y[12],y[13],y[14]),this.camera.lookAt(b.x,b.y,b.z)}#Jr(i){if(!i.checkMouseInViewBounds())return;const m=this.#$r,g=this.#zr,{keyboardKeyBuffer:x}=i.redGPUContext,_=this.#Vr;let b=!1,y=!1,T=0,w=0;yi[0]=0,yi[1]=0,yi[2]=0;const P=this.#Wr*m;return x[_.turnLeft]&&(y=!0,T=g),x[_.turnRight]&&(y=!0,T=-g),x[_.turnUp]&&(y=!0,w=g),x[_.turnDown]&&(y=!0,w=-g),x[_.moveForward]&&(b=!0,yi[2]=-P),x[_.moveBack]&&(b=!0,yi[2]=P),x[_.moveLeft]&&(b=!0,yi[0]=-P),x[_.moveRight]&&(b=!0,yi[0]=P),x[_.moveUp]&&(b=!0,yi[1]=P),x[_.moveDown]&&(b=!0,yi[1]=-P),y||b?(this.#Wr+=.1,this.#Wr>this.#Kr&&(this.#Wr=this.#Kr)):(this.#Wr+=-.1,this.#Wr<0&&(this.#Wr=0)),y&&(this.#jr+=T,this.#Yr+=w),b||y}},Camera2D:Camera2D,ObitController:class extends AController{#e;#a;#Qr=0;#en=0;#tn=0;#rn=15;#nn=2;#in=.1;#zr=3;#qr=.1;#an=-35;#sn=-90;#on=90;#un=0;#ln=0;#cn=0;#hn=0;#fn=new Set;#dn=-1;constructor(i){super(),this.camera=new PerspectiveCamera;const m=i.detector.isMobile,g={move:m?"touchmove":"mousemove",up:m?"touchend":"mouseup",down:m?"touchstart":"mousedown"};let x,_;const findTargetView=m=>{const{x:g,y:x}=this.getCanvasEventPoint(m,i);let _,b;_=g*window.devicePixelRatio*i.renderScale,b=x*window.devicePixelRatio*i.renderScale;for(const i of this.#fn){const m=i.pixelRectObject;if(m.x<_&&_<m.x+m.width&&m.y<b&&b<m.y+m.height)return i}return null};x=0,_=0;const HD_Move=m=>{if(!Ti)return;const{x:g,y:b}=this.getCanvasEventPoint(m,i),y=g-x,T=b-_;x=g,_=b,this.#un-=y*this.#zr*.1,this.#an-=T*this.#zr*.1},HD_up=()=>{Ti=null,i.htmlCanvas.removeEventListener(g.move,HD_Move),window.removeEventListener(g.up,HD_up)};i.htmlCanvas.addEventListener(g.down,m=>{const b=findTargetView(m);if(!b)return;Ti=b;const{x:y,y:T}=this.getCanvasEventPoint(m,i);x=y,_=T,i.htmlCanvas.addEventListener(g.move,HD_Move),window.addEventListener(g.up,HD_up)}),i.htmlCanvas.addEventListener("wheel",i=>{findTargetView(i)&&(this.#rn+=i.deltaY/100*this.#nn)})}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get centerX(){return this.#Qr}set centerX(i){this.#Qr=i}get centerY(){return this.#en}set centerY(i){this.#en=i}get centerZ(){return this.#tn}set centerZ(i){this.#tn=i}get distance(){return this.#rn}set distance(i){validateNumberRange(i,0),this.#rn=i}get speedDistance(){return this.#nn}set speedDistance(i){validateNumberRange(i,.01),this.#nn=i}get delayDistance(){return this.#in}set delayDistance(i){validateNumberRange(i,.01,.99),this.#in=i}get speedRotation(){return this.#zr}set speedRotation(i){validateNumberRange(i,.01),this.#zr=i}get delayRotation(){return this.#qr}set delayRotation(i){validateNumberRange(i,.01,.99),this.#qr=i}get minTilt(){return this.#sn}set minTilt(i){validateNumberRange(i,-90,90),this.#sn=i}get maxTilt(){return this.#on}set maxTilt(i){validateNumberRange(i,-90,90),this.#on=i}get pan(){return this.#un}set pan(i){this.#un=i}get tilt(){return this.#an}set tilt(i){validateNumberRange(i,-90,90),this.#an=i}update(i,m){this.#dn!==m&&(this.#dn=m,this.#fn.clear()),this.#fn.add(i),1===this.#fn.size&&this.#mn()}#mn(){const i=Math.PI/180;this.#an<this.#sn&&(this.#an=this.#sn),this.#an>this.#on&&(this.#an=this.#on);const{camera:m}=this;this.#ln+=(this.#un-this.#ln)*this.#qr,this.#cn+=(this.#an-this.#cn)*this.#qr,this.#rn<m.nearClipping&&(this.#rn=m.nearClipping),this.#hn+=(this.#rn-this.#hn)*this.#in,this.#hn<m.nearClipping&&(this.#hn=m.nearClipping);const g=m.modelMatrix;identity$2(g),translate$1(g,g,[this.#Qr,this.#en,this.#tn]),rotateY$3(g,g,this.#ln*i),rotateX$3(g,g,this.#cn*i),translate$1(g,g,[0,0,this.#hn]),m.x=g[12],m.y=g[13],m.z=g[14],this.camera.lookAt(this.#Qr,this.#en,this.#tn)}},OrthographicCamera:OrthographicCamera,PerspectiveCamera:PerspectiveCamera});class RedGPUContextSizeManager{#pn;#gn;#_;#xn=[0,0,0,0];#_n;#vn=1;constructor(i,m="100%",g="100%"){this.#_=i,this.#_n=i.htmlCanvas,this.#_n.style.boxSizing="border-box",this.#pn=m,this.#gn=g}get renderScale(){return this.#vn}set renderScale(i){validateNumber(i),i<=0&&(i=.01),this.#vn=i,this.setSize()}get width(){return this.#pn}set width(i){this.setSize(i,this.#gn)}get height(){return this.#gn}set height(i){this.setSize(this.#pn,i)}get pixelRectArray(){return this.#xn}get pixelRectObject(){return{x:this.#xn[0],y:this.#xn[1],width:this.#xn[2],height:this.#xn[3]}}get parentDomRect(){return(this.#_n.parentNode||document.body).getBoundingClientRect()}get screenRectObject(){return{x:this.#xn[0]/devicePixelRatio,y:this.#xn[1]/devicePixelRatio,width:this.#xn[2]/devicePixelRatio,height:this.#xn[3]/devicePixelRatio}}static validateSizeValue=i=>{switch(typeof i){case"number":validatePositiveNumberRange(i);break;case"string":new RegExp(/^[+]?^[.]?(\d+)(\.\d+)?(?:px|%|$)/gm).test(i)||consoleAndThrowError(`allow positive number,%,px model/input:${i}`);break;default:consoleAndThrowError(`positive number,%,px model/input:${i}`)}};static validatePositionValue=i=>{switch(typeof i){case"number":validateNumber(i);break;case"string":new RegExp(/^-?\d+(\.\d+)?(px|%)?$/).test(i)||consoleAndThrowError(`allow number,%,px model /input:${i}`);break;default:consoleAndThrowError(`number,%,px model/input:${i}`)}};static getPixelDimension(i,m,g){return"number"==typeof g?g:RedGPUContextSizeManager.calculateSizeFromString(i,m,g)}static calculateSizeFromString(i,m,g){return g.includes("%")?Math.floor(i[m]*+g.replace("%","")/100):+g.replace("px","")}setSize(i=this.#pn,m=this.#gn){RedGPUContextSizeManager.validateSizeValue(i),RedGPUContextSizeManager.validateSizeValue(m),this.#pn=i,this.#gn=m;const g=RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"width",i),x=RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"height",m);this.#bn(g,x),this.#yn(g,x),this.#Tn()}#yn(i,m){this.#xn[2]=Math.floor(i*this.#vn*window.devicePixelRatio),this.#xn[3]=Math.floor(m*this.#vn*window.devicePixelRatio)}#Tn(){this.#_.onResize&&this.#_.onResize(this.screenRectObject.width,this.screenRectObject.height),this.#_.viewList.forEach(i=>{i.setSize(),i.setPosition()})}#bn(i,m){const g=this.#_n,{style:x}=g;g.width=i*this.#vn*window.devicePixelRatio,g.height=m*this.#vn*window.devicePixelRatio,x.width=`${i}px`,x.height=`${m}px`}}class PassClusterLightBound{#Sn;#wn;#Mn;#Rn;#Pn;#_;constructor(i,m){validateRedGPUContext(i),this.#_=i,this.#Sn=m,this.#Cn()}get clusterBoundBuffer(){return this.#wn}render(){const i=this.#Sn.systemUniform_Vertex_UniformBindGroup;if(i){const{gpuDevice:m}=this.#_,g=m.createCommandEncoder(),x=g.beginComputePass({label:"Bound cluster"}),_=an.getDispatchSize();x.setPipeline(this.#Pn),x.setBindGroup(0,i),x.setBindGroup(1,this.#Rn),x.dispatchWorkgroups(_[0],_[1],_[2]),x.end(),m.queue.submit([g.finish()])}}#Cn(){const{gpuDevice:i,resourceManager:m}=this.#_,g=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n@group(1) @binding(0) var<storage,read_write> clusterLight_Clusters:ClusterLight_Clusters;\r\n\r\nfn lineIntersectionToZPlane(a:vec3<f32>,b:vec3<f32>,zDistance:f32) -> vec3<f32> {\rlet normal=vec3<f32>(0.0,0.0,0.5);\rlet ab=b - a;\rlet t=(zDistance - dot(normal,a))/dot(normal,ab);\rreturn a + t * ab;\r\n}\r\n\r\nfn clipToView(clip:vec4<f32>) -> vec4<f32> {\rlet view=systemUniforms.inverseProjectionMatrix * clip;\rreturn view/vec4<f32>(view.w,view.w,view.w,view.w);\r\n}\r\n\r\nfn screen2View(screen:vec4<f32>) -> vec4<f32> {\rlet texCoord=screen.xy/systemUniforms.resolution.xy;\rlet clip=vec4<f32>(vec2<f32>(texCoord.x,1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0,1.0),screen.z,screen.w );\rreturn clipToView(clip);\r\n}\r\n\r\nconst eyePos=vec3<f32>(0.0);\r\n\r\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\r\n\r\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) {\r\rlet tileIndex=global_id.x +\rglobal_id.y * clusterLight_tileCount.x +\rglobal_id.z * clusterLight_tileCount.x * clusterLight_tileCount.y;\r\n\r\rlet tileSize=vec2<f32>(\rsystemUniforms.resolution.x/f32(clusterLight_tileCount.x),\rsystemUniforms.resolution.y/f32(clusterLight_tileCount.y)\r);\r\n\r\rlet global_id_x_pos_one=vec2<f32>(f32(global_id.x + 1u),f32(global_id.y + 1u)) * tileSize;\rlet global_id_x_y=vec2<f32>(f32(global_id.x),f32(global_id.y)) * tileSize;\r\n\rlet maxPoint_sS=vec4<f32>(global_id_x_pos_one,0.0,1.0);\rlet minPoint_sS=vec4<f32>(global_id_x_y,0.0,1.0);\r\n\rlet maxPoint_vS=screen2View(maxPoint_sS).xyz;\rlet minPoint_vS=screen2View(minPoint_sS).xyz;\r\n\r\rlet nearFarX=systemUniforms.camera.nearClipping;\rlet nearFarY=systemUniforms.camera.farClipping;\r\n\rlet tileZ=f32(global_id.z)/f32(clusterLight_tileCount.z);\rlet tileZ_plus_one=f32(global_id.z + 1u)/f32(clusterLight_tileCount.z);\r\n\rlet tileNear=-nearFarX * pow(nearFarY/nearFarX,tileZ);\rlet tileFar=-nearFarX * pow(nearFarY/nearFarX,tileZ_plus_one);\r\n\r\rlet minPointNear=lineIntersectionToZPlane(eyePos,minPoint_vS,tileNear);\rlet minPointFar=lineIntersectionToZPlane(eyePos,minPoint_vS,tileFar);\rlet maxPointNear=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileNear);\rlet maxPointFar=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileFar);\r\n\r\rlet minAABB=min(min(minPointNear,minPointFar),min(maxPointNear,maxPointFar));\rlet maxAABB=max(max(minPointNear,minPointFar),max(maxPointNear,maxPointFar));\r\n\rclusterLight_Clusters.cubeList[tileIndex].minAABB=vec4<f32>(minAABB,0.0);\rclusterLight_Clusters.cubeList[tileIndex].maxAABB=vec4<f32>(maxAABB,0.0);\r\n}\r\n").shaderSource;this.#wn=i.createBuffer({size:32*an.getTotalTileSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#Mn=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.#Rn=i.createBindGroup({label:"clusterBoundBindGroup",layout:this.#Mn,entries:[{binding:0,resource:{buffer:this.#wn}}]}),this.#Pn=i.createComputePipeline({label:"clusterBoundPipeline",layout:i.createPipelineLayout({bindGroupLayouts:[m.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),this.#Mn]}),compute:{module:i.createShaderModule({code:g,label:"Cluster Bounds"}),entryPoint:"main"}})}}const wi=new Uint32Array([0,0,0,0]);class PassClustersLight{#Sn;#In;#En;#Ln;#_;constructor(i,m){validateRedGPUContext(i),this.#_=i,this.#Sn=m,this.#Cn()}get clusterLightsBuffer(){return this.#Ln}render(){const{gpuDevice:i}=this.#_,m=this.#Sn.systemUniform_Vertex_UniformBindGroup;if(m){const g=i.createCommandEncoder(),x=g.beginComputePass({label:"ClusterLight cluster"}),_=an.getDispatchSize();this.#_.gpuDevice.queue.writeBuffer(this.clusterLightsBuffer,0,wi),x.setPipeline(this.#En),x.setBindGroup(0,m),x.setBindGroup(1,this.#In),x.dispatchWorkgroups(_[0],_[1],_[2]),x.end(),i.queue.submit([g.finish()])}}#Cn(){const{gpuDevice:i,resourceManager:m}=this.#_,g=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n@group(1) @binding(0) var<storage> clusterLight_Clusters:ClusterLight_Clusters;\r\n\r\nfn pointLight_testSphereAABB(light:u32, tile:u32) -> bool {\r\rlet targetLight=clusterLightList.lights[light];\rlet targetTile=clusterLight_Clusters.cubeList[tile];\r\n\r\rlet radius:f32=targetLight.radius;\rlet position:vec3<f32>=targetLight.position;\rlet center:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(position,1.0)).xyz;\r\n\r\rlet squaredDistance:f32=pointLight_sqDistPointAABB(center,tile,targetTile.minAABB.xyz,targetTile.maxAABB.xyz);\r\n\rreturn squaredDistance <=(radius * radius);\r\n}\r\n\r\nfn pointLight_sqDistPointAABB(targetPoint:vec3<f32>,tile:u32,minAABB:vec3<f32>,maxAABB:vec3<f32>) -> f32 {\rvar sqDist=0.0;\rfor(var i=0u;i < 3u;i=i + 1u) {\r\rlet v=targetPoint[i];\rlet _minAABB=minAABB[i];\rlet _maxAABB=maxAABB[i];\r\n\rif(v < _minAABB){\rsqDist += (_minAABB - v) * (_minAABB - v);\r}\rif(v > _maxAABB){\rsqDist +=(v - _maxAABB) * (v - _maxAABB);\r}\r}\r\n\rreturn sqDist;\r\n}\r\n\r\nfn spotLight_testSphereAABB(light:u32,tile:u32) -> bool {\rlet targetLight=clusterLightList.lights[light];\rlet targetTile=clusterLight_Clusters.cubeList[tile];\r\n\rlet radius:f32=targetLight.radius;\rlet position:vec3<f32>=targetLight.position;\rlet center:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(position,1.0)).xyz;\r\n\r\rlet squaredDistance:f32=pointLight_sqDistPointAABB(center,tile,targetTile.minAABB.xyz,targetTile.maxAABB.xyz);\r\n\rreturn squaredDistance <=(radius * radius);\r\n}\r\n\r\n\r\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\r\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) {\rlet tileIndex=global_id.x +\rglobal_id.y * clusterLight_tileCount.x +\rglobal_id.z * clusterLight_tileCount.x * clusterLight_tileCount.y;\r\n\rvar clusterLightCount=0u;\rvar clusterLightIndices:array<u32,REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu>;\r\n\r\rfor (var i=0u;i < u32(clusterLightList.count[0]);i=i + 1u) {\rlet lightInCluster=pointLight_testSphereAABB(i,tileIndex);\r\n\rif (lightInCluster) {\rclusterLightIndices[clusterLightCount]=i;\rclusterLightCount=clusterLightCount + 1u;\r}\r\n\rif (clusterLightCount==REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu) {\rbreak;\r}\r}\r\n\r\rlet spotLightStartIndex=u32(clusterLightList.count[0]);\rfor (var i=0u;i < u32(clusterLightList.count[1]);i=i + 1u) {\rlet actualLightIndex=spotLightStartIndex + i;\r\n\r\rlet sphereTest=spotLight_testSphereAABB(actualLightIndex,tileIndex);\r\n\rif (sphereTest) {\rclusterLightIndices[clusterLightCount]=actualLightIndex;\rclusterLightCount=clusterLightCount + 1u;\r}\r\n\rif (clusterLightCount==REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu) {\rbreak;\r}\r}\r\n\rvar offset=atomicAdd(&clusterLightGroup.offset,clusterLightCount);\r\n\rfor(var i=0u;i < clusterLightCount;i=i + 1u) {\rclusterLightGroup.indices[offset + i]=clusterLightIndices[i];\r}\r\n\rclusterLightGroup.lights[tileIndex].offset=offset;\rclusterLightGroup.lights[tileIndex].count=clusterLightCount;\r\n}\r\n").shaderSource;this.#Ln=i.createBuffer({size:an.getClusterLightsBufferSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const x=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this.#In=i.createBindGroup({label:"clusterLightBindGroup",layout:x,entries:[{binding:0,resource:{buffer:this.#Sn.passLightClustersBound.clusterBoundBuffer}}]}),this.#En=i.createComputePipeline({label:"clusterLightPipeline",layout:i.createPipelineLayout({bindGroupLayouts:[m.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),x]}),compute:{module:i.createShaderModule({code:g,label:"Cluster Light"}),entryPoint:"main"}})}}class PickingEvent{pickingId;mouseX;mouseY;target;time;type;movementX=0;movementY=0;localX=0;localY=0;localZ=0;altKey=!1;ctrlKey=!1;shiftKey=!1;constructor(i,m,g,x,_,b,y){this.pickingId=i,this.mouseX=m,this.mouseY=g,this.target=x,this.time=_,this.type=b,this.altKey=y.altKey,this.ctrlKey=y.ctrlKey,this.shiftKey=y.shiftKey}}const Mi={MOVE:"move",DOWN:"down",UP:"up",OVER:"over",OUT:"out",CLICK:"click"};class PickingManager{lastMouseEvent;lastMouseClickEvent;#Bn;#Dn;#Un;#An;#_;#Sn;#kn=[];#On=0;#Nn=0;#Fn;#Gn;get mouseX(){return this.#On}set mouseX(i){this.#On=i}get mouseY(){return this.#Nn}set mouseY(i){this.#Nn=i}get castingList(){return this.#kn}get pickingGPUTexture(){return this.#Un}get pickingGPUTextureView(){return this.#An}get pickingDepthGPUTextureView(){return this.#Dn}resetCastingList(){this.#kn.length=0}destroy(){this.#Un&&(this.#Un.destroy(),this.#Bn.destroy(),this.#Un=null,this.#An=null,this.#Bn=null,this.#Dn=null)}checkTexture(i){const{redGPUContext:m}=i;this.#Sn=i,this.#_=m,this.#Un?.width===this.#Sn.pixelRectObject.width&&this.#Un?.height===this.#Sn.pixelRectObject.height||(this.destroy(),this.#Un=this.#Vn(navigator.gpu.getPreferredCanvasFormat()),this.#An=this.#Un.createView({label:this.#Un.label}),this.#Bn=this.#Vn("depth32float"),this.#Dn=this.#Bn.createView({label:this.#Bn.label}))}checkEvents(i,m){this.#$n(i,m),this.resetCastingList()}#Vn(i){const{gpuDevice:m}=this.#_;return m.createTexture({size:[this.#Sn.pixelRectObject.width,this.#Sn.pixelRectObject.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,format:i,sampleCount:1,label:`pickingGPUTexture_${this.#Sn.pixelRectObject.width}x${this.#Sn.pixelRectObject.height}_${Date.now()}`})}#$n=async(i,m,g=1,x=1)=>{const{gpuDevice:_}=i.redGPUContext,{pixelRectArray:b}=i,y=this.#On,T=this.#Nn;if(y<=0||y>=b[2]||T<=0||T>=b[3])return;const w=this.#Hn(),P=this.#zn(_,g,x,y,T),$=await this.#qn(P);P.destroy(),$?(this.#Kn($,y,T,m,w),this.#Wn($,y,T,m,w)):this.#Xn(),this.lastMouseEvent=null,this.lastMouseClickEvent=null};#Hn=()=>this.#kn.reduce((i,m)=>(i[m.pickingId]=m,i),{});#zn=(i,m,g,x,_)=>{const b=i.createCommandEncoder(),y=i.createBuffer({size:16*m*g,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),T={texture:this.#Un,origin:{x:x,y:_,z:0}},w={buffer:y,bytesPerRow:Math.max(256,4*m*g),rowsPerImage:1},P={width:m,height:g,depthOrArrayLayers:1};return b.copyTextureToBuffer(T,w,P),i.queue.submit([b.finish()]),y};#Kn=(i,m,g,x,_)=>{const b=_[i],y=this.lastMouseClickEvent?.type;if(y===Mi.CLICK){const _=new PickingEvent(i,m,g,b,x,y,this.lastMouseClickEvent);this.#jn(y,_)}};#Wn=(i,m,g,x,_)=>{const b=_[i],y=this.lastMouseEvent?.type;if(y){const _=new PickingEvent(i,m,g,b,x,y,this.lastMouseEvent);switch(this.#Fn&&(_.movementX=m-this.#Fn.mouseX,_.movementY=g-this.#Fn.mouseY),y){case Mi.DOWN:case Mi.UP:this.#jn(y,_);break;case Mi.MOVE:this.#Yn(i,b,_)}this.#Fn=_}};#Yn=(i,m,g)=>{const x=this.#Fn?.pickingId;x!==i?(this.#Fn&&x&&x!==i&&this.#Xn(),this.#Gn!==m&&(this.#jn(Mi.OVER,g),document.body.style.cursor="pointer"),this.#Gn=m):this.#jn(Mi.MOVE,g)};#Xn=()=>{this.#Fn&&this.#jn(Mi.OUT,this.#Fn),this.#Fn=null,this.#Gn=null,document.body.style.cursor="default"};async#qn(i){await i.mapAsync(GPUMapMode.READ);const m=new DataView(i.getMappedRange()),g="rgba8unorm"==this.#Un.format?[0,1,2,3]:[2,1,0,3],x=m.getUint8(g[0]),_=m.getUint8(g[1]),b=m.getUint8(g[2]);return(m.getUint8(g[3])<<24|b<<16|_<<8|x)>>>0}#jn(i,m){m.target.events[i]&&m.target.events[i](m)}}Object.freeze(PickingManager);const Ri=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include drawPicking;\r\n\r\nstruct Uniforms {\ruseDiffuseTexture:u32,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n};\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\r\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\rvar finalColor:vec4<f32>=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv);\rfinalColor=vec4<f32>(finalColor.rgb,finalColor.a * uniforms.opacity * inputData.combinedOpacity);\r\n\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\r\n\r\rif (systemUniforms.isView3D==1 && finalColor.a==0.0) {\rdiscard;\r}\r\n\rreturn finalColor;\r\n};\r\n");class BitmapMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,m,g){super(i,"BITMAP_MATERIAL",Ri,2),g&&(this.name=g),this.diffuseTexture=m,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}Br.defineByPreset(BitmapMaterial,[Br.PRESET_TEXTURE.DIFFUSE_TEXTURE,Br.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(BitmapMaterial);const Pi={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DIFFERENCE:6,EXCLUSION:7};const Ci=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include calcDirectionalShadowVisibility;\r\n#redgpu_include normalFunctions;\r\n#redgpu_include drawPicking;\r\nstruct Uniforms {\ruseDiffuseTexture:u32,\rcolor:vec3<f32>,\r\remissiveColor:vec3<f32>,\remissiveStrength:f32,\ruseEmissiveTexture:u32,\r\rspecularColor:vec3<f32>,\rspecularStrength:f32,\ruseSpecularTexture:u32,\rshininess:f32,\r\ruseAoTexture:u32,\raoStrength:f32,\r\ruseAlphaTexture:u32,\r\ruseNormalTexture:u32,\rnormalScale:f32,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\r\n};\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r\n\r\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n}\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\r\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\r\n@group(2) @binding(3) var alphaTextureSampler:sampler;\r\n@group(2) @binding(4) var alphaTexture:texture_2d<f32>;\r\n@group(2) @binding(5) var specularTextureSampler:sampler;\r\n@group(2) @binding(6) var specularTexture:texture_2d<f32>;\r\n@group(2) @binding(7) var emissiveTextureSampler:sampler;\r\n@group(2) @binding(8) var emissiveTexture:texture_2d<f32>;\r\n@group(2) @binding(9) var aoTextureSampler:sampler;\r\n@group(2) @binding(10) var aoTexture:texture_2d<f32>;\r\n@group(2) @binding(11) var normalTextureSampler:sampler;\r\n@group(2) @binding(12) var normalTexture:texture_2d<f32>;\r\n\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\n\r\rlet u_ambientLight=systemUniforms.ambientLight;\rlet u_ambientLightColor=u_ambientLight.color;\rlet u_ambientLightIntensity=u_ambientLight.intensity;\r\n\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_shadowDepthTextureSize=systemUniforms.shadowDepthTextureSize;\rlet u_bias=systemUniforms.bias;\r\n\r\n\r\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\n\r\rlet u_color=uniforms.color;\rlet u_aoStrength=uniforms.aoStrength;\rlet u_emissiveColor=uniforms.emissiveColor;\rlet u_emissiveStrength=uniforms.emissiveStrength;\rlet u_normalScale=uniforms.normalScale;\rlet u_specularColor=uniforms.specularColor;\rlet u_specularStrength=uniforms.specularStrength;\rlet u_shininess=uniforms.shininess;\rlet u_opacity=uniforms.opacity;\rlet E=normalize(u_cameraPosition);\r\rlet u_useDiffuseTexture=uniforms.useDiffuseTexture==1;\rlet u_useAlphaTexture=uniforms.useAlphaTexture==1;\rlet u_useSpecularTexture=uniforms.useSpecularTexture==1;\rlet u_useEmissiveTexture=uniforms.useEmissiveTexture==1;\rlet u_useAoTexture=uniforms.useAoTexture==1;\rlet u_useNormalTexture=uniforms.useNormalTexture==1;\r\rlet receiveShadowYn=inputData.receiveShadow !=.0;\r\n\r\n\r\r\n\r\rvar N=normalize(inputData.vertexNormal);\rif(u_useNormalTexture){\rlet normalSamplerColor=textureSample(normalTexture,normalTextureSampler,inputData.uv).rgb;\rN=perturb_normal( N,inputData.vertexPosition,inputData.uv,normalSamplerColor,u_normalScale );\r}else{\rN=N * u_normalScale;\r}\r\rvar finalColor:vec4<f32>;\rvar resultAlpha:f32=u_opacity * inputData.combinedOpacity;\rvar diffuseColor:vec3<f32>=u_color;\rif(u_useDiffuseTexture){\rlet diffuseSampleColor=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv);\rdiffuseColor=diffuseSampleColor.rgb;\rresultAlpha=resultAlpha * diffuseSampleColor.a;\r}\r\n\rvar specularSamplerValue:f32=1;\rif(u_useSpecularTexture){\rspecularSamplerValue=textureSample(specularTexture,specularTextureSampler,inputData.uv).r;\r}\rvar mixColor:vec3<f32>;\r\n\rvar visibility:f32=1.0;\rvisibility=calcDirectionalShadowVisibility(\rdirectionalShadowMap,\rdirectionalShadowMapSampler,\ru_shadowDepthTextureSize,\ru_bias,\rinputData.shadowPos,\r\n\r);\r\n\rif(!receiveShadowYn){\rvisibility=1.0;\r}\r\n\rfor (var i=0u;i < u_directionalLightCount;i=i + 1) {\rlet u_directionalLightDirection=u_directionalLights[i].direction;\rlet u_directionalLightColor=u_directionalLights[i].color;\rlet u_directionalLightIntensity=u_directionalLights[i].intensity;\r\n\rlet L=normalize(u_directionalLightDirection);\rlet R=reflect(L,N);\rlet lambertTerm=max(dot(N,-L),0.0);\rlet specular=pow(max(dot(R,E),0.0),u_shininess) * specularSamplerValue;\r\n\r\rlet lightContribution=u_directionalLightColor * u_directionalLightIntensity * visibility;\rlet ld=diffuseColor * lightContribution * lambertTerm;\rlet ls=u_specularColor * u_specularStrength * lightContribution * specular;\r\n\rmixColor +=ld + ls;\r\n\r}\r\n\r\rlet clusterIndex=getClusterLightClusterIndex(inputData.position);\rlet lightOffset =clusterLightGroup.lights[clusterIndex].offset;\rlet lightCount:u32 =clusterLightGroup.lights[clusterIndex].count;\r\n\rfor (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) {\rlet i=clusterLightGroup.indices[lightOffset + lightIndex];\rlet u_clusterLightPosition=clusterLightList.lights[i].position;\rlet u_clusterLightColor=clusterLightList.lights[i].color;\rlet u_clusterLightIntensity=clusterLightList.lights[i].intensity;\rlet u_clusterLightRadius=clusterLightList.lights[i].radius;\rlet u_isSpotLight=clusterLightList.lights[i].isSpotLight;\r\n\rlet lightDir=u_clusterLightPosition - inputData.vertexPosition;\rlet lightDistance=length(lightDir);\r\n\r\rif (lightDistance > u_clusterLightRadius) {\rcontinue;\r}\r\n\rlet L=normalize(lightDir);\r\n\rlet attenuation=clamp(1.0 - (lightDistance * lightDistance)/(u_clusterLightRadius * u_clusterLightRadius),0.0,1.0);\r\n\rvar finalAttenuation=attenuation;\r\n\r\rif (u_isSpotLight > 0.0) {\rlet u_clusterLightDirection=normalize(vec3<f32>(\rclusterLightList.lights[i].directionX,\rclusterLightList.lights[i].directionY,\rclusterLightList.lights[i].directionZ\r));\rlet u_clusterLightInnerAngle=clusterLightList.lights[i].innerCutoff;\rlet u_clusterLightOuterCutoff=clusterLightList.lights[i].outerCutoff;\r\n\r\rlet lightToVertex=normalize(-lightDir);\rlet cosTheta=dot(lightToVertex,u_clusterLightDirection);\r\n\rlet cosOuter=cos(radians(u_clusterLightOuterCutoff));\rlet cosInner=cos(radians(u_clusterLightInnerAngle));\r\n\r\rif (cosTheta < cosOuter) {\rcontinue;\r}\r\n\r\rlet epsilon=cosInner - cosOuter;\rlet spotIntensity=clamp((cosTheta - cosOuter)/epsilon,0.0,1.0);\r\n\rfinalAttenuation *=spotIntensity;\r}\r\n\r\rlet R=reflect(-L,N);\rlet diffuse=diffuseColor * max(dot(N,L),0.0);\rlet specular=pow(max(dot(R,E),0.0),u_shininess) * specularSamplerValue;\r\n\r\rlet diffuseAttenuation=finalAttenuation;\rlet specularAttenuation=finalAttenuation * finalAttenuation;\r\n\rlet ld=u_clusterLightColor * diffuse * diffuseAttenuation * u_clusterLightIntensity;\rlet ls=u_specularColor * u_specularStrength * specular * specularAttenuation * u_clusterLightIntensity;\r\n\rmixColor +=ld + ls;\r}\r\n\r\n\rif(u_useAlphaTexture){\rlet alphaMapValue:f32=textureSample(alphaTexture,alphaTextureSampler,inputData.uv).r;\rresultAlpha=alphaMapValue * resultAlpha;\rif(resultAlpha==0){\rdiscard;\r}\r}\rvar emissiveColor=u_emissiveColor * u_emissiveStrength;\rif(u_useEmissiveTexture){\remissiveColor=textureSample(emissiveTexture,emissiveTextureSampler,inputData.uv).rgb * u_emissiveStrength;\r}\rif(u_useAoTexture){\rmixColor=mixColor * textureSample(aoTexture,aoTextureSampler,inputData.uv).rgb * u_aoStrength;\r}\rfinalColor=vec4<f32>(mixColor + emissiveColor,resultAlpha);\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\r\rif (systemUniforms.isView3D==1 && finalColor.a==0.0) {\rdiscard;\r}\rreturn finalColor;\r\n}\r\n");class PhongMaterial extends ABitmapBaseMaterial{#Zn;#Jn=1;constructor(i,m="#fff",g){super(i,"PHONG_MATERIAL",Ci,2),g&&(this.name=g),this.initGPURenderInfos(),this.color.setColorByHEX(m),this.emissiveColor.setColorByHEX(this.emissiveColor.hex),this.specularColor.setColorByHEX(this.specularColor.hex)}get displacementScale(){return this.#Jn}set displacementScale(i){this.#Jn=i}get displacementTexture(){return this.#Zn}set displacementTexture(i){const m=this.#Zn;this.#Zn=i,this.updateTexture(m,i),this.dirtyPipeline=!0}}Br.defineByPreset(PhongMaterial,[Br.PRESET_COLOR_RGB.COLOR,Br.PRESET_TEXTURE.ALPHA_TEXTURE,Br.PRESET_SAMPLER.ALPHA_TEXTURE_SAMPLER,Br.PRESET_TEXTURE.AO_TEXTURE,Br.PRESET_SAMPLER.AO_TEXTURE_SAMPLER,Br.PRESET_POSITIVE_NUMBER.AO_STRENGTH,Br.PRESET_TEXTURE.DIFFUSE_TEXTURE,Br.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER,Br.PRESET_TEXTURE.EMISSIVE_TEXTURE,Br.PRESET_SAMPLER.EMISSIVE_TEXTURE_SAMPLER,Br.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,[Br.PRESET_COLOR_RGB.EMISSIVE_COLOR,"#000000"],Br.PRESET_TEXTURE.NORMAL_TEXTURE,Br.PRESET_SAMPLER.NORMAL_TEXTURE_SAMPLER,Br.PRESET_POSITIVE_NUMBER.NORMAL_SCALE,Br.PRESET_TEXTURE.SPECULAR_TEXTURE,Br.PRESET_SAMPLER.SPECULAR_TEXTURE_SAMPLER,Br.PRESET_POSITIVE_NUMBER.SPECULAR_STRENGTH,[Br.PRESET_COLOR_RGB.SPECULAR_COLOR,"#ffffff"],[Br.PRESET_POSITIVE_NUMBER.SHININESS,32]]),Object.freeze(PhongMaterial);var Ii=Object.freeze({__proto__:null,ABaseMaterial:ABaseMaterial,ABitmapBaseMaterial:ABitmapBaseMaterial,BLEND_MODE:Pi,BitmapMaterial:BitmapMaterial,COMPOSITE_MODE:{ADDITIVE:"additive",SOURCE_OVER:"source-over",SOURCE_IN:"source-in",SOURCE_OUT:"source-out",SOURCE_ATOP:"source-atop",DESTINATION_OVER:"destination-over",DESTINATION_IN:"destination-in",DESTINATION_OUT:"destination-out",DESTINATION_ATOP:"destination-atop"},ColorMaterial:ColorMaterial,PhongMaterial:PhongMaterial,TINT_BLEND_MODE:Bn,getComputeBindGroupLayoutDescriptorFromShaderInfo:getComputeBindGroupLayoutDescriptorFromShaderInfo,getFragmentBindGroupLayoutDescriptorFromShaderInfo:getFragmentBindGroupLayoutDescriptorFromShaderInfo,getVertexBindGroupLayoutDescriptorFromShaderInfo:getVertexBindGroupLayoutDescriptorFromShaderInfo});class ASinglePassPostEffect{#Qn;#ei;#ti;#ri;#ni;#ii;#ai;#si;#oi;#ui;#li;#ci;#a;#hi;#fi;#di;#mi=[];#pi=[];#gi=16;#xi=16;#_i=1;#vi=!1;#_;#bi;#yi=[];constructor(i){this.#_=i,this.#bi=i.antialiasingManager}get useDepthTexture(){return this.#vi}set useDepthTexture(i){this.#vi=i}get redGPUContext(){return this.#_}get storageInfo(){return this.#ci}get shaderInfo(){return this.#bi.useMSAA?this.#hi:this.#fi}get uniformBuffer(){return this.#ui}get uniformInfo(){return this.#li}get WORK_SIZE_X(){return this.#gi}set WORK_SIZE_X(i){this.#gi=i}get WORK_SIZE_Y(){return this.#xi}set WORK_SIZE_Y(i){this.#xi=i}get WORK_SIZE_Z(){return this.#_i}set WORK_SIZE_Z(i){this.#_i=i}get outputTextureView(){return this.#pi}getOutputTextureView(){return this.#pi[this.#pi.length-1]}clear(){this.#mi&&(this.#mi.forEach(i=>i.destroy()),this.#mi.length=0,this.#pi.length=0)}init(i,m,g,x){this.#a=m;const{resourceManager:_}=i;this.#Qn=_.createGPUShaderModule(`${m}_MSAA`,{code:g.msaa}),this.#ei=_.createGPUShaderModule(`${m}_NonMSAA`,{code:g.nonMsaa}),this.#hi=parseWGSL(g.msaa),this.#fi=parseWGSL(g.nonMsaa);const b=this.#hi.storage,y=this.#hi.uniforms.uniforms;if(this.#ci=b,this.#li=y,y){const m=new ArrayBuffer(y.arrayBufferByteLength);this.#ui=new UniformBuffer(i,m,`${this.constructor.name}_UniformBuffer`)}}execute(i,m,g){const x=i.createCommandEncoder(),_=x.beginComputePass();_.setPipeline(this.#oi),_.setBindGroup(0,this.#ni),_.setBindGroup(1,this.#ii),_.dispatchWorkgroups(Math.ceil(m/this.WORK_SIZE_X),Math.ceil(g/this.WORK_SIZE_Y)),_.end(),i.queue.submit([x.finish()])}render(i,m,g,...x){const{gpuDevice:_,antialiasingManager:b}=this.#_,{useMSAA:y}=b,T=this.#Ti(i),w=b.changedMSAA,P=this.#Si(x),$=this.getOutputTextureView(),{redGPUContext:H}=i;if(T||w||P){const m=this.storageInfo,g=this.uniformInfo;this.#ai=[],this.#si=[];for(const i in m){const g=m[i],{binding:_,name:b}=g;"outputTexture"!==b&&this.#ai.push({binding:_,resource:x[_]})}this.#si.push({binding:0,resource:$}),this.shaderInfo.textures.forEach(m=>{const{name:g,binding:x}=m;"depthTexture"===g&&this.#ai.push({binding:x,resource:i.viewRenderTextureManager.depthTextureView})}),this.#ui&&g&&this.#si.push({binding:g.binding,resource:{buffer:this.#ui.gpuBuffer,offset:0,size:this.#ui.size}})}if(T||w||P){const i=y?this.#hi:this.#fi,m=y?this.#Qn:this.#ei;this.#ti=H.resourceManager.getGPUBindGroupLayout(`${this.#a}_BIND_GROUP_LAYOUT_0_USE_MSAA_${y}`)||H.resourceManager.createBindGroupLayout(`${this.#a}_BIND_GROUP_LAYOUT_0_USE_MSAA_${y}`,getComputeBindGroupLayoutDescriptorFromShaderInfo(i,0,y)),this.#ri=H.resourceManager.getGPUBindGroupLayout(`${this.#a}_BIND_GROUP_LAYOUT_1_USE_MSAA_${y}`)||H.resourceManager.createBindGroupLayout(`${this.#a}_BIND_GROUP_LAYOUT_1_USE_MSAA_${y}`,getComputeBindGroupLayoutDescriptorFromShaderInfo(i,1,y)),this.#ni=_.createBindGroup({layout:this.#ti,entries:this.#ai}),this.#ii=_.createBindGroup({layout:this.#ri,entries:this.#si}),this.#oi=_.createComputePipeline({label:`${this.#a}_COMPUTE_PIPELINE_USE_MSAA_${y}`,layout:_.createPipelineLayout({bindGroupLayouts:[this.#ti,this.#ri]}),compute:{module:m,entryPoint:"main"}}),this.#wi(x)}return this.update(performance.now()),this.execute(_,m,g),$}update(i){}updateUniform(i,m){this.uniformBuffer.writeBuffer(this.uniformInfo.members[i],m)}#Si(i){if(!this.#yi||this.#yi.length!==i.length)return!0;for(let m=0;m<i.length;m++)if(this.#yi[m]!==i[m])return!0;return!1}#wi(i){this.#yi=[...i]}#Ti(i){const{redGPUContext:m,viewRenderTextureManager:g}=i,{colorTexture:x}=g,{gpuDevice:_}=m,{width:b,height:y}=x,T=b!==this.#di?.width||y!==this.#di?.height;if(T){this.clear();const i=_.createTexture({size:{width:b,height:y},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,label:`PostEffect_${this.#a}_${b}x${y}_${Date.now()}`});this.#mi.push(i),this.#pi.push(i.createView({label:i.label}))}return this.#di={width:b,height:y},T}}Object.freeze(ASinglePassPostEffect);const createCode=(i,m,g="",x=!1)=>{const{WORK_SIZE_X:_,WORK_SIZE_Y:b,WORK_SIZE_Z:y}=i,T=x?"texture_depth_multisampled_2d":"texture_depth_2d";return`${g}@group(0) @binding(0) var sourceTexture:texture_storage_2d<rgba8unorm,read>;${i.useDepthTexture?`@group(0) @binding(1) var depthTexture:${T}`:""};\n\t@group(1) @binding(0) var outputTexture:texture_storage_2d<rgba8unorm,write>;${g?"@group(1) @binding(1) var<uniform> uniforms:Uniforms;":""}@compute @workgroup_size(${_},${b},${y})fn main (@builtin(global_invocation_id) global_id:vec3<u32>,){${(i=>i.replace(/\/\/[^\r\n]*(?=\S)/g,"\n").replace(/\/\/[^\r\n]*/g,""))(m)}}`},createBasicPostEffectCode=(i,m,g="")=>({msaa:createCode(i,m,g,!0),nonMsaa:createCode(i,m,g,!1)});Object.freeze(createBasicPostEffectCode);class FXAA extends ASinglePassPostEffect{#Mi=.75;#Ri=.166;#Pi=.0833;constructor(i){super(i);this.init(i,"POST_EFFECT_FXAA",createBasicPostEffectCode(this,"\nlet index=vec2<u32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\n\nvar colorC=textureLoad(sourceTexture,index);\nvar colorN=textureLoad(sourceTexture,vec2<u32>(index.x,u32(max(i32(index.y) - 1,0))));\nvar colorS=textureLoad(sourceTexture,vec2<u32>(index.x,u32(min(i32(index.y) + 1,i32(dimH - 1)))));\nvar colorW=textureLoad(sourceTexture,vec2<u32>(u32(max(i32(index.x) - 1,0)),index.y));\nvar colorE=textureLoad(sourceTexture,vec2<u32>(u32(min(i32(index.x) + 1,i32(dimW - 1))),index.y));\n\nlet lumaC=dot(colorC.rgb,vec3<f32>(0.299,0.587,0.114));\nlet lumaN=dot(colorN.rgb,vec3<f32>(0.299,0.587,0.114));\nlet lumaS=dot(colorS.rgb,vec3<f32>(0.299,0.587,0.114));\nlet lumaW=dot(colorW.rgb,vec3<f32>(0.299,0.587,0.114));\nlet lumaE=dot(colorE.rgb,vec3<f32>(0.299,0.587,0.114));\n\nlet lumaMin=min(lumaC,min(min(lumaN,lumaS),min(lumaW,lumaE)));\nlet lumaMax=max(lumaC,max(max(lumaN,lumaS),max(lumaW,lumaE)));\nlet range=lumaMax - lumaMin;\n\nlet edgeThreshold=uniforms.edgeThreshold;\nlet edgeThresholdMin=uniforms.edgeThresholdMin;\nlet subpix=uniforms.subpix;\n\nif (range < edgeThresholdMin) {\ntextureStore(outputTexture,index,colorC);\nreturn;\n}\n\nlet blurredColor=(colorN.rgb + colorS.rgb + colorW.rgb + colorE.rgb + colorC.rgb) * 0.2;\n\nlet blendAmount=min(1.0,range * 50.0 + 0.5) * subpix;\n\nlet finalColor=mix(colorC.rgb,blurredColor,blendAmount);\n\ntextureStore(outputTexture,index,vec4<f32>(finalColor,colorC.a));\n","\nstruct Uniforms {subpix:f32,edgeThreshold:f32,edgeThresholdMin:f32 \n};\n")),this.subpix=this.#Mi,this.edgeThreshold=this.#Ri,this.edgeThresholdMin=this.#Pi}get subpix(){return this.#Mi}set subpix(i){validateNumberRange(i,0,1),this.#Mi=i,this.updateUniform("subpix",i)}get edgeThreshold(){return this.#Ri}set edgeThreshold(i){validateNumberRange(i,1e-4,.25),this.#Ri=i,this.updateUniform("edgeThreshold",i)}get edgeThresholdMin(){return this.#Pi}set edgeThresholdMin(i){validateNumberRange(i,1e-5,.1),this.#Pi=i,this.updateUniform("edgeThresholdMin",i)}}Object.freeze(FXAA);class PostEffectManager{#Sn;#Ci=[];#Ii;#Ei;#Li;#Bi=16;#Di=4;#Ui=1;#Ai;#ki;#Oi;#Ni;#Fi;#Gi;constructor(i){this.#Sn=i,this.#Vi()}get view(){return this.#Sn}get effectList(){return this.#Ci}addEffect(i){this.#Ci.push(i)}addEffectAt(i){}getEffectAt(i){return this.#Ci[i]}removeEffect(i){}removeEffectAt(i){}removeAllEffect(){this.#Ci.forEach(i=>{i.clear()}),this.#Ci.length=0}render(){const{viewRenderTextureManager:i,redGPUContext:m}=this.#Sn,{antialiasingManager:g}=m,{useMSAA:x,useFXAA:_}=g,{colorTextureView:b,colorResolveTextureView:y,colorTexture:T}=i,{width:w,height:P}=T,$=x?y:b;this.#Ei=this.#$i(this.#Sn,$);let H=this.#Ei;return this.#Ci.forEach(i=>{H=i.render(this.#Sn,w,P,H)}),_&&(this.#Ai||(this.#Ai=new FXAA(m)),this.#Ai.subpix=g.fxaa_subpix,H=this.#Ai.render(this.#Sn,w,P,H)),H}clear(){this.#Ci.forEach(i=>{i.clear()})}#Vi(){const{redGPUContext:i}=this.#Sn,{gpuDevice:m,width:g}=i,x=this.#Hi();this.#ki=m.createShaderModule({code:x}),this.#Ni=this.#zi(i),this.#Fi=this.#qi(m,this.#ki,this.#Ni)}#$i(i,m){const{redGPUContext:g,viewRenderTextureManager:x}=i,{colorTexture:_}=x,{gpuDevice:b,antialiasingManager:y}=g,{useMSAA:T,changedMSAA:w}=y,{width:P,height:$}=_,H=P!==this.#Gi?.width||$!==this.#Gi?.height;return H&&(this.#Ii&&(this.#Ii.destroy(),this.#Ii=null),this.#Ii=this.#Ki(b,P,$),this.#Li=this.#Ii.createView({label:this.#Ii.label})),(H||w)&&(this.#Oi=this.#Wi(g,this.#Ni,m,this.#Li)),this.#Gi={width:P,height:$},this.#Xi(b,this.#Fi,this.#Oi,P,$),this.#Li}#Hi(){return`@group(0) @binding(0) var sourceTextureSampler:sampler;@group(0) @binding(1) var sourceTexture:texture_2d<f32>;@group(0) @binding(2) var outputTexture:texture_storage_2d<rgba8unorm,write>;@compute @workgroup_size(${this.#Bi},${this.#Di},${this.#Ui})fn main (@builtin(global_invocation_id) global_id:vec3<u32>,){let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>((f32(index.x)+0.5)/dimW,(f32(index.y)+0.5)/dimH);var color:vec4<f32>=textureSampleLevel(sourceTexture,sourceTextureSampler,uv,0);textureStore(outputTexture,index,color );};`}#zi(i){return i.resourceManager.createBindGroupLayout("POST_EFFECT_COPY_TO_STORAGE",{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm"}}]})}#Ki(i,m,g){return i.createTexture({size:{width:m,height:g},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,label:`PostEffect_Storage_${m}x${g}_${Date.now()}`})}#Wi(i,m,g,x){return i.gpuDevice.createBindGroup({layout:m,entries:[{binding:0,resource:new Sampler(i).gpuSampler},{binding:1,resource:g},{binding:2,resource:x}]})}#qi(i,m,g){return i.createComputePipeline({layout:i.createPipelineLayout({bindGroupLayouts:[g]}),compute:{module:m,entryPoint:"main"}})}#Xi(i,m,g,x,_){const b=i.createCommandEncoder(),y=b.beginComputePass();y.setPipeline(m),y.setBindGroup(0,g),y.dispatchWorkgroups(Math.ceil(x/this.#Bi),Math.ceil(_/this.#Di)),y.end(),i.queue.submit([b.finish()])}}Object.freeze(PostEffectManager);class RenderViewStateData{useDistanceCulling;cullingDistanceSquared;distanceCulling;num3DGroups;num3DObjects;numDrawCalls;numDirtyPipelines;numInstances;numTriangles;numPoints;viewRenderTime;viewportSize;usedVideoMemory;currentRenderPassEncoder;timestamp;frustumPlanes;prevVertexGpuBuffer;prevFragmentUniformBindGroup;dirtyVertexUniformFromMaterial={};alphaLayer=[];transparentLayer=[];particleLayer=[];instanceMeshLayer=[];render2PathLayer=[];startTime;isScene2DMode=!1;#Sn;constructor(i){this.#Sn=i}get view(){return this.#Sn}reset(i,m){if(!m||!this.#Sn)throw new Error("Invalid parameters provided");const g=this.#Sn,{useFrustumCulling:x,frustumPlanes:_}=g,{colorTexture:b,depthTexture:y}=g.viewRenderTextureManager;if(!b||!y)throw new Error("Invalid view properties");this.useDistanceCulling=g.useDistanceCulling,this.distanceCulling=g.distanceCulling,this.cullingDistanceSquared=this.distanceCulling*this.distanceCulling,this.num3DGroups=0,this.num3DObjects=0,this.numDrawCalls=0,this.numInstances=0,this.numDirtyPipelines=0,this.numTriangles=0,this.numPoints=0,this.viewRenderTime=0,this.currentRenderPassEncoder=i,this.timestamp=m,this.prevVertexGpuBuffer=null,this.prevFragmentUniformBindGroup=null,this.dirtyVertexUniformFromMaterial={},this.alphaLayer=[],this.transparentLayer=[],this.particleLayer=[],this.instanceMeshLayer=[],this.render2PathLayer=[],this.startTime=performance.now(),this.isScene2DMode=g.camera instanceof Camera2D,this.viewportSize={x:g.x,y:g.y,width:g.width,height:g.height,pixelRectArray:g.pixelRectArray};try{this.usedVideoMemory=calculateTextureByteSize({size:[b.width,b.height,b.depthOrArrayLayers],format:b.format,sampleCount:b.sampleCount,usage:b.usage})+calculateTextureByteSize({size:[y.width,y.height,y.depthOrArrayLayers],format:y.format,sampleCount:y.sampleCount,usage:y.usage})}catch(i){throw new Error("Could not calculate texture size:"+i.message)}this.frustumPlanes=x?_:null}}class ADrawDebuggerLight{#_;#ji;#Yi;get lightMaterial(){return this.#ji}get lightDebugMesh(){return this.#Yi}constructor(i,m,g=32){this.#_=i;const x=this.createLightDebugGeometry(i,g);this.#ji=new ColorMaterial(i),this.#ji.color.setColorByRGB(m[0],m[1],m[2]),this.#Yi=new Mesh(i,x,this.#ji),this.#Yi.primitiveState.cullMode="none",this.#Yi.primitiveState.topology=yr.LINE_LIST,this.#Yi.depthStencilState.depthWriteEnabled=!1}createLightDebugGeometry(i,m){const g=new Float32Array(2*m*8),x=new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexNormal:InterleaveType.float32x3,texcoord:InterleaveType.float32x2},`lightDebugStruct_${Math.random()}`),_=new VertexBuffer(i,g,x);return new Geometry(i,_)}updateVertexBuffer(i,m){const g=m.data;let x=0;const _=Math.min(i.length,Math.floor(g.length/16));for(let m=0;m<_;m++){const[_,b]=i[m];g[x++]=_[0],g[x++]=_[1],g[x++]=_[2],g[x++]=0,g[x++]=0,g[x++]=1,g[x++]=0,g[x++]=0,g[x++]=b[0],g[x++]=b[1],g[x++]=b[2],g[x++]=0,g[x++]=0,g[x++]=1,g[x++]=0,g[x++]=0}m.updateAllData(g)}}class DrawDebuggerPointLight extends ADrawDebuggerLight{#$e;constructor(i,m){super(i,[0,255,255],51),this.#$e=m}#Zi(i,m){const g=i.position||[0,0,0],x=i.radius||1,_=16,b=[];for(let i=0;i<_;i++){const m=i/_*Math.PI*2,y=(i+1)/_*Math.PI*2,T=g[0]+Math.cos(m)*x,w=g[1]+Math.sin(m)*x,P=g[2],$=g[0]+Math.cos(y)*x,H=g[1]+Math.sin(y)*x,z=g[2];b.push([[T,w,P],[$,H,z]])}for(let i=0;i<_;i++){const m=i/_*Math.PI*2,y=(i+1)/_*Math.PI*2,T=g[0]+Math.cos(m)*x,w=g[1],P=g[2]+Math.sin(m)*x,$=g[0]+Math.cos(y)*x,H=g[1],z=g[2]+Math.sin(y)*x;b.push([[T,w,P],[$,H,z]])}for(let i=0;i<_;i++){const m=i/_*Math.PI*2,y=(i+1)/_*Math.PI*2,T=g[0],w=g[1]+Math.cos(m)*x,P=g[2]+Math.sin(m)*x,$=g[0],H=g[1]+Math.cos(y)*x,z=g[2]+Math.sin(y)*x;b.push([[T,w,P],[$,H,z]])}const y=.2*x;b.push([[g[0]-y,g[1],g[2]],[g[0]+y,g[1],g[2]]]),b.push([[g[0],g[1]-y,g[2]],[g[0],g[1]+y,g[2]]]),b.push([[g[0],g[1],g[2]-y],[g[0],g[1],g[2]+y]]),this.updateVertexBuffer(b,m)}render(i){this.#$e.enableDebugger&&(this.#Zi(this.#$e,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i))}}Object.freeze(DrawDebuggerPointLight);class DrawDebuggerSpotLight extends ADrawDebuggerLight{#$e;constructor(i,m){super(i,[255,255,0],80),this.#$e=m}#Ji(i,m){const g=i.position||[0,0,0],x=i.direction||[0,-1,0],_=i.radius||5,b=i.outerCutoff||22.5,y=i.innerCutoff||15,T=[],w=Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]),P=[x[0]/w,x[1]/w,x[2]/w],$=[g[0]+P[0]*_,g[1]+P[1]*_,g[2]+P[2]*_],H=_*Math.tan(b*Math.PI/180),z=_*Math.tan(y*Math.PI/180);let q=[0,1,0];Math.abs(P[1])>.99&&(q=[1,0,0]);const W=[P[1]*q[2]-P[2]*q[1],P[2]*q[0]-P[0]*q[2],P[0]*q[1]-P[1]*q[0]],ye=Math.sqrt(W[0]*W[0]+W[1]*W[1]+W[2]*W[2]),Ge=[W[0]/ye,W[1]/ye,W[2]/ye],Ke=[Ge[1]*P[2]-Ge[2]*P[1],Ge[2]*P[0]-Ge[0]*P[2],Ge[0]*P[1]-Ge[1]*P[0]],Xe=16;for(let i=0;i<Xe;i++){const m=i/Xe*Math.PI*2,x=(i+1)/Xe*Math.PI*2,_=Math.cos(m),b=Math.sin(m),y=Math.cos(x),w=Math.sin(x),P=[$[0]+(Ge[0]*_+Ke[0]*b)*H,$[1]+(Ge[1]*_+Ke[1]*b)*H,$[2]+(Ge[2]*_+Ke[2]*b)*H],z=[$[0]+(Ge[0]*y+Ke[0]*w)*H,$[1]+(Ge[1]*y+Ke[1]*w)*H,$[2]+(Ge[2]*y+Ke[2]*w)*H];T.push([P,z]),T.push([g,P])}for(let i=0;i<Xe;i++){const m=i/Xe*Math.PI*2,g=(i+1)/Xe*Math.PI*2,x=Math.cos(m),_=Math.sin(m),b=Math.cos(g),y=Math.sin(g),w=[$[0]+(Ge[0]*x+Ke[0]*_)*z,$[1]+(Ge[1]*x+Ke[1]*_)*z,$[2]+(Ge[2]*x+Ke[2]*_)*z],P=[$[0]+(Ge[0]*b+Ke[0]*y)*z,$[1]+(Ge[1]*b+Ke[1]*y)*z,$[2]+(Ge[2]*b+Ke[2]*y)*z];T.push([w,P])}T.push([g,$]);const je=.3;T.push([[g[0]-je,g[1],g[2]],[g[0]+je,g[1],g[2]]]),T.push([[g[0],g[1]-je,g[2]],[g[0],g[1]+je,g[2]]]),T.push([[g[0],g[1],g[2]-je],[g[0],g[1],g[2]+je]]);for(let i=0;i<4;i++){const m=i/4*Math.PI*2,x=Math.cos(m),_=Math.sin(m),b=[$[0]+(Ge[0]*x+Ke[0]*_)*H,$[1]+(Ge[1]*x+Ke[1]*_)*H,$[2]+(Ge[2]*x+Ke[2]*_)*H];T.push([g,b])}this.updateVertexBuffer(T,m)}render(i){this.#$e.enableDebugger&&(this.#Ji(this.#$e,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i))}}Object.freeze(DrawDebuggerSpotLight);class ResourceStateIndexBuffer{static dirtyList=[];buffer;label;uuid;#$=0;constructor(i){this.buffer=i,this.label=i.name,this.uuid=i.uuid}get useNum(){return this.#$}set useNum(i){this.#$=i,ResourceStateIndexBuffer.dirtyList.push(this)}}class IndexBuffer extends ABaseBuffer{#W;#Qi=0;#Ge=0;#X;constructor(i,m,g=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,x=""){super(i,"managedIndexBufferState",g);const _=getCacheBufferFromResourceState(this,x);if(_)return _;x&&(this.name=x),this.changeData(m),basicRegisterResource(this,new ResourceStateIndexBuffer(this))}get gpuBuffer(){return this.#X}get size(){return this.#W.byteLength||0}get triangleCount(){return this.#Ge}get indexNum(){return this.#Qi}destroy(){const i=this.#X;i&&(this.#X=null,this.__fireListenerList(!0),basicUnregisterResource(this),i&&i.destroy())}changeData(i){const{gpuDevice:m}=this;if(Array.isArray(i)&&(i=new Uint32Array(i)),this.#X){this.targetResourceManagedState.videoMemory-=this.#W.byteLength||0;let i=this.#X;requestAnimationFrame(()=>{i.destroy()}),this.#X=null}this.#W=i,this.#Qi=i.length,this.targetResourceManagedState.videoMemory+=this.#W.byteLength;const g={size:this.#W.byteLength,usage:this.usage,label:this.name};this.#X=m.createBuffer(g),this.#Ge=this.#Qi/3,m.queue.writeBuffer(this.#X,0,this.#W)}updatePartialData(i,m){const{gpuDevice:g}=this;(i<0||i>=this.#W.length)&&consoleAndThrowError(`Offset value is out of data bounds. Tried to access index ${i} on data of length ${this.#W.length}`),Array.isArray(m)&&(m=new Uint32Array(m)),this.#Qi=m.length,g.queue.writeBuffer(this.#X,i,m)}}Object.freeze(IndexBuffer);class Primitive{#ea;#T;#S;#w;constructor(i){validateRedGPUContext(i)}static get primitiveInterleaveStruct(){return new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexNormal:InterleaveType.float32x3,texcoord:InterleaveType.float32x2},"primitiveInterleaveStruct")}get gpuRenderInfo(){return this.#ea}get vertexBuffer(){return this.#T}get indexBuffer(){return this.#S}get volume(){return this.#w||(this.#w=calculateGeometryAABB(this.#T)),this.#w}_setData(i){if(this.#T=i.vertexBuffer,this.#S=i.indexBuffer,this.#T){const{interleavedStruct:i}=this.#T;this.#ea=new GeometryGPURenderInfo([{arrayStride:i.arrayStride,attributes:i.attributes}])}}}Object.freeze(Primitive);const createPrimitiveGeometry=(i,m,g,x)=>new Geometry(i,new VertexBuffer(i,new Float32Array(m),Primitive.primitiveInterleaveStruct,void 0,`VertexBuffer_${x}`),new IndexBuffer(i,new Uint32Array(g),void 0,`IndexBuffer_${x}`));class Box extends Primitive{#ta=function(){let i,m;return m=function(m,g,x,_,b,y,T,w,P,$,H,z,q){let W,ye,Ge=w/H,Ke=P/z,Xe=w/2,je=P/2,Ye=$/2,Ze=H+1,Je=z+1,Qe=0,et=[];for(ye=0;ye<Je;ye++){let i=ye*Ke-je;for(W=0;W<Ze;W++){let g=W*Ge-Xe;et[x]=g*y,et[_]=i*T,et[b]=Ye,m.push(et.x,et.y,et.z),et[x]=0,et[_]=0,et[b]=$>0?1:-1,m.push(et.x,et.y,et.z),m.push(W/H*q,ye/z*q),Qe+=1}}for(ye=0;ye<z;ye++)for(W=0;W<H;W++){let m=i+W+Ze*ye,x=i+W+Ze*(ye+1),_=i+(W+1)+Ze*(ye+1),b=i+(W+1)+Ze*ye;g.push(m,x,b,x,_,b)}i+=Qe},function(g,x,_,b,y,T,w,P,$){let H=[],z=[];return i=0,m(H,z,"z","y","x",-1,-1,y,b,_,P,w,$),m(H,z,"z","y","x",1,-1,y,b,-_,P,w,$),m(H,z,"x","z","y",1,1,_,y,b,T,P,$),m(H,z,"x","z","y",1,-1,_,y,-b,T,P,$),m(H,z,"x","y","z",1,-1,_,b,y,T,w,$),m(H,z,"x","y","z",-1,-1,_,b,-y,T,w,$),createPrimitiveGeometry(x,H,z,g)}}();constructor(i,m=1,g=1,x=1,_=1,b=1,y=1,T=1){super(i);const w=`PRIMITIVE_BOX_W${m}_H${g}_D${x}_WS${_}_HS${b}_DS${y}_UV${T}`,P=i.resourceManager.cachedBufferState;let $=P[w];$||($=P[w]=this.#ta(w,i,m,g,x,_,b,y,T)),this._setData($)}}class Cylinder extends Primitive{#ta=function(){let i,m;return function(g,x,_,b,y,T,w,P,$,H){const z=[],q=[];let W=0;const ye=[],Ge=y/2;return i=function(){let i,m;const g=[],x=[],P=(b-_)/y;for(m=0;m<=w;m++){const q=[],Ke=m/w,Xe=Ke*(b-_)+_;for(i=0;i<=T;i++){const m=i/T,_=m*H+$,b=Math.sin(_),w=Math.cos(_);x[0]=Xe*b,x[1]=-Ke*y+Ge,x[2]=Xe*w,z.push(x[0],x[1],x[2]),g[0]=b,g[1]=P,g[2]=w,normalize$4(g,g),z.push(g[0],g[1],g[2]),z.push(m,Ke),q.push(W++)}ye.push(q)}for(i=0;i<T;i++)for(m=0;m<w;m++){const g=ye[m][i],x=ye[m+1][i],_=ye[m+1][i+1],b=ye[m][i+1];q.push(g,x,b),q.push(x,_,b)}},m=function(i){let m,g,x;const y=[],w=[],P=!0===i?_:b,ye=!0===i?1:-1;for(g=W,m=1;m<=T;m++)z.push(0,Ge*ye,0),z.push(0,ye,0),z.push(.5,.5),W++;for(x=W,m=0;m<=T;m++){const i=m/T*H+$,g=Math.cos(i),x=Math.sin(i);w[0]=P*x,w[1]=Ge*ye,w[2]=P*g,z.push(w[0],w[1],w[2]),z.push(0,ye,0),y[0]=.5*g+.5,y[1]=.5*x*ye+.5,z.push(y[0],1-y[1]),W++}for(m=0;m<T;m++){const _=g+m,b=x+m;!0===i?q.push(b,b+1,_):q.push(b+1,b,_)}},i(),!1===P&&(_>0&&m(!0),b>0&&m(!1)),createPrimitiveGeometry(x,z,q,g)}}();constructor(i,m=1,g=1,x=1,_=8,b=8,y=!1,T=0,w=2*Math.PI){super(i);const P=`PRIMITIVE_CYLINDER_RT${m}_RB${g}_H${x}_RS${_}_HS${b}_TS${y}_TS${T}_TL${w}`,$=i.resourceManager.cachedBufferState;let H=$[P];H||(H=$[P]=this.#ta(P,i,m,g,x,_,b,y,T,w)),this._setData(H)}}class Sphere extends Primitive{#ta=function(){let i,m,g,x,_,b,y,T,w=[],P=new Float32Array([0,0,0]),$=new Float32Array([0,0,0]);return function(H,z,q,W,ye,Ge,Ke,Xe,je,Ye){i=Xe+je,x=0,w.length=0,P[0]=0,P[1]=0,P[2]=0,$[0]=0,$[1]=0,$[2]=0;let Ze=[],Je=[];for(g=0;g<=ye;g++){let i=[],_=g/ye;for(m=0;m<=W;m++){let g=m/W;P.x=-q*Math.cos(Ge+g*Ke)*Math.sin(Xe+_*je),P.y=q*Math.cos(Xe+_*je),P.z=q*Math.sin(Ge+g*Ke)*Math.sin(Xe+_*je),Ze.push(P.x,P.y,P.z),$[0]=P.x,$[1]=P.y,$[2]=P.z,normalize$4($,$),Ze.push($[0],$[1],$[2]),Ze.push(g*Ye,_*Ye),i.push(x++)}w.push(i)}for(g=0;g<ye;g++)for(m=0;m<W;m++)_=w[g][m+1],b=w[g][m],y=w[g+1][m],T=w[g+1][m+1],(0!==g||Xe>0)&&Je.push(_,b,T),(g!==ye-1||i<Math.PI)&&Je.push(b,y,T);return createPrimitiveGeometry(z,Ze,Je,H)}}();constructor(i,m=1,g=16,x=16,_=0,b=2*Math.PI,y=0,T=Math.PI,w=1){super(i);const P=`PRIMITIVE_SPHERE_R${m}_WS${g}_HS${x}_PS${_}_PL${b}_TS${y}_TL${T}_UV${w}`,$=i.resourceManager.cachedBufferState;let H=$[P];H||(H=$[P]=this.#ta(P,i,m,g,x,_,b,y,T,w)),this._setData(H)}}class DrawDebuggerAxis extends Mesh{constructor(i){super(i,null,null);const m=new Mesh(i,new Sphere(i,.5),new ColorMaterial(i));this.addChild(m);const g=new Box(i);this.addChild(this.#ra(g,"#ff0000",[5,.1,.1],[2.5,0,0])),this.addChild(this.#na(i,"#ff0000",[.5,1.25],[5.5,0,0],[0,0,-90])),this.addChild(this.#ra(g,"#00ff00",[.1,5,.1],[0,2.5,0])),this.addChild(this.#na(i,"#00ff00",[.5,1.25],[0,5.5,0],[180,0,0])),this.addChild(this.#ra(g,"#0000ff",[.1,.1,5],[0,0,2.5])),this.addChild(this.#na(i,"#0000ff",[.5,1.25],[0,0,5.5],[90,0,0]))}#ra(i,m,g,x){const{redGPUContext:_}=this,b=new Mesh(_,i,new ColorMaterial(_,m));return b.setScale(...g),b.setPosition(...x),b}#na(i,m,g,x,_){const b=new Mesh(i,new Cylinder(i,g[0],.001,g[1],32,1),new ColorMaterial(i,m));return b.setScale(g[0],g[1],g[0]),b.setPosition(...x),b.setRotation(..._),b}}var Ei="#redgpu_include SYSTEM_UNIFORM;\r\nstruct VertexIn {\r@location(0) pos:vec4<f32>,\r@location(1) uv:vec2<f32>,\r\n}\r\n\r\nstruct VertexOut {\r@builtin(position) pos:vec4<f32>,\r@location(0) uv:vec2<f32>,\r\n}\r\n\r\n\r\n@vertex\r\nfn vertexMain(in:VertexIn) -> VertexOut {\rvar out:VertexOut;\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\r\rout.pos=u_projectionMatrix * u_cameraMatrix * in.pos;\rout.uv=in.uv;\rreturn out;\r\n}\r\n\r\nfn PristineGrid(uv:vec2<f32>,lineWidth:vec2<f32>) -> f32 {\rlet uvDDXY=vec4<f32>(dpdx(uv),dpdy(uv));\rlet uvDeriv=vec2<f32>(length(uvDDXY.xz),length(uvDDXY.yw));\rlet invertLine:vec2<bool>=lineWidth > vec2f(0.5);\rlet targetWidth:vec2<f32>=select(lineWidth,1 - lineWidth,invertLine);\rlet drawWidth:vec2<f32>=clamp(targetWidth,uvDeriv,vec2f(0.5));\rlet lineAA:vec2<f32>=uvDeriv * 1.5;\rvar gridUV:vec2<f32>=abs(fract(uv) * 2.0 - 1.0);\rgridUV=select(1 - gridUV,gridUV,invertLine);\rvar grid2:vec2<f32>=smoothstep(drawWidth + lineAA,drawWidth - lineAA,gridUV);\rgrid2 *=saturate(targetWidth/drawWidth);\rgrid2=mix(grid2,targetWidth,saturate(uvDeriv * 2.0 - 1.0));\rgrid2=select(grid2,1.0 - grid2,invertLine);\rreturn mix(grid2.x,1.0,grid2.y);\r\n}\r\n\r\n\r\nstruct GridArgs {\rlineColor:vec4<f32>,\rbaseColor:vec4<f32>,\rlineWidth:vec2<f32>,\rsize:f32,\rdistance:f32,\r\n}\r\n@group(1) @binding(0) var<uniform> gridArgs:GridArgs;\r\n\r\n@fragment\r\nfn fragmentMain(in:VertexOut) -> @location(0) vec4<f32> {\rvar lineWidthWeight:f32=1;\rvar color:vec4<f32>=gridArgs.lineColor;\rlet DIVISION_SIZE:f32=gridArgs.size;\rlet ASIX_SIZE:f32=max(DIVISION_SIZE * gridArgs.lineWidth.x,DIVISION_SIZE/20);\r\n\rlet HALF_DIVISION_SIZE:f32=DIVISION_SIZE * 0.5;\rlet PER_SIZE:f32=1/DIVISION_SIZE * ASIX_SIZE;\rlet MIN_RANGE=HALF_DIVISION_SIZE - PER_SIZE;\rlet MAX_RANGE=HALF_DIVISION_SIZE + PER_SIZE;\rif( MIN_RANGE <=in.uv.x && in.uv.x <=MAX_RANGE) {\rcolor=vec4<f32>(0,0,1,1);\rlineWidthWeight=ASIX_SIZE;\r}else if( MIN_RANGE <=in.uv.y && in.uv.y <=MAX_RANGE) {\rcolor=vec4<f32>(1,0,0,1);\rlineWidthWeight=ASIX_SIZE;\r}\rvar grid=PristineGrid(in.uv,gridArgs.lineWidth * lineWidthWeight);\r\n\r\n\rreturn mix(gridArgs.baseColor,color,grid * gridArgs.lineColor.a);\r\n;\r\n}\r\n";const Li=parseWGSL(Ei),Bi=Li.uniforms.gridArgs;class DrawDebuggerGrid{#T;#S;#ui;#ia;#ce;#aa;#pe;#ge;#sa;#K=100;#e;#a;#oa=1;constructor(i){validateRedGPUContext(i),this.#e=InstanceIdGenerator.getNextId(this.constructor);const{resourceManager:m,gpuDevice:g}=i,x={code:Ei},_=m.createGPUShaderModule("VERTEX_MODULE_GRID",x);this.#pe=new BlendState(this,cn.ONE,cn.ONE_MINUS_SRC_ALPHA,hn.ADD),this.#ge=new BlendState(this,cn.SRC_ALPHA,cn.ONE_MINUS_SRC_ALPHA,hn.ADD),this.#sa=new ColorRGBA(128,128,128,1);const b=m.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),y=i.resourceManager.getGPUBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT")||i.resourceManager.createBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(Li,1));this.#ua(i),this.#ia=g.createBindGroup({label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_GRID",layout:y,entries:[{binding:0,resource:{buffer:this.#ui.gpuBuffer,offset:0,size:this.#ui.size}}]});const T={label:"PIPELINE_DESCRIPTOR_GRID",layout:g.createPipelineLayout({bindGroupLayouts:[b,y]}),vertex:{module:_,entryPoint:"vertexMain",buffers:[{arrayStride:this.#T.interleavedStruct.arrayStride,attributes:this.#T.interleavedStruct.attributes}]},fragment:{module:_,entryPoint:"fragmentMain",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:this.#pe.state,alpha:this.#ge.state}}]},depthStencil:{format:"depth32float",depthWriteEnabled:!1,depthCompare:Qn.LESS_EQUAL}};this.#ce=g.createRenderPipeline(T),this.#aa=g.createRenderPipeline({...T,multisample:{count:4}})}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get size(){return this.#K}set size(i){this.#K=i}get lineColor(){return this.#sa}get lineWidth(){return this.#oa}set lineWidth(i){validatePositiveNumberRange(i),this.#oa=i}render(i){const{view:m,currentRenderPassEncoder:g}=i,x=create$4();set$4(x,m.rawCamera.x,m.rawCamera.y,m.rawCamera.z);const _=distance$2(x,[0,0,0]),b=this.#K;i.num3DObjects++,i.numDrawCalls++;const y=1/m.pixelRectObject.width*_*this.#oa;this.#ui.writeBuffers([[Bi.members.lineColor,this.#sa.rgbaNormal],[Bi.members.lineWidth,[y,y]],[Bi.members.size,b],[Bi.members.distance,_]]);const T=[-b/2,-0,-b/2,0,0,b/2,-0,-b/2,b,0,-b/2,-0,b/2,0,b,b/2,-0,b/2,b,b];if(this.#T.changeData(T),this.#ce){const{triangleCount:x,indexNum:_}=this.#S;g.setPipeline(m.redGPUContext.antialiasingManager.useMSAA?this.#aa:this.#ce),g.setBindGroup(1,this.#ia),g.setVertexBuffer(0,this.#T.gpuBuffer),g.setIndexBuffer(this.#S.gpuBuffer,"uint32"),g.drawIndexed(6),i.numTriangles+=x,i.numPoints+=_}}#ua(i){const m=this.#K,{resourceManager:g}=i,{cachedBufferState:x}=g;{const g="VertexBuffer_Grid",_=x[g],b=[-m,-0,-m,0,0,m,-0,-m,m,0,-m,-0,m,0,m,m,-0,m,m,m];x[g]=this.#T=_||new VertexBuffer(i,b,new InterleavedStruct({position:InterleaveType.float32x3,uv:InterleaveType.float32x2}),void 0,g)}{const m="IndexBuffer_Grid",g=x[m],_=[0,1,2,1,2,3];x[m]=this.#S=g||new IndexBuffer(i,_,void 0,m)}{const m="UniformBuffer_Grid",g=x[m],_=new ArrayBuffer(Bi.arrayBufferByteLength);x[m]=this.#ui=g||new UniformBuffer(i,_)}}}class DrawDebuggerDirectionalLight extends ADrawDebuggerLight{#$e;constructor(i,m){super(i,[255,255,0],8),this.#$e=m}#la(i,m){const g=[0,5,0],x=i.direction||[0,-1,0],_=Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]),b=[x[0]/_,x[1]/_,x[2]/_],y=[g[0]+3*b[0],g[1]+3*b[1],g[2]+3*b[2]],T=.3;let w=[0,1,0];Math.abs(b[1])>.99&&(w=[1,0,0]);const P=[b[1]*w[2]-b[2]*w[1],b[2]*w[0]-b[0]*w[2],b[0]*w[1]-b[1]*w[0]],$=Math.sqrt(P[0]*P[0]+P[1]*P[1]+P[2]*P[2]),H=[P[0]/$,P[1]/$,P[2]/$],z=[H[1]*b[2]-H[2]*b[1],H[2]*b[0]-H[0]*b[2],H[0]*b[1]-H[1]*b[0]],q=[[g,y],[y,[y[0]+-.5*b[0]+H[0]*T,y[1]+-.5*b[1]+H[1]*T,y[2]+-.5*b[2]+H[2]*T]],[y,[y[0]+-.5*b[0]-H[0]*T,y[1]+-.5*b[1]-H[1]*T,y[2]+-.5*b[2]-H[2]*T]],[y,[y[0]+-.5*b[0]+z[0]*T,y[1]+-.5*b[1]+z[1]*T,y[2]+-.5*b[2]+z[2]*T]],[y,[y[0]+-.5*b[0]-z[0]*T,y[1]+-.5*b[1]-z[1]*T,y[2]+-.5*b[2]-z[2]*T]],[[g[0]-.3,g[1],g[2]],[g[0]+.3,g[1],g[2]]],[[g[0],g[1]-.3,g[2]],[g[0],g[1]+.3,g[2]]],[[g[0],g[1],g[2]-.3],[g[0],g[1],g[2]+.3]]];this.updateVertexBuffer(q,m)}render(i){this.#$e.enableDebugger&&(this.#la(this.#$e,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i))}}Object.freeze(DrawDebuggerDirectionalLight);class BaseLight{#ca;#ha;drawDebugger;#Nr=!1;get enableDebugger(){return this.#Nr}set enableDebugger(i){this.#Nr=i}constructor(i,m=1){this.#ca=i,this.#ha=m}get color(){return this.#ca}set color(i){this.#ca=i}get intensity(){return this.#ha}set intensity(i){this.#ha=i}}Object.freeze(BaseLight);class AmbientLight extends BaseLight{constructor(i=new ColorRGB(7,7,7),m=.2){super(i,m)}}Object.freeze(AmbientLight);class DirectionalLight extends BaseLight{#fa=-1;#da=-1;#ma=-1;constructor(i=[-1,-1,-1],m="#fff",g=1){super(new ColorRGB(...convertHexToRgb(m,!0)),g),this.#fa=i[0],this.#da=i[1],this.#ma=i[2]}get directionX(){return this.#fa}set directionX(i){this.#fa=i}get directionY(){return this.#da}set directionY(i){this.#da=i}get directionZ(){return this.#ma}set directionZ(i){this.#ma=i}get direction(){return[this.#fa,this.#da,this.#ma]}set direction(i){this.#fa=i[0],this.#da=i[1],this.#ma=i[2]}}Object.freeze(DirectionalLight);class PointLight extends BaseLight{#pa=1;#r=0;#n=0;#i=0;constructor(i="#fff",m=1){super(new ColorRGB(...convertHexToRgb(i,!0)),m)}get x(){return this.#r}set x(i){this.#r=i}get y(){return this.#n}set y(i){this.#n=i}get z(){return this.#i}set z(i){this.#i=i}get position(){return[this.#r,this.#n,this.#i]}get radius(){return this.#pa}set radius(i){this.#pa=i}setPosition(i,m,g){Array.isArray(i)?[this.#r,this.#n,this.#i]=i:(this.#r=i,this.#n=m,this.#i=g)}}Object.freeze(PointLight);class SpotLight extends BaseLight{#pa=1;#r=0;#n=2;#i=0;#fa=0;#da=-1;#ma=0;#ga=15;#xa=22.5;constructor(i="#fff",m=1){super(new ColorRGB(...convertHexToRgb(i,!0)),m)}get x(){return this.#r}set x(i){this.#r=i}get y(){return this.#n}set y(i){this.#n=i}get z(){return this.#i}set z(i){this.#i=i}get position(){return[this.#r,this.#n,this.#i]}get radius(){return this.#pa}set radius(i){this.#pa=i}get directionX(){return this.#fa}set directionX(i){this.#fa=i}get directionY(){return this.#da}set directionY(i){this.#da=i}get directionZ(){return this.#ma}set directionZ(i){this.#ma=i}get direction(){return[this.#fa,this.#da,this.#ma]}set direction(i){this.#fa=i[0],this.#da=i[1],this.#ma=i[2]}get innerCutoff(){return this.#ga}set innerCutoff(i){this.#ga=i}get outerCutoff(){return this.#xa}set outerCutoff(i){this.#xa=i}get innerCutoffCos(){return Math.cos(this.#ga*Math.PI/180)}get outerCutoffCos(){return Math.cos(this.#xa*Math.PI/180)}setPosition(i,m,g){Array.isArray(i)?[this.#r,this.#n,this.#i]=i:(this.#r=i,this.#n=m,this.#i=g)}lookAt(i,m,g){let x,_,b;Array.isArray(i)?[x,_,b]=i:(x=i,_=m,b=g);const y=x-this.#r,T=_-this.#n,w=b-this.#i,P=Math.sqrt(y*y+T*T+w*w);P>0&&(this.#fa=y/P,this.#da=T/P,this.#ma=w/P)}}Object.freeze(SpotLight);class LightManager{#_a=3;#va=an.MAX_CLUSTER_LIGHTS;#ba=[];#ya=[];#Ta=[];#Sa=new AmbientLight;#wa=create$5();get spotLights(){return this.#Ta}get spotLightCount(){return this.#Ta.length}get limitClusterLightCount(){return this.#va}get pointLights(){return this.#ya}get pointLightCount(){return this.#ya.length}get limitDirectionalLightCount(){return this.#_a}get directionalLightCount(){return this.#ba.length}get directionalLights(){return this.#ba}get ambientLight(){return this.#Sa}set ambientLight(i){i instanceof AmbientLight||consoleAndThrowError("allow only AmbientLight instance"),this.#Sa=i}addSpotLight(i){i instanceof SpotLight||consoleAndThrowError("allow only SpotLight instance");this.#Ta.length+this.#ya.length>this.#va&&consoleAndThrowError("Cannot add more cluster lights. The limit has been reached."),this.#Ta.push(i)}addPointLight(i){i instanceof PointLight||consoleAndThrowError("allow only PointLight instance");this.#Ta.length+this.#ya.length>this.#va&&consoleAndThrowError("Cannot add more cluster lights. The limit has been reached."),this.#ya.push(i)}addDirectionalLight(i){i instanceof DirectionalLight||consoleAndThrowError("allow only DirectionalLight instance");this.#ba.length>this.#_a&&consoleAndThrowError("Cannot add more directional lights. The limit has been reached."),this.#ba.push(i)}removeSpotLight(i){const m=this.#Ta.indexOf(i);-1!==m&&this.#Ta.splice(m,1)}removePointLight(i){const m=this.#ya.indexOf(i);-1!==m&&this.#ya.splice(m,1)}removeDirectionalLight(i){const m=this.#ba.indexOf(i);-1!==m&&this.#ba.splice(m,1)}removeAllSpotLight(){this.#Ta=[]}removeAllPointLight(){this.#ya=[]}removeAllDirectionalLight(){this.#ba=[]}removeAllLight(){this.removeAllPointLight(),this.removeAllSpotLight(),this.removeAllDirectionalLight(),this.#Sa=null}updateViewSystemUniforms(i){const{scene:m,redGPUContext:g}=i,x=i.systemUniform_Vertex_StructInfo,{systemUniform_Vertex_UniformBuffer:_}=i,{members:b}=x,{lightManager:y,shadowManager:T}=m,{directionalShadowManager:w}=T;if(_.writeBuffers([[b.directionalLightCount,y.directionalLightCount],[b.directionalLightProjectionViewMatrix,this.#Ma(i)],[b.directionalLightProjectionMatrix,this.#Ra(i)],[b.directionalLightViewMatrix,this.#Pa(i)],[b.shadowDepthTextureSize,w.shadowDepthTextureSize],[b.bias,w.bias]]),y.directionalLights.forEach((m,x)=>{const{directionalLights:y}=b,{direction:T,color:w,intensity:P}=y.memberList[x];m.enableDebugger&&(m.drawDebugger||(m.drawDebugger=new DrawDebuggerDirectionalLight(g,m)),m.drawDebugger.render(i.debugViewRenderState)),_.writeBuffers([[T,m.direction],[w,m.color.rgbNormal],[P,m.intensity]])}),y.ambientLight){const m=i.scene.lightManager.ambientLight,{ambientLight:g}=b,{color:x,intensity:y}=g.members;_.writeBuffers([[x,m.color.rgbNormal],[y,m.intensity]])}}#Ma(i){return multiply$5(create$5(),this.#Ra(i),this.#Pa(i))}#Ra(i){const m=create$5(),g=i.rawCamera instanceof Camera2D?fromValues$4(0,0,0):fromValues$4(i.rawCamera.x,i.rawCamera.y,i.rawCamera.z),x=Math.max(distance$2(g,create$4()),1);return ye(m,-x,x,-x,x,3*-x,3*x),m}#Pa(i){identity$2(this.#wa);const m=i.rawCamera instanceof Camera2D?fromValues$4(0,0,0):fromValues$4(i.rawCamera.x,i.rawCamera.y,i.rawCamera.z),g=Math.max(distance$2(m,create$4()),1),x=fromValues$4(0,1,0),_=fromValues$4(0,0,0),b=i.scene.lightManager.directionalLights.length?fromValues$4(-i.scene.lightManager.directionalLights[0].direction[0]*g,-i.scene.lightManager.directionalLights[0].direction[1]*g,-i.scene.lightManager.directionalLights[0].direction[2]*g):create$4(),y=create$5();return lookAt(y,b,_,x),y}}Object.freeze(LightManager);class DirectionalShadowManager{#Ca=2048;#Ia=.005;#Ea;#La;#Ba;#_;#kn=[];get castingList(){return this.#kn}get shadowDepthTextureView(){return this.#La}get shadowDepthTextureViewEmpty(){return this.#Ba}get bias(){return this.#Ia}set bias(i){validatePositiveNumberRange(i,0,1),this.#Ia=i}get shadowDepthTextureSize(){return this.#Ca}set shadowDepthTextureSize(i){validateUintRange(i,1),this.#Ca=i,this.#Da()}resetCastingList(){this.#kn.length=0}updateViewSystemUniforms(i){this.#_=i,this.#Da()}destroy(){this.#Ea&&(this.#Ea.destroy(),this.#Ea=null,this.#La=null)}#Da(){this.#Ea?.width!==this.#Ca&&(this.destroy(),this.#Ua())}#Aa(i){const m=i.createTexture({size:[1,1,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float",label:`DirectionalShadowManager_EmptyDepthTexture_1x1_${Date.now()}`});this.#Ba=m.createView({label:m.label})}#Ua(){const{gpuDevice:i}=this.#_;this.#Ea=i.createTexture({size:[this.#Ca,this.#Ca,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float",label:`DirectionalShadowManager_shadowDepthTextureSize_${this.#Ca}x${this.#Ca}_${Date.now()}`}),this.#La=this.#Ea.createView({label:this.#Ea.label}),this.#Ba||this.#Aa(i)}}Object.freeze(DirectionalShadowManager);class ShadowManager{#ka=new DirectionalShadowManager;constructor(){}get directionalShadowManager(){return this.#ka}}Object.freeze(ShadowManager);class Scene extends Object3DContainer{#e;#a;#Oa=new ColorRGBA;#Na=!1;#Fa=new LightManager;#Ga=new ShadowManager;constructor(i){super(),this.#e=InstanceIdGenerator.getNextId(this.constructor),this.#a=i}get lightManager(){return this.#Fa}get shadowManager(){return this.#Ga}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get backgroundColor(){return this.#Oa}set backgroundColor(i){i instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#Oa=i}get useBackgroundColor(){return this.#Na}set useBackgroundColor(i){this.#Na=i}}class ViewRenderTextureManager{#Va;#$a;#Ha;#za;#qa;#Ka;#Wa;#Xa;#ja;#Ya=!0;#Za=!0;#_;#Sn;constructor(i){validateRedGPUContext(i.redGPUContext),this.#_=i.redGPUContext,this.#Sn=i}get renderPath1ResultTextureDescriptor(){return this.#za}get colorTexture(){return this.#Va}get colorResolveTexture(){return this.#qa}get depthTexture(){return this.#Ka}get depthTextureView(){return this.#Ja("depth"),this.#ja}get colorTextureView(){return this.#Ja("color"),this.#Wa}get colorResolveTextureView(){return this.#Xa}get renderPath1ResultTextureView(){return this.#Ha}get renderPath1ResultTexture(){return this.#Qa(),this.#$a}#Qa(){const{gpuDevice:i}=this.#_,m=this.#$a,{pixelRectObject:g}=this.#Sn,{width:x,height:_}=g;(!m||(m?.width!==x||m?.height!==_))&&(m&&(m?.destroy(),this.#$a=null,this.#Ha=null),this.#za={size:{width:Math.max(1,x),height:Math.max(1,_),depthOrArrayLayers:1},format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,mipLevelCount:getMipLevelCount(x,_),label:`renderPath1ResultTexture_${x}x${_}_${Date.now()}`},this.#$a=i.createTexture(this.#za),this.#Ha=this.#$a.createView({label:this.#$a.label}))}#Ja(i){const m="depth"===i,{antialiasingManager:g,gpuDevice:x}=this.#_,{useMSAA:_}=g,b=m?this.#Ka:this.#Va,{pixelRectObject:y}=this.#Sn,{width:T,height:w}=y,P=b?.width!==T||b?.height!==w,$=m?this.#Za!==_:this.#Ya!==_,H=!b||P||$;if(m?this.#Za=_:this.#Ya=_,H){b&&(b?.destroy(),m||(this.#qa?.destroy(),this.#qa=null,this.#Xa=null));const g=x.createTexture({size:[Math.max(T,1),Math.max(w,1),1],sampleCount:_?4:1,label:`${i}_${T}x${w}_${Date.now()}`,format:m?"depth32float":navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|(m||_?0:GPUTextureUsage.COPY_SRC)});if(m)this.#Ka=g,this.#ja=g.createView({label:g.label});else if(this.#Va=g,this.#Wa=g.createView({label:g.label}),_){const m=x.createTexture({size:{width:Math.max(T,1),height:Math.max(w,1),depthOrArrayLayers:1},sampleCount:1,label:`${i}_resolve_${T}x${w}_${Date.now()}`,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});this.#qa=m,this.#Xa=m.createView({label:m.label})}}}}Object.freeze(ViewRenderTextureManager);class ViewTransform{onResize=null;#_;#es=create$5();#Fr;#r=0;#n=0;#pn;#gn;#xn=[0,0,0,0];constructor(i){validateRedGPUContext(i),this.#_=i}get redGPUContext(){return this.#_}get camera(){return this.#Fr}set camera(i){i instanceof PerspectiveCamera||i instanceof Camera2D||i instanceof Camera2D||i instanceof OrthographicCamera||i instanceof AController||consoleAndThrowError("allow PerspectiveCamera or OrthographicCamera or AController instance"),this.#Fr=i}get x(){return this.#r}set x(i){this.setPosition(i,this.y)}get y(){return this.#n}set y(i){this.setPosition(this.x,i)}get width(){return this.#pn}set width(i){this.setSize(i,this.#gn)}get height(){return this.#gn}set height(i){this.setSize(this.#pn,i)}get pixelRectArray(){return this.#xn}get pixelRectObject(){return{x:this.#xn[0],y:this.#xn[1],width:this.#xn[2],height:this.#xn[3]}}get screenRectObject(){return{x:this.#xn[0]/devicePixelRatio,y:this.#xn[1]/devicePixelRatio,width:this.#xn[2]/devicePixelRatio,height:this.#xn[3]/devicePixelRatio}}get aspect(){return this.#xn[2]/this.#xn[3]}get frustumPlanes(){return this.#Fr instanceof AController?computeViewFrustumPlanes(this.projectionMatrix,this.#Fr.camera.modelMatrix):computeViewFrustumPlanes(this.projectionMatrix,this.#Fr.modelMatrix)}get rawCamera(){return this.#Fr instanceof AController?this.#Fr.camera:this.#Fr}get projectionMatrix(){const{pixelRectObject:i,redGPUContext:m}=this;if(this.rawCamera instanceof OrthographicCamera){const{nearClipping:i,farClipping:m}=this.rawCamera;orthoZO(this.#es,this.rawCamera.left,this.rawCamera.right,this.rawCamera.bottom,this.rawCamera.top,i,m)}else if(this.rawCamera instanceof Camera2D)ye(this.#es,-.5,.5,-.5,.5,-1e5,1e5),scale$5(this.#es,this.#es,[m.renderScale,m.renderScale,1]),translate$1(this.#es,this.#es,[-.5,.5,0]),scale$5(this.#es,this.#es,[1/i.width*window.devicePixelRatio,-1/i.height*window.devicePixelRatio,1]),identity$2(this.rawCamera.modelMatrix);else{const{fieldOfView:i,nearClipping:m,farClipping:g}=this.rawCamera;W(this.#es,Math.PI/180*i,this.aspect,m,g)}return this.#es}get inverseProjectionMatrix(){return invert$2(create$5(),this.#es)}setPosition(i=this.#r,m=this.#n){const{sizeManager:g}=this.#_;RedGPUContextSizeManager.validatePositionValue(i),RedGPUContextSizeManager.validatePositionValue(m),this.#r=i,this.#n=m;const x=g.pixelRectObject,_=RedGPUContextSizeManager.getPixelDimension(x,"width",i),b=RedGPUContextSizeManager.getPixelDimension(x,"height",m);this.#xn[0]=Math.floor(_*(this.#r.toString().includes("%")?1:g.renderScale*window.devicePixelRatio)),this.#xn[1]=Math.floor(b*(this.#n.toString().includes("%")?1:g.renderScale*window.devicePixelRatio))}setSize(i=this.#pn,m=this.#gn){const{sizeManager:g}=this.#_;RedGPUContextSizeManager.validateSizeValue(i),RedGPUContextSizeManager.validateSizeValue(m),this.#pn=i,this.#gn=m;const x=g.pixelRectObject,_=RedGPUContextSizeManager.getPixelDimension(x,"width",i),b=RedGPUContextSizeManager.getPixelDimension(x,"height",m);this.#xn[2]=Math.floor(_*(this.#pn.toString().includes("%")?1:g.renderScale*window.devicePixelRatio)),this.#xn[3]=Math.floor(b*(this.#gn.toString().includes("%")?1:g.renderScale*window.devicePixelRatio)),this.onResize&&this.onResize(this.screenRectObject.width,this.screenRectObject.height)}}const Di=parseWGSL(sn.SYSTEM_UNIFORM).uniforms.systemUniforms;class View3D extends ViewTransform{#ts=Di;#rs;#ns;#e;#is;#as;#ss;#a;#os;#us=!0;#ls=!1;#cs=50;#hs;#fs;#ds;#ms;#ps=new PickingManager;#gs=[];#xs;#Gt;#Ln;#_s;#vs;#bs;#ys=void 0;#Ts=void 0;constructor(i,m,g,x){super(i),this.scene=m,this.camera=g,x&&(this.name=x),this.#Vi(),this.#ms=new ViewRenderTextureManager(this),this.#fs=new RenderViewStateData(this),this.#ds=new PostEffectManager(this),this.setSize("100%","100%")}get viewRenderTextureManager(){return this.#ms}get systemUniform_Vertex_StructInfo(){return this.#ts}get systemUniform_Vertex_UniformBindGroup(){return this.#rs}get systemUniform_Vertex_UniformBuffer(){return this.#ns}get passLightClustersBound(){return this.#bs}get ibl(){return this.#hs}set ibl(i){this.#hs=i}get pickingManager(){return this.#ps}get postEffectManager(){return this.#ds}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get debugViewRenderState(){return this.#fs}get grid(){return this.#is}set grid(i){if("boolean"==typeof i)i=!0===i?new DrawDebuggerGrid(this.redGPUContext):null;else if(!(i instanceof DrawDebuggerGrid)&&null!==i)throw new TypeError("grid must be of type 'DrawDebuggerGrid','boolean',or 'null'.");this.#is=i}get axis(){return this.#as}set axis(i){if("boolean"==typeof i)i=!0===i?new DrawDebuggerAxis(this.redGPUContext):null;else if(!(i instanceof DrawDebuggerAxis)&&null!==i)throw new TypeError("axis must be of type 'DrawDebuggerAxis','boolean',or 'null'.");this.#as=i}get skybox(){return this.#ss}set skybox(i){this.#ss=i}get useFrustumCulling(){return this.#us}set useFrustumCulling(i){this.#us=i}get useDistanceCulling(){return this.#ls}set useDistanceCulling(i){this.#ls=i}get distanceCulling(){return this.#cs}set distanceCulling(i){this.#cs=i}get scene(){return this.#os}set scene(i){i instanceof Scene||consoleAndThrowError("allow only Scene instance"),this.#os=i}update(i,m=!1,g=!1,x){const{scene:_}=i,{shadowManager:b}=_,{directionalShadowManager:y}=b,T=i.ibl,w=T?.environmentTexture?.gpuTexture,P=T?.irradianceTexture?.gpuTexture;let $=m?y.shadowDepthTextureViewEmpty:y.shadowDepthTextureView;const H=i.redGPUContext.viewList.indexOf(i),z=`${H}_${m?"shadowRender":"basic"}_2path${!!x}`;if(H>-1){let m=!0,g=this.#gs[z];g&&(m=g.ibl!==T||g.ibl_environmentTexture!==w||g.ibl_irradianceTexture!==P||g.renderPath1ResultTextureView!==x||g.shadowDepthTextureView!==$||!this.#vs),m?this.#Ss(z,$,i.ibl,x):this.#rs=this.#gs[z].vertexUniformBindGroup,[{key:"useIblTexture",value:[w?1:0]},{key:"time",value:[i.debugViewRenderState.timestamp||0]},{key:"isView3D",value:[this.constructor===View3D?1:0]}].forEach(({key:i,value:m})=>{this.redGPUContext.gpuDevice.queue.writeBuffer(this.#ns.gpuBuffer,this.#ts.members[i].uniformOffset,new this.#ts.members[i].View(m))}),this.#gs[z]={ibl:T,ibl_environmentTexture:w,ibl_irradianceTexture:P,renderPath1ResultTextureView:x,shadowDepthTextureView:$,vertexUniformBindGroup:this.#rs}}this.#ws(g)}checkMouseInViewBounds(){const{pixelRectObject:i,pickingManager:m}=this,{mouseX:g,mouseY:x}=m;return 0<g&&g<i.width&&0<x&&x<i.height}#Ss(i,m,g,x){this.#ws(!0);const _=g?.environmentTexture,b=g?.irradianceTexture,y={layout:this.redGPUContext.resourceManager.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),label:`SYSTEM_UNIFORM_bindGroup_${i}`,entries:[{binding:0,resource:{buffer:this.#ns.gpuBuffer,offset:0,size:this.#ns.size}},{binding:1,resource:this.#xs},{binding:2,resource:m},{binding:3,resource:this.#Gt},{binding:5,resource:{buffer:this.#Ln,offset:0,size:this.#Ln.size}},{binding:6,resource:{buffer:this.#vs.clusterLightsBuffer,offset:0,size:this.#vs.clusterLightsBuffer.size}},{binding:7,resource:this.#Gt},{binding:8,resource:x||this.redGPUContext.resourceManager.emptyBitmapTextureView},{binding:9,resource:this.#Gt},{binding:10,resource:_?.gpuTexture?.createView(_?.viewDescriptor||CubeTexture.defaultViewDescriptor)||this.redGPUContext.resourceManager.emptyCubeTextureView},{binding:11,resource:b?.gpuTexture?.createView(b?.viewDescriptor||CubeTexture.defaultViewDescriptor)||this.redGPUContext.resourceManager.emptyCubeTextureView}]};this.#rs=this.redGPUContext.gpuDevice.createBindGroup(y)}#Vi(){const i=new ArrayBuffer(Di.arrayBufferByteLength);this.#ns=new UniformBuffer(this.redGPUContext,i,"#systemUniform_Vertex_UniformBuffer"),this.#_s=new Float32Array(16*an.MAX_CLUSTER_LIGHTS+4),this.#Ln=this.redGPUContext.gpuDevice.createBuffer({label:"clusterLightsBuffer",size:this.#_s.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#Ln,0,this.#_s),this.#xs=new Sampler(this.redGPUContext,{addressModeU:An.CLAMP_TO_EDGE,addressModeV:An.CLAMP_TO_EDGE,addressModeW:An.CLAMP_TO_EDGE,compare:Qn.LESS_EQUAL}).gpuSampler,this.#Gt=new Sampler(this.redGPUContext).gpuSampler}#ws(i=!1){if(!i)return;const{redGPUContext:m,scene:g,debugViewRenderState:x}=this;if(this.#bs||(this.#bs=new PassClusterLightBound(m,this)),this.#vs&&(this.#bs.render(),this.#ys=this.pixelRectArray[2],this.#Ts=this.pixelRectArray[3]),this.#vs||(this.#vs=new PassClustersLight(m,this)),g){const{pointLights:i,spotLights:_}=g.lightManager,b=i.length,y=_.length;if(b){let g=b;for(;g--;){const _=i[g],b=4+16*g;this.#_s.set([..._.position,_.radius,..._.color.rgbNormal,_.intensity,0],b),_.enableDebugger&&(_.drawDebugger||(_.drawDebugger=new DrawDebuggerPointLight(m,_)),_.drawDebugger.render(x))}}if(y){const i=16,g=b*i;let T=y;for(;T--;){const b=_[T],y=4+i*T+g;this.#_s.set([...b.position,b.radius,...b.color.rgbNormal,b.intensity,1,...b.direction,b.outerCutoff,b.innerCutoff],y),b.enableDebugger&&(b.drawDebugger||(b.drawDebugger=new DrawDebuggerSpotLight(m,b)),b.drawDebugger.render(x))}}this.#_s.set([b,y,0,0],0),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#Ln,0,this.#_s),this.#vs.render()}}}Object.freeze(View3D);class RedGPUContextViewContainer{#Ms=[];constructor(){}get viewList(){return this.#Ms}get numViews(){return this.#Ms.length}contains(i){return this.#Ms.includes(i)}addView(i){this.#Rs(i),this.#Ms.push(i)}addViewAt(i,m){this.#Rs(i),validateUintRange(m);const g=this.#Ms.length;g<m&&(m=g),this.#Ms[m]=i}getViewAt(i){return validateUintRange(i),this.#Ms[i]}getViewIndex(i){return this.#Rs(i),this.#Ms.indexOf(i)}setViewIndex(i,m){this.#Rs(i),validateUintRange(m);const g=this.#Ms.length,x=m>=g,_=this.#Ms.indexOf(i);-1===_&&consoleAndThrowError("입력하신 View 는 RedGPUContext instance 에 등록되지 않은 View 입니다."),x&&consoleAndThrowError(`index must be smaller than the viewList length./index:${m}/this.#viewList.length:${g}`),this.#Ms.splice(_,1),this.#Ms.splice(m,0,i)}swapViews(i,m){this.#Rs(i),this.#Rs(m);const g=this.#Ms.indexOf(i),x=this.#Ms.indexOf(m);-1!==g&&-1!==x||consoleAndThrowError((-1===g?"view1":"view2")+" is not child of this RedGPUContext instance."),this.swapViewsAt(g,x)}swapViewsAt(i,m){i===m&&consoleAndThrowError("The indices to swap cannot be the same."),validateUintRange(i),validateUintRange(m);const g=this.#Ms.length;(i>=g||m>=g)&&consoleAndThrowError(`index1,index2 must be smaller than the viewList length./index1:${i}/index2:${m}/this.#viewList.length:${g}`);const x=this.#Ms[i];this.#Ms[i]=this.#Ms[m],this.#Ms[m]=x}removeView(i){this.#Rs(i);const m=this.#Ms.indexOf(i);m>-1?this.#Ms.splice(m,1):consoleAndThrowError("View3D is not found in the view list.")}removeViewAt(i){validateUintRange(i);const m=this.#Ms.length;i<m?this.#Ms.splice(i,1):consoleAndThrowError(`Index ${i} is out of range. View list length is ${m}.`)}removeAllViews(){this.#Ms.length=0}#Rs(i){i instanceof View3D||consoleAndThrowError("allow only View3D instance")}}class RedGPUContextDetector{#Ps;#Cs;#Is;#Es;#Ls;constructor(i){this.#Vi(i.gpuAdapter)}get adapterInfo(){return this.#Ps}get limits(){return this.#Cs}get isFallbackAdapter(){return this.#Is}get groupedLimits(){return this.#Es}get userAgent(){return this.#Ls}get isMobile(){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone|Kindle|Silk|PlayBook/i.test(navigator.userAgent)}#Vi(i){this.#Ls=navigator.userAgent,this.#Bs(i),this.#Ds()}#Bs(i){if(i){const{limits:m,info:g}=i,{isFallbackAdapter:x}=g;this.#Ps=g,this.#Is=x,this.#Cs=m}}#Ds(){const i={TextureLimits:["maxTextureDimension1D","maxTextureDimension2D","maxTextureDimension3D","maxTextureArrayLayers","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage"],BufferLimits:["maxBindGroups","maxBindGroupsPlusVertexBuffers","maxBindingsPerBindGroup","maxDynamicUniformBuffersPerPipelineLayout","maxDynamicStorageBuffersPerPipelineLayout","maxStorageBuffersPerShaderStage","maxStorageTexturesPerShaderStage","maxUniformBuffersPerShaderStage","maxUniformBufferBindingSize","maxStorageBufferBindingSize","minUniformBufferOffsetAlignment","minStorageBufferOffsetAlignment","maxBufferSize"],PipelineAndShaderLimits:["maxVertexBuffers","maxVertexAttributes","maxVertexBufferArrayStride","maxInterStageShaderComponents","maxInterStageShaderVariables"],ComputeLimits:["maxComputeWorkgroupStorageSize","maxComputeInvocationsPerWorkgroup","maxComputeWorkgroupSizeX","maxComputeWorkgroupSizeY","maxComputeWorkgroupSizeZ","maxComputeWorkgroupsPerDimension"],ColorLimits:["maxColorAttachments","maxColorAttachmentBytesPerSample"]};let m={TextureLimits:{},BufferLimits:{},PipelineAndShaderLimits:{},ComputeLimits:{},ColorLimits:{},EtcLimit:{}};for(const g in this.#Cs){let x=!1;for(const _ in i)if(i[_].includes(g)){m[_][g]=this.#Cs[g],x=!0;break}x||(m.EtcLimit[g]=this.#Cs[g])}this.#Es=m}}class AntialiasingManager{#_;#Us=!0;#As=!1;#ks=.75;#Os=.166;#Ns=.0833;#Fs=!0;constructor(i){this.#_=i}get fxaa_subpix(){return this.#ks}set fxaa_subpix(i){validateNumberRange(i,0,1),this.#ks=i}get fxaa_edgeThreshold(){return this.#Os}set fxaa_edgeThreshold(i){validateNumberRange(i,1e-4,.25),this.#Os=i}get fxaa_edgeThresholdMin(){return this.#Ns}set fxaa_edgeThresholdMin(i){validateNumberRange(i,1e-5,.1),this.#Ns=i}get useMSAA(){return this.#Us}set useMSAA(i){this.#Us=i,this.#Fs=!0}get useFXAA(){return this.#As}set useFXAA(i){this.#As=i}get changedMSAA(){return this.#Fs}set changedMSAA(i){this.#Fs=i}}Object.freeze(AntialiasingManager);class RedGPUContext extends RedGPUContextViewContainer{currentRequestAnimationFrame;onResize=null;#Gs;#Vs;#$s;#Hs;#v;#_n;#zs;#qs;#xe;#Oa=new ColorRGBA(0,0,0,1);#Ks=!1;#Ws={};#bi;constructor(i,m,g,x,_){super(),this.#Vs=m,this.#v=g,this.#Hs=x,this.#$s=_,this.#_n=i,this.#zs=new RedGPUContextSizeManager(this),this.#qs=new RedGPUContextDetector(this),this.#xe=new ResourceManager(this),this.#bi=new AntialiasingManager(this),this.#Xs()}get antialiasingManager(){return this.#bi}get useDebugPanel(){return this.#Ks}set useDebugPanel(i){this.#Ks=i}get backgroundColor(){return this.#Oa}set backgroundColor(i){i instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#Oa=i}get detector(){return this.#qs}get configurationDescription(){return this.#Gs}get gpuAdapter(){return this.#Vs}get alphaMode(){return this.#$s}set alphaMode(i){this.#$s=i,this.#js()}get gpuContext(){return this.#Hs}get gpuDevice(){return this.#v}get htmlCanvas(){return this.#_n}get keyboardKeyBuffer(){return this.#Ws}set keyboardKeyBuffer(i){this.#Ws=i}get resourceManager(){return this.#xe}get sizeManager(){return this.#zs}get width(){return this.#zs.width}set width(i){this.#zs.width=i}get height(){return this.#zs.height}set height(i){this.#zs.height=i}get screenRectObject(){return this.#zs.screenRectObject}get renderScale(){return this.#zs.renderScale}set renderScale(i){this.#zs.renderScale=i,this.viewList.forEach(i=>{i.setPosition(),i.setSize()})}destroy(){this.#v.destroy()}setSize(i=this.width,m=this.height){this.sizeManager.setSize(i,m)}#Xs(){this.#js(),this.sizeManager.setSize("100%","100%"),window?.addEventListener("resize",()=>{this.sizeManager.setSize(),this.viewList.forEach(i=>{i.setSize(),i.setPosition()})});(this.detector.isMobile?["click","touchmove","touchstart","touchend"]:["click","mousemove","mousedown","mouseup"]).forEach(i=>{const m=this.detector.isMobile?{click:Mi.CLICK,touchmove:Mi.MOVE,touchstart:Mi.DOWN,touchend:Mi.UP}:{click:Mi.CLICK,mousemove:Mi.MOVE,mousedown:Mi.DOWN,mouseup:Mi.UP};this.#_n.addEventListener(i,i=>{const g=m[i.type];this.viewList.forEach(m=>{this.detector.isMobile&&i instanceof TouchEvent&&i.touches.length>0?(m.pickingManager.mouseX=i.touches[0].clientX*devicePixelRatio-m.pixelRectObject.x,m.pickingManager.mouseY=i.touches[0].clientY*devicePixelRatio-m.pixelRectObject.y):i instanceof MouseEvent&&(m.pickingManager.mouseX=i.offsetX*devicePixelRatio-m.pixelRectObject.x,m.pickingManager.mouseY=i.offsetY*devicePixelRatio-m.pixelRectObject.y),g===Mi.CLICK?m.pickingManager.lastMouseClickEvent={...i,type:g}:m.pickingManager.lastMouseEvent={...i,type:g}})})});{const HD_keyDown=i=>{this.#Ws[i.key]=!0},HD_keyUp=i=>{this.#Ws[i.key]=!1};window?.addEventListener("keyup",HD_keyUp),window?.addEventListener("keydown",HD_keyDown)}new ResizeObserver(i=>{}).observe(this.#_n)}#js(){const i=navigator.gpu.getPreferredCanvasFormat();this.#Gs={device:this.#v,format:i,alphaMode:this.#$s},this.#Hs.configure(this.#Gs)}}Object.freeze(RedGPUContext);const copyGPUBuffer=(i,m,g)=>{const x=i.createCommandEncoder();x.copyBufferToBuffer(m,0,g,0,Math.min(m.size,g.size));const _=x.finish();i.queue.submit([_])},Ui=3.141592653589793,Ai=6.283185307179586,ki=.225,Oi=1.27323954,Ni=.405284735,Fi=1.5707963267948966,Gi=Math.PI/180;class InstancingMeshObject3D{modelMatrix=create$5();localMatrix=create$5();normalModelMatrix=create$5();inited=!1;#r=0;#i=0;#n=0;#Sr=[0,0,0];#Cr=1;#Ir=1;#Er=1;#Lr=[1,1,1];#o=0;#u=0;#l=0;#Br=[0,0,0];#Ys=0;#Zs;#_;#kr=1;constructor(i,m,g){validateRedGPUContext(i),this.#_=i,this.#Zs=g,this.#Ys=m}get opacity(){return this.#kr}set opacity(i){validatePositiveNumberRange(i,0,1),this.#kr=i,this.#Js()}get x(){return this.#r}set x(i){this.#r=this.#Sr[0]=i,this.#Js()}get y(){return this.#n}set y(i){this.#n=this.#Sr[1]=i,this.#Js()}get z(){return this.#i}set z(i){this.#i=this.#Sr[2]=i,this.#Js()}get position(){return this.#Sr}set position(i){this.#r=this.#Sr[0]=i,this.#n=this.#Sr[1]=i,this.#i=this.#Sr[2]=i,this.#Js()}get scaleX(){return this.#Cr}set scaleX(i){this.#Cr=this.#Lr[0]=i,this.#Js()}get scaleY(){return this.#Ir}set scaleY(i){this.#Ir=this.#Lr[1]=i,this.#Js()}get scaleZ(){return this.#Er}set scaleZ(i){this.#Er=this.#Lr[2]=i,this.#Js()}get scale(){return this.#Sr}set scale(i){this.#Cr=this.#Lr[0]=i,this.#Ir=this.#Lr[1]=i,this.#Er=this.#Lr[2]=i,this.#Js()}get rotationX(){return this.#o}set rotationX(i){this.#o=this.#Br[0]=i,this.#Js()}get rotationY(){return this.#u}set rotationY(i){this.#u=this.#Br[1]=i,this.#Js()}get rotationZ(){return this.#l}set rotationZ(i){this.#l=this.#Br[2]=i,this.#Js()}get rotation(){return this.#Br}set rotation(i){this.#o=this.#Br[0]=i,this.#u=this.#Br[1]=i,this.#l=this.#Br[2]=i,this.#Js()}setScale(i,m,g){m=m??i,g=g??i;const x=this.#Lr;this.#Cr=x[0]=i,this.#Ir=x[1]=m,this.#Er=x[2]=g,this.#Js()}setPosition(i,m,g){m=m??i,g=g??i;const x=this.#Sr;this.#r=x[0]=i,this.#n=x[1]=m,this.#i=x[2]=g,this.#Js()}setRotation(i,m,g){m=m??i,g=g??i;const x=this.#Br;this.#o=x[0]=i,this.#u=x[1]=m,this.#l=x[2]=g,this.#Js()}#Js(){let i,m,g,x,_,b,y,T,w,P,$,H,z,q,W,ye,Ge,Ke,Xe,je,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt,vt,bt,yt,Tt,St,wt,Mt,Rt;this.inited=!0;{const z=this.localMatrix;let Ge;P=1,$=0,H=0,q=0,W=1,ye=0,Ke=0,Xe=0,je=1,z[12]=this.#r,z[13]=this.#n,z[14]=this.#i,z[15]=1,y=this.#o*Gi,T=this.#u*Gi,w=this.#l*Gi,Ge=y%Ai,Ge<-Ui?Ge+=Ai:Ge>Ui&&(Ge-=Ai),Ge=Ge<0?Oi*Ge+Ni*Ge*Ge:Oi*Ge-Ni*Ge*Ge,i=Ge<0?ki*(Ge*-Ge-Ge)+Ge:ki*(Ge*Ge-Ge)+Ge,Ge=(y+Fi)%Ai,Ge<-Ui?Ge+=Ai:Ge>Ui&&(Ge-=Ai),Ge=Ge<0?Oi*Ge+Ni*Ge*Ge:Oi*Ge-Ni*Ge*Ge,x=Ge<0?ki*(Ge*-Ge-Ge)+Ge:ki*(Ge*Ge-Ge)+Ge,Ge=T%Ai,Ge<-Ui?Ge+=Ai:Ge>Ui&&(Ge-=Ai),Ge=Ge<0?Oi*Ge+Ni*Ge*Ge:Oi*Ge-Ni*Ge*Ge,m=Ge<0?ki*(Ge*-Ge-Ge)+Ge:ki*(Ge*Ge-Ge)+Ge,Ge=(T+Fi)%Ai,Ge<-Ui?Ge+=Ai:Ge>Ui&&(Ge-=Ai),Ge=Ge<0?Oi*Ge+Ni*Ge*Ge:Oi*Ge-Ni*Ge*Ge,_=Ge<0?ki*(Ge*-Ge-Ge)+Ge:ki*(Ge*Ge-Ge)+Ge,Ge=w%Ai,Ge<-Ui?Ge+=Ai:Ge>Ui&&(Ge-=Ai),Ge=Ge<0?Oi*Ge+Ni*Ge*Ge:Oi*Ge-Ni*Ge*Ge,g=Ge<0?ki*(Ge*-Ge-Ge)+Ge:ki*(Ge*Ge-Ge)+Ge,Ge=(w+Fi)%Ai,Ge<-Ui?Ge+=Ai:Ge>Ui&&(Ge-=Ai),Ge=Ge<0?Oi*Ge+Ni*Ge*Ge:Oi*Ge-Ni*Ge*Ge,b=Ge<0?ki*(Ge*-Ge-Ge)+Ge:ki*(Ge*Ge-Ge)+Ge,xt=_*b,vt=i*m*b-x*g,bt=x*m*b+i*g,yt=_*g,Tt=i*m*g+x*b,St=x*m*g-i*b,wt=-m,Mt=i*_,Rt=x*_,y=this.#Cr,T=this.#Ir,w=this.#Er,z[0]=(P*xt+q*vt+Ke*bt)*y,z[1]=($*xt+W*vt+Xe*bt)*y,z[2]=(H*xt+ye*vt+je*bt)*y,z[3]=z[3]*y,z[4]=(P*yt+q*Tt+Ke*St)*T,z[5]=($*yt+W*Tt+Xe*St)*T,z[6]=(H*yt+ye*Tt+je*St)*T,z[7]=z[7]*T,z[8]=(P*wt+q*Mt+Ke*Rt)*w,z[9]=($*wt+W*Mt+Xe*Rt)*w,z[10]=(H*wt+ye*Mt+je*Rt)*w,z[11]=z[11]*w}this.modelMatrix=this.localMatrix;{let i=this.normalModelMatrix,m=this.modelMatrix;P=m[0],$=m[1],H=m[2],z=m[3],q=m[4],W=m[5],ye=m[6],Ge=m[7],Ke=m[8],Xe=m[9],je=m[10],Ye=m[11],Je=m[12],Qe=m[13],et=m[14],at=m[15],Ze=P*W-$*q,ht=P*ye-H*q,ft=P*Ge-z*q,gt=$*ye-H*W,xt=$*Ge-z*W,vt=H*Ge-z*ye,bt=Ke*Qe-Xe*Je,yt=Ke*et-je*Je,Tt=Ke*at-Ye*Je,wt=Xe*at-Ye*Qe,St=je*at-Ye*et,Rt=Ze*St-ht*wt+ft*St+gt*Tt-xt*yt+vt*bt,Rt=1/Rt,i[0]=(W*St-ye*wt+Ge*St)*Rt,i[4]=(-$*St+H*wt-z*St)*Rt,i[8]=(Qe*vt-et*xt+at*gt)*Rt,i[12]=(-Xe*vt+je*xt-Ye*gt)*Rt,i[1]=(-q*St+ye*Tt-Ge*yt)*Rt,i[5]=(P*St-H*Tt+z*yt)*Rt,i[9]=(-Je*vt+et*ft-at*ht)*Rt,i[13]=(Ke*vt-je*ft+Ye*ht)*Rt,i[2]=(q*wt-W*Tt+Ge*bt)*Rt,i[6]=(-P*wt+$*Tt-z*bt)*Rt,i[10]=(Je*xt-Qe*ft+at*Ze)*Rt,i[14]=(-Ke*xt+Xe*ft-Ye*Ze)*Rt,i[3]=(-q*St+W*yt-ye*bt)*Rt,i[7]=(P*St-$*yt+H*bt)*Rt,i[11]=(-Je*gt+Qe*ht-et*Ze)*Rt,i[15]=(Ke*gt-Xe*ht+je*Ze)*Rt}if(this.#Zs.gpuRenderInfo){const{vertexUniformBuffer:i,vertexUniformInfo:m}=this.#Zs.gpuRenderInfo,g=m.members.instanceModelMatrixs,x=m.members.instanceNormalModelMatrix,_=m.members.instanceOpacity;this.#_.gpuDevice.queue.writeBuffer(i.gpuBuffer,g.uniformOffset+g.stride*this.#Ys,new g.View(this.modelMatrix)),this.#_.gpuDevice.queue.writeBuffer(i.gpuBuffer,x.uniformOffset+x.stride*this.#Ys,new x.View(this.normalModelMatrix)),this.#_.gpuDevice.queue.writeBuffer(i.gpuBuffer,_.uniformOffset+_.stride*this.#Ys,new _.View([this.opacity]))}}}var Vi="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcDisplacements;\r\nstruct InstanceUniforms {\rinstanceGroupModelMatrix:mat4x4<f32>,\r\n\t instanceModelMatrixs:array<mat4x4<f32>,100000>,\r\n\t instanceNormalModelMatrix:array<mat4x4<f32>,100000>,\r\n\t instanceOpacity:array<f32,100000>,\ruseDisplacementTexture:u32,\rdisplacementScale:f32,\r\n};\r\n@group(1) @binding(0) var<storage,read> instanceUniforms:InstanceUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@builtin(instance_index) instanceIdx:u32,\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) instanceOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n};\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\rlet input_instanceIdx:u32=inputData.instanceIdx;\rlet u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx];\rlet u_normalModelMatrix=instanceUniforms.instanceNormalModelMatrix[input_instanceIdx];\rlet u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix;\rlet u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u;\rlet u_displacementScale=instanceUniforms.displacementScale;\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\n\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\r\r\rlet worldPosition=position.xyz;\r\n\r\rlet margin:f32=0.5;\r\n\r\rvar clipPosition:vec4<f32>=u_projectionMatrix * u_cameraMatrix * vec4<f32>(worldPosition,1.0);\r\n\r\rlet ndcPosition:vec3<f32>=clipPosition.xyz/clipPosition.w;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\noutput.position=clipPosition;\r\n\r\r\n\r\n\rvar normalPosition:vec3<f32>=(u_instanceGroupModelMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0)).xyz;;\r\n\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_cameraPosition);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacedPosition=calcDisplacementPosition(input_position,input_vertexNormal,displacementTexture,displacementTextureSampler,u_displacementScale,input_uv,mipLevel);\r\n\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\r}\r\n\routput.position=u_projectionMatrix * u_cameraMatrix * u_instanceGroupModelMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition;\routput.uv=input_uv;\routput.instanceOpacity=instanceUniforms.instanceOpacity[input_instanceIdx];\rreturn output;\r\n}\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\rlet input_instanceIdx:u32=inputData.instanceIdx;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx];\rlet u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u;\rlet u_displacementScale=instanceUniforms.displacementScale;\r\n\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rposition= u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_directionalLightProjectionViewMatrix[3].xyz);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacedPosition=calcDisplacementPosition(input_position,input_vertexNormal,displacementTexture,displacementTextureSampler,u_displacementScale,input_uv,mipLevel);\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\r}\r\n\r\n\routput.position=u_directionalLightProjectionViewMatrix * position;\rreturn output;\r\n}\r\n";const $i="VERTEX_BIND_GROUP_DESCRIPTOR_INSTANCING";class InstancingMesh extends Mesh{#_;#Qs=1;#eo=[];constructor(i,m,g,x){super(i,g,x),this.#_=i,this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null),this.instanceCount=m,this.#to(i)}get instanceCount(){return this.#Qs}set instanceCount(i){validateUintRange(i),this.gpuRenderInfo.vertexUniformInfo=parseWGSL(Vi).storage.instanceUniforms;const m=new ArrayBuffer(this.gpuRenderInfo.vertexUniformInfo.arrayBufferByteLength),g=new StorageBuffer(this.#_,m,this.name),x=this.gpuRenderInfo.vertexUniformBuffer;x?.gpuBuffer&&copyGPUBuffer(this.#_.gpuDevice,x.gpuBuffer,g.gpuBuffer),x?.destroy(),this.gpuRenderInfo.vertexUniformBuffer=g;let _=i;for(;_--;)this.#eo[_]||(this.#eo[_]=new InstancingMeshObject3D(this.#_,_,this));this.#Qs=i,this.#to(this.#_)}get instanceChildren(){return this.#eo}render(i,m=!1){const{view:g,currentRenderPassEncoder:x}=i,{scene:_}=g,{shadowManager:b}=_,{directionalShadowManager:y}=b,{castingList:T}=y,w=this.parent;let P=this.dirtyTransform;P&&(identity$2(this.localMatrix),translate$1(this.localMatrix,this.localMatrix,[this.x,this.y,this.z]),rotateX$3(this.localMatrix,this.localMatrix,this.rotationX),rotateY$3(this.localMatrix,this.localMatrix,this.rotationY),rotateZ$3(this.localMatrix,this.localMatrix,this.rotationZ),scale$5(this.localMatrix,this.localMatrix,[this.scaleX,this.scaleY,this.scaleZ]),w?.modelMatrix?multiply$5(this.modelMatrix,this.localMatrix,w.modelMatrix):this.modelMatrix=clone$5(this.localMatrix)),this.geometry?i.num3DObjects++:i.num3DGroups++;const $=this.#_;if(this.geometry){const{antialiasingManager:g,gpuDevice:_}=$;g.changedMSAA&&(this.dirtyPipeline=!0),this.gpuRenderInfo||this.#to($);const b=this.dirtyPipeline||this.material.dirtyPipeline,{displacementTexture:y,displacementScale:T}=this.material||{};b&&(this.dirtyTransform=!0,this.material.dirtyPipeline&&this.material._updateFragmentState(),this.#ro(),this.material.dirtyPipeline=!1,this.dirtyPipeline=!1,i.numDirtyPipelines++);const{gpuRenderInfo:w}=this,{vertexUniformBuffer:P,vertexUniformBindGroup:H,vertexUniformInfo:z,pipeline:q,shadowPipeline:W}=w;void 0!==z.members.displacementScale&&_.queue.writeBuffer(P.gpuBuffer,z.members.displacementScale.uniformOffset,new z.members.displacementScale.View([T])),void 0!==z.members.useDisplacementTexture&&_.queue.writeBuffer(P.gpuBuffer,z.members.useDisplacementTexture.uniformOffset,new z.members.useDisplacementTexture.View([y?1:0])),this.dirtyTransform&&_.queue.writeBuffer(P.gpuBuffer,z.members.instanceGroupModelMatrix.uniformOffset,new z.members.instanceGroupModelMatrix.View(this.modelMatrix)),this.dirtyTransform=!1,x.setPipeline(m?W:q);const{gpuBuffer:ye}=this.geometry.vertexBuffer,{fragmentUniformBindGroup:Ge}=this.material.gpuRenderInfo;if(i.prevVertexGpuBuffer!==ye&&(x.setVertexBuffer(0,ye),i.prevVertexGpuBuffer=ye),x.setBindGroup(1,H),x.setBindGroup(2,Ge),i.numDrawCalls++,i.numInstances++,this.geometry.indexBuffer){const{indexBuffer:m}=this.geometry,{indexNum:g,triangleCount:_,gpuBuffer:b}=m;x.setIndexBuffer(b,"uint32"),x.drawIndexed(g,this.#Qs,0,0,0),i.numTriangles+=_*this.#Qs,i.numPoints+=g*this.#Qs}else{const{vertexBuffer:m}=this.geometry,{vertexCount:g,triangleCount:_}=m;x.draw(g,this.#Qs,0,0),i.numTriangles+=_,i.numPoints+=g}}this.castShadow&&(T[T.length]=this);const{children:H}=this;let z=H.length;for(;z--;)H[z].dirtyTransform=P,H[z].render(i);this.dirtyTransform=!1}#to(i){this.dirtyPipeline=!0;const{resourceManager:m}=this.#_,g=m.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing),{basicSampler:x,emptyBitmapTextureView:_,emptyCubeTextureView:b}=m,{gpuSampler:y}=x,{vertexUniformBuffer:T}=this.gpuRenderInfo,{material:w}=this,P={layout:g,label:$i,entries:[{binding:0,resource:{buffer:T.gpuBuffer,offset:0,size:T.size}},{binding:1,resource:w?.displacementTextureSampler?.gpuSampler||y},{binding:2,resource:w?.displacementTexture?.gpuTexture?.createView()||_}]},$=i.gpuDevice.createBindGroup(P);this.#ro(),this.gpuRenderInfo.vertexBindGroupLayout=g,this.gpuRenderInfo.vertexUniformBindGroup=$}#ro(){const{resourceManager:i}=this.#_,m={code:Vi},g=i.createGPUShaderModule("VERTEX_MODULE_INSTANCING",m),{vertexUniformBuffer:x}=this.gpuRenderInfo,{material:_}=this,{basicSampler:b,emptyBitmapTextureView:y,emptyCubeTextureView:T}=i,{gpuSampler:w}=b,P=i.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing),$={layout:P,label:$i,entries:[{binding:0,resource:{buffer:x.gpuBuffer,offset:0,size:x.size}},{binding:1,resource:_?.displacementTextureSampler?.gpuSampler||w},{binding:2,resource:_?.displacementTexture?.gpuTexture?.createView()||y}]};this.gpuRenderInfo.vertexUniformBindGroup=this.redGPUContext.gpuDevice.createBindGroup($),this.gpuRenderInfo.pipeline=createBasePipeline(this,g,P),this.gpuRenderInfo.shadowPipeline=createBasePipeline(this,g,P,ei)}}Object.defineProperty(InstancingMesh.prototype,"meshType",{value:"instanceMesh",writable:!1});var Hi="#redgpu_include SYSTEM_UNIFORM;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\n\r\nstruct OutData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec4<f32>,\r\n};\r\nstruct VertexUniforms {\r\n\t modelMatrix:mat4x4<f32>,\r\n};\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@vertex\r\nfn main(inputData:InputData) -> OutData {\rvar outData:OutData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\routData.position=u_projectionMatrix * u_cameraMatrix * vertexUniforms.modelMatrix * vec4<f32>(inputData.position,1.0);\routData.vertexPosition=0.5 * (vec4<f32>(inputData.position,1.0) + vec4<f32>(1.0,1.0,1.0,1.0));\rreturn outData;\r\n}\r\n";const zi=parseWGSL("\r\nstruct Uniforms {\ropacity:f32,\ruseSkyboxTexture:u32\r\n};\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var skyboxTextureSampler:sampler;\r\n@group(2) @binding(2) var skyboxTexture:texture_cube<f32>;\r\n\r\nstruct InputData {\r@location(0) vertexPosition:vec4<f32>,\r\n};\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\rvar cubemapVec=inputData.vertexPosition.xyz - vec3<f32>(0.5);\r\n\r\n\rvar sampleColor:vec4<f32>=textureSample(skyboxTexture,skyboxTextureSampler,cubemapVec);\rvar outColor=vec4<f32>(sampleColor.rgb,sampleColor.a * uniforms.opacity);\rif(outColor.a==0.0) {\rdiscard;\r}\rreturn outColor;\r\n}\r\n");class SkyBoxMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,m){super(i,"SKYBOX_MATERIAL",zi,2),this.skyboxTexture=m,this.skyboxTextureSampler=new Sampler(this.redGPUContext,{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}),this.initGPURenderInfos()}}Br.defineCubeTexture(SkyBoxMaterial,["skyboxTexture"]),Br.defineSampler(SkyBoxMaterial,["skyboxTextureSampler"]),Object.freeze(SkyBoxMaterial);const qi=parseWGSL(Hi),Ki=qi.uniforms.vertexUniforms;class View2D extends View3D{constructor(i,m,g){super(i,m,new Camera2D,g)}}Object.freeze(View2D);const Wi=Math.PI/180;class GroupBase extends Object3DContainer{modelMatrix=create$5();localMatrix=create$5();#e;#a;#Tr;#r=0;#i=0;#n=0;#Sr=[0,0,0];#wr=0;#Mr=0;#Rr=0;#Cr=1;#Ir=1;#Er=1;#Lr=[1,1,1];#o=0;#u=0;#l=0;#Br=[0,0,0];#no=!0;constructor(i){super(),i&&(this.name=i)}get dirtyTransform(){return this.#no}set dirtyTransform(i){this.#no=i}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get parent(){return this.#Tr}set parent(i){this.#Tr=i}get pivotX(){return this.#wr}set pivotX(i){this.#wr=i,this.dirtyTransform=!0}get pivotY(){return this.#Mr}set pivotY(i){this.#Mr=i,this.dirtyTransform=!0}get pivotZ(){return this.#Rr}set pivotZ(i){this.#Rr=i,this.dirtyTransform=!0}get x(){return this.#r}set x(i){this.#r=this.#Sr[0]=i,this.dirtyTransform=!0}get y(){return this.#n}set y(i){this.#n=this.#Sr[1]=i,this.dirtyTransform=!0}get z(){return this.#i}set z(i){this.#i=this.#Sr[2]=i,this.dirtyTransform=!0}get position(){return this.#Sr}get scaleX(){return this.#Cr}set scaleX(i){this.#Cr=this.#Lr[0]=i,this.dirtyTransform=!0}get scaleY(){return this.#Ir}set scaleY(i){this.#Ir=this.#Lr[1]=i,this.dirtyTransform=!0}get scaleZ(){return this.#Er}set scaleZ(i){this.#Er=this.#Lr[2]=i,this.dirtyTransform=!0}get scale(){return this.#Sr}get rotationX(){return this.#o}set rotationX(i){this.#o=this.#Br[0]=i,this.dirtyTransform=!0}get rotationY(){return this.#u}set rotationY(i){this.#u=this.#Br[1]=i,this.dirtyTransform=!0}get rotationZ(){return this.#l}set rotationZ(i){this.#l=this.#Br[2]=i,this.dirtyTransform=!0}get rotation(){return this.#Br}setScale(i,m,g){m=m??i,g=g??i;const x=this.#Lr;this.#Cr=x[0]=i,this.#Ir=x[1]=m,this.#Er=x[2]=g,this.dirtyTransform=!0}setPosition(i,m,g){m=m??i,g=g??i;const x=this.#Sr;this.#r=x[0]=i,this.#n=x[1]=m,this.#i=x[2]=g,this.dirtyTransform=!0}setRotation(i,m,g){m=m??i,g=g??i;const x=this.#Br;this.#o=x[0]=i,this.#u=x[1]=m,this.#l=x[2]=g,this.dirtyTransform=!0}render(i){const{view:m,isScene2DMode:g}=i;let x;if(g&&(this.#i=0,this.#Rr=0),this.dirtyTransform){x=!0;{const{pixelRectObject:i}=m,g=this.parent,x=this.localMatrix;identity$2(x),translate$1(x,x,[this.#r,this.#n,this.#i]),rotateX$3(x,x,this.#o*Wi),rotateY$3(x,x,this.#u*Wi),rotateZ$3(x,x,this.#l*Wi);let _=[this.#Cr,this.#Ir,this.#Er];if(this.renderTextureWidth&&(_[0]*=this.renderTextureWidth/i.height,_[1]*=this.renderTextureHeight/i.height),scale$5(x,x,_),this.#wr||this.#Mr||this.#Rr){translate$1(x,x,[-this.#wr,-this.#Mr,-this.#Rr])}g?.modelMatrix?multiply$5(this.modelMatrix,g.modelMatrix,this.localMatrix):copy$5(this.modelMatrix,this.localMatrix)}}this.dirtyTransform&&(x=!0,this.dirtyTransform=!1),i.num3DGroups++;const{children:_}=this;let b=0;const y=_.length;for(;b<y;b++)x&&(_[b].dirtyTransform=x),_[b].render(i)}}Object.defineProperty(GroupBase.prototype,"meshType",{value:"mesh",writable:!1}),Object.freeze(GroupBase);class Group2D extends GroupBase{#e;#a;#io=0;constructor(i){super(),i&&(this.name=i)}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}get rotation(){return this.#io}set rotation(i){this.#io=i,super.rotationZ=i}setScale(i,m){m=m??i,super.setScale(i,m,1)}setPosition(i,m){m=m??i,super.setPosition(i,m,0)}setRotation(i){this.rotation=i}}Object.defineProperty(Group2D.prototype,"is2DMeshType",{value:!0,writable:!1}),Object.freeze(Group2D);class Group3D extends GroupBase{#e;#a;constructor(i){super(),i&&(this.name=i)}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#a||`${this.constructor.name} Instance ${this.#e}`}set name(i){this.#a=i}}Object.defineProperty(Group3D.prototype,"meshType",{value:"mesh",writable:!1}),Object.freeze(Group3D);const Xi={Linear:0,QuintIn:1,QuintOut:2,QuintInOut:3,BackIn:4,BackOut:5,BackInOut:6,CircIn:7,CircOut:8,CircInOut:9,CubicIn:10,CubicOut:11,CubicInOut:12,ExpoIn:13,ExpoOut:14,ExpoInOut:15,QuadIn:16,QuadOut:17,QuadInOut:18,QuartIn:19,QuartOut:20,QuartInOut:21,SineIn:22,SineOut:23,SineInOut:24,ElasticIn:25,ElasticOut:26,ElasticInOut:27};class Plane extends Primitive{#ta=function(){const i=[],m=[];return function(g,x,_,b,y,T,w,P){const $=_/2,H=b/2,z=Math.floor(y)||1,q=Math.floor(T)||1,W=z+1,ye=q+1,Ge=_/z,Ke=b/q;i.length=0,m.length=0;for(let g=0;g<ye;g++){const x=g*Ke-H,_=P?(1-g/q)*w:g/q*w;for(let b=0;b<W;b++){const y=b*Ge-$,T=b/z*w;if(i.push(y,-x,0,0,0,1,T,_),g<q&&b<z){const i=b+W*g,x=b+W*(g+1),_=b+1+W*(g+1),y=b+1+W*g;m.push(i,x,y),m.push(x,_,y)}}}return createPrimitiveGeometry(x,i,m,g)}}();constructor(i,m=1,g=1,x=1,_=1,b=1,y=!1){super(i);const T=`PRIMITIVE_PLANE_W${m}_H${g}_WS${x}_HS${_}_UV${b}_FY${y}`,w=i.resourceManager.cachedBufferState;let P=w[T];P||(P=w[T]=this.#ta(T,i,m,g,x,_,b,y)),this._setData(P)}}var ji="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t useBillboardPerspective:u32,\r\n\t useBillboard:u32,\r\n\t combinedOpacity:f32,\r\n};\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) a_position:vec3<f32>,\r@location(1) a_normal:vec3<f32>,\r@location(2) a_uv:vec2<f32>,\r@location(3) position:vec3<f32>,\r@location(4) alpha:f32,\r@location(5) rotation:vec3<f32>,\r@location(6) scale:f32,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n};\r\nfn mat4_inverse(a:mat4x4<f32>) -> mat4x4<f32> {\rvar a00:f32=a[0][0];\rvar a01:f32=a[0][1];\rvar a02:f32=a[0][2];\rvar a03:f32=a[0][3];\rvar a10:f32=a[1][0];\rvar a11:f32=a[1][1];\rvar a12:f32=a[1][2];\rvar a13:f32=a[1][3];\rvar a20:f32=a[2][0];\rvar a21:f32=a[2][1];\rvar a22:f32=a[2][2];\rvar a23:f32=a[2][3];\rvar a30:f32=a[3][0];\rvar a31:f32=a[3][1];\rvar a32:f32=a[3][2];\rvar a33:f32=a[3][3];\r\n\rvar b00:f32=a00*a11 - a01*a10;\rvar b01:f32=a00*a12 - a02*a10;\rvar b02:f32=a00*a13 - a03*a10;\rvar b03:f32=a01*a12 - a02*a11;\rvar b04:f32=a01*a13 - a03*a11;\rvar b05:f32=a02*a13 - a03*a12;\rvar b06:f32=a20*a31 - a21*a30;\rvar b07:f32=a20*a32 - a22*a30;\rvar b08:f32=a20*a33 - a23*a30;\rvar b09:f32=a21*a32 - a22*a31;\rvar b10:f32=a21*a33 - a23*a31;\rvar b11:f32=a22*a33 - a23*a32;\r\n\r\rvar det:f32=b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06;\r\n\r\rif (det !=0.0) {\rdet=1.0/det;\rreturn mat4x4<f32>(\r(a11*b11 - a12*b10 + a13*b09) * det,\r(a02*b10 - a01*b11 - a03*b09) * det,\r(a31*b05 - a32*b04 + a33*b03) * det,\r(a22*b04 - a21*b05 - a23*b03) * det,\r(a12*b08 - a10*b11 - a13*b07) * det,\r(a00*b11 - a02*b08 + a03*b07) * det,\r(a32*b02 - a30*b05 - a33*b01) * det,\r(a20*b05 - a22*b02 + a23*b01) * det,\r(a10*b10 - a11*b08 + a13*b06) * det,\r(a01*b08 - a00*b10 - a03*b06) * det,\r(a30*b04 - a31*b02 + a33*b00) * det,\r(a21*b02 - a20*b04 - a23*b00) * det,\r(a11*b07 - a10*b09 - a12*b06) * det,\r(a00*b09 - a01*b07 + a02*b06) * det,\r(a31*b01 - a30*b03 - a32*b00) * det,\r(a20*b03 - a21*b01 + a22*b00) * det\r);\r}\r\n\r\rreturn mat4x4<f32>(\r0.0,0.0,0.0,0.0,\r0.0,0.0,0.0,0.0,\r0.0,0.0,0.0,0.0,\r0.0,0.0,0.0,0.0\r);\r\n}\r\nfn rotationMTX(t:vec3<f32>)->mat4x4<f32>\r\n{\rvar s:f32=sin(t.x);\rvar c:f32=cos(t.x);\rvar m1=mat4x4<f32>(1,0, 0,0,\r0,c,-s,0,\r0,s, c,0,\r0,0, 0,1);\r\n\rs=sin(t[1]);c=cos(t[1]);\rvar m2=mat4x4<f32>(c,0,s,0,\r0,1,0,0,\r-s,0,c,0,\r0,0,0,1);\r\n\rs=sin(t[2]);c=cos(t[2]);\rvar m3=mat4x4<f32>(c,-s,0,0,\rs,c,0,0,\r0,0,1,0,\r0,0,0,1);\r\n\rreturn m1 * m2 * m3;\r\n}\r\n\r\n@vertex\r\nfn main( inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_resolution=systemUniforms.resolution;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective==1u;\rlet u_useBillboard=vertexUniforms.useBillboard==1u;\r\n\r\rlet input_position=inputData.position;\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\rvar scaleMTX=mat4x4<f32>(\rinputData.scale,0,0,0,\r0,inputData.scale,0,0,\r0,0,inputData.scale,0,\r0,0,0,1\r);\r\n\r\n\rvar translateTX=mat4x4<f32>(\r1,0,0,0,\r0,1,0,0,\r0,0,1,0,\rinputData.position.x,inputData.position.y,inputData.position.z,1\r);\r\n\r\n\rvar temp:mat4x4<f32>;\rif(u_useBillboard){\rvar rotateMTX2=rotationMTX( vec3(0,0,inputData.rotation.z) );\rtemp=translateTX * rotateMTX2;\rposition=rotateMTX2 * vec4<f32>(inputData.a_position ,1);\routput.position= u_projectionMatrix * getBillboardMatrixNoScaleRatio( u_cameraMatrix, temp ) * scaleMTX * position;\r}else{\rvar rotateMTX=rotationMTX( inputData.rotation );\rtemp=translateTX * rotateMTX * scaleMTX;\rposition=temp * vec4<f32>(inputData.a_position,1);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\r}\r\n\routput.vertexPosition=position.xyz;\routput.vertexNormal= (transpose(mat4_inverse(temp) ) * vec4<f32>(inputData.a_normal,1.0)).xyz;\routput.uv=inputData.a_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n";const Yi=parseWGSL(ji),Zi=Yi.uniforms.vertexUniforms;class ParticleEmitter extends Mesh{#ao=1e3;#so=5e3;#oo=0;#uo=0;#lo=0;#co=0;#ho=0;#fo=0;#do=-5;#mo=-5;#po=-5;#go=5;#xo=5;#_o=5;#vo=0;#bo=0;#yo=1;#To=1;#So=0;#wo=1;#Mo=0;#Ro=0;#Po=-360;#Co=-360;#Io=-360;#Eo=360;#Lo=360;#Bo=360;#Do=-360;#Uo=-360;#Ao=-360;#ko=360;#Oo=360;#No=360;#Fo=Xi.CubicOut;#Go=Xi.CubicOut;#Vo=Xi.CubicOut;#$o=Xi.Linear;#Ho=Xi.Linear;#zo=Xi.CubicOut;#qo=Xi.CubicOut;#Ko=Xi.CubicOut;#Wo;#Xo;#jo;#oi;#Yo;#Zo=2e3;constructor(i){super(i),this.geometry=new Plane(i),this.material=new BitmapMaterial(i),this.ignoreFrustumCulling=!0,this.useBillboard=!0}get vertexStateBuffers(){return[{arrayStride:32,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32x2"}]},{arrayStride:48,stepMode:"instance",attributes:[{shaderLocation:3,offset:16,format:"float32x3"},{shaderLocation:4,offset:28,format:"float32"},{shaderLocation:5,offset:32,format:"float32x3"},{shaderLocation:6,offset:44,format:"float32"}]}]}get particleBuffers(){return this.#Xo}get particleNum(){return this.#Zo}set particleNum(i){this.#Zo=Math.max(Math.min(i,5e5),1),this.#Jo()}get minLife(){return this.#ao}set minLife(i){this.#ao=i}get maxLife(){return this.#so}set maxLife(i){this.#so=i}get minStartX(){return this.#oo}set minStartX(i){this.#oo=i}get minStartY(){return this.#uo}set minStartY(i){this.#uo=i}get minStartZ(){return this.#lo}set minStartZ(i){this.#lo=i}get maxStartX(){return this.#co}set maxStartX(i){this.#co=i}get maxStartY(){return this.#ho}set maxStartY(i){this.#ho=i}get maxStartZ(){return this.#fo}set maxStartZ(i){this.#fo=i}get minEndX(){return this.#do}set minEndX(i){this.#do=i}get minEndY(){return this.#mo}set minEndY(i){this.#mo=i}get minEndZ(){return this.#po}set minEndZ(i){this.#po=i}get maxEndX(){return this.#go}set maxEndX(i){this.#go=i}get maxEndY(){return this.#xo}set maxEndY(i){this.#xo=i}get maxEndZ(){return this.#_o}set maxEndZ(i){this.#_o=i}get minStartAlpha(){return this.#vo}set minStartAlpha(i){this.#vo=i}get maxStartAlpha(){return this.#bo}set maxStartAlpha(i){this.#bo=i}get minEndAlpha(){return this.#yo}set minEndAlpha(i){this.#yo=i}get maxEndAlpha(){return this.#To}set maxEndAlpha(i){this.#To=i}get minStartScale(){return this.#So}set minStartScale(i){this.#So=i}get maxStartScale(){return this.#wo}set maxStartScale(i){this.#wo=i}get minEndScale(){return this.#Mo}set minEndScale(i){this.#Mo=i}get maxEndScale(){return this.#Ro}set maxEndScale(i){this.#Ro=i}get minStartRotationX(){return this.#Po}set minStartRotationX(i){this.#Po=i}get minStartRotationY(){return this.#Co}set minStartRotationY(i){this.#Co=i}get minStartRotationZ(){return this.#Io}set minStartRotationZ(i){this.#Io=i}get maxStartRotationX(){return this.#Eo}set maxStartRotationX(i){this.#Eo=i}get maxStartRotationY(){return this.#Lo}set maxStartRotationY(i){this.#Lo=i}get maxStartRotationZ(){return this.#Bo}set maxStartRotationZ(i){this.#Bo=i}get minEndRotationX(){return this.#Do}set minEndRotationX(i){this.#Do=i}get minEndRotationY(){return this.#Uo}set minEndRotationY(i){this.#Uo=i}get minEndRotationZ(){return this.#Ao}set minEndRotationZ(i){this.#Ao=i}get maxEndRotationX(){return this.#ko}set maxEndRotationX(i){this.#ko=i}get maxEndRotationY(){return this.#Oo}set maxEndRotationY(i){this.#Oo=i}get maxEndRotationZ(){return this.#No}set maxEndRotationZ(i){this.#No=i}get easeX(){return this.#Fo}set easeX(i){this.#Fo=i}get easeY(){return this.#Go}set easeY(i){this.#Go=i}get easeZ(){return this.#Vo}set easeZ(i){this.#Vo=i}get easeAlpha(){return this.#$o}set easeAlpha(i){this.#$o=i}get easeScale(){return this.#Ho}set easeScale(i){this.#Ho=i}get easeRotationX(){return this.#zo}set easeRotationX(i){this.#zo=i}get easeRotationY(){return this.#qo}set easeRotationY(i){this.#qo=i}get easeRotationZ(){return this.#Ko}set easeRotationZ(i){this.#Ko=i}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_PARTICLE_EMITTER",Yi,Zi,ji)}render(i){this.#Xo||this.#Vi(),this.#Qo(i.timestamp),super.render(i)}#Jo(){let i=this.redGPUContext;const m=new Float32Array(12*this.#Zo),g=new Float32Array(12*this.#Zo),x=new Float32Array(12*this.#Zo),_=new Float32Array(4*this.#Zo),b=new Float32Array(4*this.#Zo),y=performance.now(),T=this.localToWorld(this.x,this.y,this.z);for(let i=0;i<this.#Zo;++i){let w=Math.random()*this.#so,P=Math.random()*w;const $=T[0]+Math.random()*(this.#co-this.#oo)+this.#oo,H=T[1]+Math.random()*(this.#ho-this.#uo)+this.#uo,z=T[2]+Math.random()*(this.#fo-this.#lo)+this.#lo,q=Math.random()*(this.#Eo-this.#Po)+this.#Po,W=Math.random()*(this.#Lo-this.#Co)+this.#Co,ye=Math.random()*(this.#Bo-this.#Io)+this.#Io;Math.random(),this.#wo,this.#So,this.#So,Math.random(),this.#bo,this.#vo,this.#vo,m[12*i]=y-P,m[12*i+1]=w,m[12*i+4]=$,m[12*i+5]=H,m[12*i+6]=z,m[12*i+7]=0,m[12*i+8]=q,m[12*i+9]=W,m[12*i+10]=ye,m[12*i+11]=0,g[4*i]=$,g[4*i+1]=Math.random()*(this.#go-this.#do)+this.#do,g[4*i+2]=this.#Fo,g[4*i+3]=T[0],g[4*i+4]=H,g[4*i+5]=Math.random()*(this.#xo-this.#mo)+this.#mo,g[4*i+6]=this.#Go,g[4*i+7]=T[1],g[4*i+8]=z,g[4*i+9]=Math.random()*(this.#_o-this.#po)+this.#po,g[4*i+10]=this.#Vo,g[4*i+11]=T[2],x[4*i]=q,x[4*i+1]=Math.random()*(this.#ko-this.#Do)+this.#Do,x[4*i+2]=this.#zo,x[4*i+3]=0,x[4*i+4]=W,x[4*i+5]=Math.random()*(this.#Oo-this.#Uo)+this.#Uo,x[4*i+6]=this.#qo,x[4*i+7]=0,x[4*i+8]=ye,x[4*i+9]=Math.random()*(this.#No-this.#Ao)+this.#Ao,x[4*i+10]=this.#Ko,x[4*i+11]=0,_[4*i]=0,_[4*i+1]=Math.random()*(this.#Ro-this.#Mo)+this.#Mo,_[4*i+2]=this.#Ho,_[4*i+3]=0,b[4*i]=0,b[4*i+1]=Math.random()*(this.#To-this.#yo)+this.#yo,b[4*i+2]=this.#$o,b[4*i+3]=0}const w=this.#Xo;this.#Xo=[];const P=[m,g,x,_,b];P.forEach((m,g)=>{const x=i.gpuDevice.createBuffer({size:m.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE});i.gpuDevice.queue.writeBuffer(x,0,m),this.#Xo.push(x),w?.length&&copyGPUBuffer(i.gpuDevice,w[g],x)}),w&&w.forEach(i=>i.destroy());let $={code:"\r\nstruct Info {\rstartValue:f32,\rendValue:f32,\reaseType:f32,\rbirthCenterValue:f32\r\n};\r\n\r\nstruct InfoGroup {\rinfoX:Info,\rinfoY:Info,\rinfoZ:Info,\r\n};\r\n\r\nstruct Particle {\rstartTime:f32,\rlife:f32,\rvaluePosition:vec3<f32>,\rvalueAlpha:f32,\rvalueRotation:vec3<f32>,\rvalueScale:f32,\r\n};\r\nstruct SimParams {\rtime:f32,\rcurrentPositionX:f32,currentPositionY:f32,currentPositionZ:f32,\rminLife:f32,maxLife:f32,\rminStartX:f32,maxStartX:f32,minEndX:f32,maxEndX:f32,easeX:f32,\rminStartY:f32,maxStartY:f32,minEndY:f32,maxEndY:f32,easeY:f32,\rminStartZ:f32,maxStartZ:f32,minEndZ:f32,maxEndZ:f32,easeZ:f32,\rminStartAlpha:f32,maxStartAlpha:f32,minEndAlpha:f32,maxEndAlpha:f32,easeAlpha:f32,\rminStartScale:f32,maxStartScale:f32,minEndScale:f32,maxEndScale:f32,easeScale:f32,\rminStartRotationX:f32,maxStartRotationX:f32,minEndRotationX:f32,maxEndRotationX:f32,easeRotationX:f32,\rminStartRotationY:f32,maxStartRotationY:f32,minEndRotationY:f32,maxEndRotationY:f32,easeRotationY:f32,\rminStartRotationZ:f32,maxStartRotationZ:f32,minEndRotationZ:f32,maxEndRotationZ:f32,easeRotationZ:f32,\r\n};\r\n\r\n\r\n@group(0) @binding(0) var<uniform> params:SimParams;\r\n@group(0) @binding(1) var<storage,read_write> particles:array<Particle>;\r\n@group(0) @binding(2) var<storage,read_write> infoPosition:array<InfoGroup>;\r\n@group(0) @binding(3) var<storage,read_write> infoRotation:array<InfoGroup>;\r\n@group(0) @binding(4) var<storage,read_write> infoScale:array<Info>;\r\n@group(0) @binding(5) var<storage,read_write> infoAlpha:array<Info>;\r\n\r\nconst PI:f32=3.141592653589793;\r\nconst HPI:f32=PI * 0.5;\r\nconst PI2:f32=PI * 2.0;\r\n\r\nfn calEasing(n:f32,easingType:f32) -> f32 {\rvar m:f32=n;\rlet easingInt:i32=i32(easingType);\r\n\rswitch (easingInt) {\rcase 0:{ m=m;}\rcase 1:{ m=m * m * m * m * m;}\rcase 2:{\rm -=1.0;\rm=(m * m * m * m * m) + 1.0;\r}\rcase 3:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * m * m * m * 0.5;\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * (m * m * m * m * m + 2.0);\r}\r}\rcase 4:{ m=m * m * (m * 1.70158 + m - 1.70158);}\rcase 5:{\rm -=1.0;\rm=m * m * (m * 1.70158 + m + 1.70158) + 1.0;\r}\rcase 6:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=0.5 * m * m * (m * 1.70158 + m - 1.70158);\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * m * m * (m * 1.70158 + m + 1.70158) + 1.0;\r}\r}\rcase 7:{ m=-1.0 * (sqrt(1.0 - m * m) - 1.0);}\rcase 8:{\rm -=1.0;\rm=sqrt(1.0 - m * m);\r}\rcase 9:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=-0.5 * (sqrt(1.0 - m * m) - 1.0);\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * sqrt(1.0 - m * m) + 0.5;\r}\r}\rcase 10:{ m=m * m * m;}\rcase 11:{\rm -=1.0;\rm=m * m * m + 1.0;\r}\rcase 12:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * m * 0.5;\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * (m * m * m + 2.0);\r}\r}\rcase 13:{\rif (m==0.0) { m=0.0;}\relse { m=pow(2.0,10.0 * (m - 1.0));}\r}\rcase 14:{\rif (m==1.0) { m=1.0;}\relse { m=-pow(2.0,-10.0 * m) + 1.0;}\r}\rcase 15:{\rif(m * 2.0 < 1.0) {\rif (m==0.0) { m=0.0;}\relse { m *=2.0;m=0.5 * pow(2.0,10.0 * (m - 1.0));}\r}\relse {\rif (m==2.0) { m=1.0;}\relse { m=m * 2.0 - 1.0;m=-0.5 * pow(2.0,-10.0 * m) + 1.0;}\r}\r}\rcase 16:{ m=m * m;}\rcase 17:{ m=(2.0 - m) * m;}\rcase 18:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * 0.5;\r}\relse {\rm=2.0 - m;\rm=0.5 * (m * m + 1.0);\r}\r}\rcase 19:{ m=m * m * m * m;}\rcase 20:{\rm -=1.0;\rm=1.0 - (m * m * m * m);\r}\rcase 21:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * m * m * 0.5;\r}\relse {\rm=m * 2.0 - 2.0;\rm=1.0 - (m * m * m * m * 0.5);\r}\r}\rcase 22:{ m=-cos(m * HPI) + 1.0;}\rcase 23:{ m=sin(m * HPI);}\rcase 24:{ m=(-cos(m * PI) + 1.0) * 0.5;}\rcase 25:{\rif (m==0.0) { m=0.0;}\relse if (m==1.0) { m=1.0;}\relse { m -=1.0;m=-1.0 * pow(2.0,10.0 * m) * sin((m - 0.075) * (PI2)/0.3);}\r}\r\rcase 26:{\rif (m==0.0) {\rm=0.0;\r} else if (m==1.0) {\rm=1.0;\r} else {\rm -=1.0;\rm=-pow(2.0,10.0 * m) * sin((m - 0.075) * PI2/0.3);\r}\r}\r\rcase 27:{\rif (m==0.0) {\rm=0.0;\r} else if (m==1.0) {\rm=1.0;\r} else {\rm=pow(2.0,-10.0 * m) * sin((m - 0.075) * PI2/0.3) + 1.0;\r}\r}\rdefault:{ m=m;}\r}\rreturn m;\r\n}\r\nfn rand(n:f32) -> f32 {\rreturn fract(sin(n) * 43758.5453123);\r\n}\r\nfn randomRange(min:f32,max:f32,v:f32)->f32\r\n{\rvar newValue:f32=rand(v);\rreturn (newValue * (max-min)) + min;\r\n}\r\nfn compute_value(tInfo:Info,lifeRatio:f32) -> f32 {\rreturn tInfo.startValue + ((tInfo.endValue - tInfo.startValue) * calEasing(lifeRatio,tInfo.easeType));\r\n}\r\n@compute @workgroup_size(256,1,1)\r\nfn main(\r@builtin(global_invocation_id) global_id:vec3<u32>\r) {\rlet index:u32=(global_id.x);\rlet age:f32=(params.time - particles[index].startTime);\rvar lifeRatio:f32=(age/particles[index].life);\rif (lifeRatio >=1.0 ) {\rlet uuid:f32=(params.time + f32(index));\rparticles[index].startTime=params.time;\rparticles[index].life=randomRange( params.minLife,params.maxLife,uuid );\r\n\r\rinfoPosition[index].infoX.startValue=randomRange( params.minStartX + params.currentPositionX,params.maxStartX + params.currentPositionX,(uuid + 1.0) );\rinfoPosition[index].infoX.endValue =randomRange( params.minEndX + params.currentPositionX,params.maxEndX + params.currentPositionX,(uuid + 2.0) );\rinfoPosition[index].infoX.easeType =params.easeX;\rinfoPosition[index].infoX.birthCenterValue=params.currentPositionX;\r\rinfoPosition[index].infoY.startValue=randomRange( params.minStartY +params.currentPositionY,params.maxStartY+params.currentPositionY,(uuid + 3.0) );\rinfoPosition[index].infoY.endValue =randomRange( params.minEndY+params.currentPositionY,params.maxEndY+params.currentPositionY,(uuid + 4.0) );\rinfoPosition[index].infoY.easeType =params.easeY;\rinfoPosition[index].infoY.birthCenterValue=params.currentPositionY;\r\rinfoPosition[index].infoZ.startValue=randomRange( params.minStartZ+params.currentPositionZ,params.maxStartZ+params.currentPositionZ,(uuid + 5.0) );\rinfoPosition[index].infoZ.endValue =randomRange( params.minEndZ+params.currentPositionZ,params.maxEndZ+params.currentPositionZ,(uuid + 6.0) );\rinfoPosition[index].infoZ.easeType =params.easeZ;\rinfoPosition[index].infoZ.birthCenterValue=params.currentPositionZ;\r\rinfoAlpha[index].startValue=randomRange( params.minStartAlpha,params.maxStartAlpha,(uuid + 7.0) );\rinfoAlpha[index].endValue =randomRange( params.minEndAlpha,params.maxEndAlpha,(uuid + 8.0) );\rinfoAlpha[index].easeType =params.easeAlpha;\r\rinfoScale[index].startValue=randomRange( params.minStartScale,params.maxStartScale,(uuid + 9.0) );\rinfoScale[index].endValue =randomRange( params.minEndScale,params.maxEndScale,(uuid + 10.0));\rinfoScale[index].easeType =params.easeScale;\r\rinfoRotation[index].infoX.startValue=randomRange( params.minStartRotationX,params.maxStartRotationX,(uuid + 11.0));\rinfoRotation[index].infoX.endValue =randomRange( params.minEndRotationX,params.maxEndRotationX,(uuid + 12.0));\rinfoRotation[index].infoX.easeType =params.easeRotationX;\r\rinfoRotation[index].infoY.startValue=randomRange( params.minStartRotationY,params.maxStartRotationY,(uuid + 13.0));\rinfoRotation[index].infoY.endValue =randomRange( params.minEndRotationY,params.maxEndRotationY,(uuid + 14.0));\rinfoRotation[index].infoY.easeType =params.easeRotationY;\r\rinfoRotation[index].infoZ.startValue=randomRange( params.minStartRotationZ,params.maxStartRotationZ,(uuid + 15.0));\rinfoRotation[index].infoZ.endValue =randomRange( params.minEndRotationZ,params.maxEndRotationZ,(uuid + 16.0));\rinfoRotation[index].infoZ.easeType =params.easeRotationZ;\r\n\rlifeRatio=0.0;\r}\rvar targetInfo:Info;\rlet targetParticle=particles[index];\r\rtargetInfo=infoPosition[index].infoX;\rparticles[index].valuePosition.x=compute_value(targetInfo,lifeRatio);\rtargetInfo=infoPosition[index].infoY;\rparticles[index].valuePosition.y= compute_value(targetInfo,lifeRatio);\rtargetInfo=infoPosition[index].infoZ;\rparticles[index].valuePosition.z= compute_value(targetInfo,lifeRatio);\r\rtargetInfo=infoAlpha[index];\rparticles[index].valueAlpha=compute_value(targetInfo,lifeRatio);\r\rtargetInfo=infoScale[index];\rparticles[index].valueScale=compute_value(targetInfo,lifeRatio);\r\rtargetInfo=infoRotation[index].infoX;\rparticles[index].valueRotation.x= compute_value(targetInfo,lifeRatio) * PI/180.0;\rtargetInfo=infoRotation[index].infoY;\rparticles[index].valueRotation.y= compute_value(targetInfo,lifeRatio) * PI/180.0;\rtargetInfo=infoRotation[index].infoZ;\rparticles[index].valueRotation.z= compute_value(targetInfo,lifeRatio) * PI/180.0;\r\n\r\n\r\n}\r\n"},H=i.resourceManager.createGPUShaderModule("PARTICLE_EMITTER_MODULE",$);const z=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}],q=[{binding:0,resource:{buffer:this.#Wo,offset:0,size:this.#jo.byteLength}}];P.forEach((i,m)=>{z.push({binding:m+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),q.push({binding:m+1,resource:{buffer:this.#Xo[m],offset:0,size:i.byteLength}})});const W=i.gpuDevice.createBindGroupLayout({entries:z}),ye=i.gpuDevice.createPipelineLayout({bindGroupLayouts:[W]});this.#Yo=i.gpuDevice.createBindGroup({layout:W,entries:q}),this.#oi=i.gpuDevice.createComputePipeline({layout:ye,compute:{module:H,entryPoint:"main"}})}#Vi(){this.#jo=new Float32Array(46);let i={size:this.#jo.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const{gpuDevice:m}=this.redGPUContext;this.#Wo=m.createBuffer(i),m.queue.writeBuffer(this.#Wo,0,this.#jo),this.#Jo(),this.depthStencilState.depthWriteEnabled=!1}#Qo(i){const m=this.localToWorld(this.x,this.y,this.z);this.#jo.set([i,...m,this.#ao,this.#so,this.#oo,this.#co,this.#do,this.#go,this.#Fo,this.#uo,this.#ho,this.#mo,this.#xo,this.#Go,this.#lo,this.#fo,this.#po,this.#_o,this.#Vo,this.#vo,this.#bo,this.#yo,this.#To,this.#$o,this.#So,this.#wo,this.#Mo,this.#Ro,this.#Ho,this.#Po,this.#Eo,this.#Do,this.#ko,this.#zo,this.#Co,this.#Lo,this.#Uo,this.#Oo,this.#qo,this.#Io,this.#Bo,this.#Ao,this.#No,this.#Ko],0);const{gpuDevice:g}=this.redGPUContext;g.queue.writeBuffer(this.#Wo,0,this.#jo);const x=g.createCommandEncoder({}),_=x.beginComputePass();_.setPipeline(this.#oi),_.setBindGroup(0,this.#Yo),_.dispatchWorkgroups(Math.ceil(this.#Zo/256)),_.end(),g.queue.submit([x.finish()])}}function mixInMesh2D(i){const m=class extends i{#io=0;#eu=Pi.NORMAL;get blendMode(){const i=Object.entries(Pi).find(([,i])=>i===this.#eu);if(!i)throw new Error(`Invalid blendMode value:${this.#eu}`);return i[0]}set blendMode(i){let m;if("string"==typeof i){if(!(i in Pi))throw new Error(`Invalid blendMode key:${i}`);m=Pi[i]}else{if("number"!=typeof i||!Object.values(Pi).includes(i))throw new Error(`Invalid blendMode:${i}`);m=i}this.#eu=m,this.#tu(m)}get rotation(){return this.#io}set rotation(i){this.#io=i,super.rotationZ=i}setScale(i,m){m=m??i,super.setScale(i,m,1)}setPosition(i,m){m=m??i,super.setPosition(i,m,0)}setRotation(i){this.rotation=i}#tu(i){const{blendColorState:m,blendAlphaState:g}=this._material;switch(i){case Pi.NORMAL:m.operation=hn.ADD,m.srcFactor=cn.SRC_ALPHA,m.dstFactor=cn.ONE_MINUS_SRC_ALPHA,g.operation=hn.ADD,g.srcFactor=cn.SRC_ALPHA,g.dstFactor=cn.ONE_MINUS_SRC_ALPHA;break;case Pi.MULTIPLY:m.operation=hn.ADD,m.srcFactor=cn.ONE_MINUS_DST_ALPHA,m.dstFactor=cn.ONE_MINUS_SRC_ALPHA,g.operation=hn.ADD,g.srcFactor=cn.SRC_ALPHA,g.dstFactor=cn.ONE_MINUS_SRC_ALPHA;break;case Pi.LIGHTEN:m.operation=hn.MAX,m.srcFactor=cn.ONE,m.dstFactor=cn.ONE,g.operation=hn.ADD,g.srcFactor=cn.SRC_ALPHA,g.dstFactor=cn.ONE_MINUS_SRC_ALPHA;break;case Pi.SCREEN:m.operation=hn.ADD,m.srcFactor=cn.ONE,m.dstFactor=cn.ONE_MINUS_SRC,g.operation=hn.ADD,g.srcFactor=cn.SRC_ALPHA,g.dstFactor=cn.ONE_MINUS_SRC_ALPHA;break;case Pi.LINEAR_DODGE:m.operation=hn.ADD,m.srcFactor=cn.ONE,m.dstFactor=cn.ONE,g.operation=hn.ADD,g.srcFactor=cn.SRC_ALPHA,g.dstFactor=cn.ONE;break;case Pi.SUBTRACT:m.operation=hn.REVERSE_SUBTRACT,m.srcFactor=cn.SRC_ALPHA,m.dstFactor=cn.ONE_MINUS_SRC_ALPHA,g.operation=hn.REVERSE_SUBTRACT,g.srcFactor=cn.ONE,g.dstFactor=cn.ONE;break;case Pi.DIFFERENCE:m.operation=hn.SUBTRACT,m.srcFactor=cn.ONE,m.dstFactor=cn.ONE,g.operation=hn.SUBTRACT,g.srcFactor=cn.ONE,g.dstFactor=cn.ONE;break;case Pi.EXCLUSION:m.operation=hn.ADD,m.srcFactor=cn.ONE_MINUS_DST_ALPHA,m.dstFactor=cn.ONE_MINUS_SRC_ALPHA,g.operation=hn.ADD,g.srcFactor=cn.ONE,g.dstFactor=cn.ONE;break;default:console.warn(`Unsupported blend mode:${i}`)}}};return Object.defineProperty(m.prototype,"is2DMeshType",{value:!0,writable:!1}),m}Object.defineProperty(ParticleEmitter.prototype,"meshType",{value:"particle",writable:!1}),br.defineByPreset(ParticleEmitter,[br.PRESET_BOOLEAN.USE_BILLBOARD]),br.definePositiveNumber(ParticleEmitter,[]),Object.freeze(ParticleEmitter);const Ji=mixInMesh2D(Mesh);class Sprite2D extends Ji{#pn=1;#gn=1;constructor(i,m){super(i,new Plane(i,1,1,1,1,1,!0),m),this.primitiveState.cullMode=ni.FRONT}get width(){return this.#pn}set width(i){validatePositiveNumberRange(i),this.#pn=i,this.dirtyTransform=!0}get height(){return this.#gn}set height(i){validatePositiveNumberRange(i),this.#gn=i,this.dirtyTransform=!0}get material(){return this._material}set material(i){consoleAndThrowError("Sprite2D can not change material")}setSize(i,m){this.width=i,this.height=void 0!==m?m:i}}Object.freeze(Sprite2D);var Qi="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseBillboardPerspective:u32,\ruseBillboard:u32,\rbillboardFixedScale:f32,\rcombinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_resolution=systemUniforms.resolution;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rlet input_vertexNormalVec4=vec4<f32>(input_vertexNormal,1.0);\rlet input_uv=inputData.uv;\r\n\r\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\r\n\r\n\r\rif (u_useBillboard==1) {\r\rlet projectionModelMatrix=u_projectionMatrix * u_modelMatrix;\rlet billboardMatrix=getBillboardMatrix(u_cameraMatrix,u_modelMatrix);\rlet billboardNormalMatrix=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix);\rif(u_useBillboardPerspective==1){\rposition=billboardMatrix * input_positionVec4;\rnormalPosition=billboardNormalMatrix * input_vertexNormalVec4;\r}else{\rposition=billboardMatrix * input_positionVec4;\rnormalPosition=billboardNormalMatrix * input_vertexNormalVec4;\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((projectionModelMatrix)[1][1],-1.0,1.0)/aspectRatio;\rlet scaleY=clamp((projectionModelMatrix)[1][1],-1.0,1.0);\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * input_positionVec4;\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * input_vertexNormalVec4;\r\n\r\routput.position=u_projectionMatrix * position;\r}\r\n\r\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_directionalLightProjectionMatrix=systemUniforms.directionalLightProjectionMatrix;\rlet u_directionalLightViewMatrix=systemUniforms.directionalLightViewMatrix;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\rlet input_position=inputData.position;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rvar position:vec4<f32>;\r\n\rreturn output;\r\n}\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_cameraMatrix=systemUniforms.camera.cameraMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\n\r\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\r\n\r\rlet input_position=inputData.position;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\r\rlet u_resolution=systemUniforms.resolution;\r\n\r\rvar position:vec4<f32>;\r\n\rif (u_useBillboard==1) {\r\rlet projectionModelMatrix=u_projectionMatrix * u_modelMatrix;\rlet billboardMatrix=getBillboardMatrix(u_cameraMatrix,u_modelMatrix);\rif(u_useBillboardPerspective==1){\rposition=billboardMatrix * input_positionVec4;\r}else{\rposition=billboardMatrix * input_positionVec4;\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((projectionModelMatrix)[1][1],-1.0,1.0)/aspectRatio;\rlet scaleY=clamp((projectionModelMatrix)[1][1],-1.0,1.0);\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * input_positionVec4;\routput.position=u_projectionMatrix * position;\r}\r\n\r\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\r\n\rreturn output;\r\n}\r\n";const ea=parseWGSL(Qi),ta=ea.uniforms.vertexUniforms;class Sprite3D extends Mesh{constructor(i,m,g){super(i),this._geometry=g||new Plane(i),this._material=m,this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.primitiveState.cullMode=ni.NONE}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_3D",ea,ta,Qi)}}br.defineByPreset(Sprite3D,[[br.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],[br.PRESET_BOOLEAN.USE_BILLBOARD,!0],[br.PRESET_POSITIVE_NUMBER.BILLBOARD_FIXED_SCALE,.1,.1]]),Object.freeze(Sprite3D);class ASpriteSheet extends Mesh{#ru=0;#nu=0;#iu=0;#au=!0;#su=!0;#ou;#uu;#lu="play";constructor(i,m,g){super(i),this.#uu=g,this._material=new BitmapMaterial(i),this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.spriteSheetInfo=m}get state(){return this.#lu}get loop(){return this.#su}set loop(i){this.#su=i}get frameRate(){return this.#ru}set frameRate(i){i<0&&(i=0),0===this.#ru&&i&&(this.#nu=0),this.#ru=i,this.#iu=1e3/this.#ru}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("ASpriteSheet can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("ASpriteSheet can not change material")}get spriteSheetInfo(){return this.#ou}set spriteSheetInfo(i){this.#ou=i,this.frameRate=i.frameRate,this.segmentW=i.segmentW,this.segmentH=i.segmentH,this.totalFrame=i.totalFrame,this.currentIndex=i.startIndex,this.#su=!0,this.#nu=0,this._material.diffuseTexture=i.texture}play(){this.#au=!0,this.#lu="play",this.#nu=0}pause(){this.#au=!1,this.#lu="pause"}stop(){this.#au=!1,this.currentIndex=0,this.#lu="stop"}render(i){const{diffuseTexture:m}=this._material;this.#uu(m,this.segmentW,this.segmentH);const{timestamp:g}=i;if(this.#nu||(this.#nu=this.#iu+g),this.#au&&this.#nu<g&&this.#ru){const i=Math.floor((g-this.#nu)/this.#iu),m=(Number.isFinite(i)?i:0)||1;this.#nu=this.#iu+g,this.currentIndex+=m,this.currentIndex>=this.totalFrame&&(this.loop?(this.#au=!0,this.currentIndex=0):(this.#au=!1,this.currentIndex=this.totalFrame-1))}super.render(i)}}br.definePositiveNumber(ASpriteSheet,[["segmentW",5],["segmentH",3],["totalFrame",15],["currentIndex",0]]),Object.freeze(ASpriteSheet);var ra="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\rsegmentW:f32,\rsegmentH:f32,\rtotalFrame:f32,\rcurrentIndex:f32,\rcombinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\r\n\routput.position=u_projectionMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\r\n\rlet uv=vec2<f32>(\rinput_uv.x * 1/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW),\rinput_uv.y * 1/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH)\r);\r\n\routput.uv=uv;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_directionalLightProjectionMatrix=systemUniforms.directionalLightProjectionMatrix;\rlet u_directionalLightViewMatrix=systemUniforms.directionalLightViewMatrix;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\rlet input_position=inputData.position;\rvar position:vec4<f32>;\r\n\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\routput.position=u_projectionMatrix * position;\r\n\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";const na=parseWGSL(ra),ia=na.uniforms.vertexUniforms,aa=mixInMesh2D(ASpriteSheet);class SpriteSheet2D extends aa{#pn=1;#gn=1;constructor(i,m){super(i,m,(i,m,g)=>{if(i){const{gpuTexture:x}=i,_=x?.width/m,b=x?.height/g;_===this.#pn&&b===this.#gn||(this.#pn=x?.width/m,this.#gn=x?.height/g,this.dirtyTransform=!0)}else this.#pn=1,this.#gn=1}),this._geometry=new Plane(i,1,1,1,1,1,!0),this.primitiveState.cullMode=ni.FRONT}get width(){return this.#pn}get height(){return this.#gn}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("SpriteSheet2D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("SpriteSheet2D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_2D",na,ia,ra)}}Object.freeze(SpriteSheet2D);var sa="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseBillboardPerspective:u32,\ruseBillboard:u32,\rsegmentW:f32,\rsegmentH:f32,\rtotalFrame:f32,\rcurrentIndex:f32,\rbillboardFixedScale:f32,\r_renderRatioX:f32,\r_renderRatioY:f32,\rcombinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_resolution=systemUniforms.resolution;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\rlet u_renderRatioX=vertexUniforms._renderRatioX;\rlet u_renderRatioY=vertexUniforms._renderRatioY;\rvar ratioScaleMatrix:mat4x4<f32>=mat4x4<f32>(\ru_renderRatioX,0,0,0,\r0,u_renderRatioY,0,0,\r0,0,1,0,\r0,0,0,1\r);\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\r\rif (u_useBillboard==1) {\r\rif(u_useBillboardPerspective==1){\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix) * ratioScaleMatrix *vec4<f32>(input_vertexNormal,1.0);\r}else{\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix *vec4<f32>(input_position,1.0);\rnormalPosition=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix) * ratioScaleMatrix * vec4<f32>(input_vertexNormal,1.0);\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((u_projectionMatrix)[1][1],-1.0,1.0)/aspectRatio * u_renderRatioX;\rlet scaleY=clamp((u_projectionMatrix)[1][1],-1.0,1.0) * u_renderRatioY;\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * ratioScaleMatrix * vec4<f32>(input_vertexNormal,1.0);\r\n\r\routput.position=u_projectionMatrix * position;\r}\r\n\r\n\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\r\n\r\n\rlet uv=vec2<f32>(\rinput_uv.x * 1/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW),\rinput_uv.y * 1/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH)\r);\r\n\routput.uv=uv;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_directionalLightProjectionMatrix=systemUniforms.directionalLightProjectionMatrix;\rlet u_directionalLightViewMatrix=systemUniforms.directionalLightViewMatrix;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet input_position=inputData.position;\rvar position:vec4<f32>;\r\n\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_cameraMatrix=systemUniforms.camera.cameraMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\n\r\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\rlet u_renderRatioX=vertexUniforms._renderRatioX;\rlet u_renderRatioY=vertexUniforms._renderRatioY;\rvar ratioScaleMatrix:mat4x4<f32>=mat4x4<f32>(\ru_renderRatioX,0,0,0,\r0,u_renderRatioY,0,0,\r0,0,1,0,\r0,0,0,1\r);\r\n\r\rlet input_position=inputData.position;\r\n\r\rlet u_resolution=systemUniforms.resolution;\r\n\r\rvar position:vec4<f32>;\r\n\rif (u_useBillboard==1) {\r\rif(u_useBillboardPerspective==1){\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0);\r}else{\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix *vec4<f32>(input_position,1.0);\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((u_projectionMatrix)[1][1],-1.0,1.0)/aspectRatio * u_renderRatioX;\rlet scaleY=clamp((u_projectionMatrix)[1][1],-1.0,1.0) * u_renderRatioY;\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0);\r\routput.position=u_projectionMatrix * position;\r}\r\n\r\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\r\n\rreturn output;\r\n}\r\n";const oa=parseWGSL(sa),ua=oa.uniforms.vertexUniforms;class SpriteSheet3D extends ASpriteSheet{#cu=1;#hu=1;constructor(i,m){super(i,m,(i,m,g)=>{if(i){const{gpuTexture:x}=i,_=x?.width/m,b=x?.height/g;_===this.#cu&&b===this.#hu||(this.#cu=x?.width/m,this.#hu=x?.height/g,this.#hu>this.#cu?(this._renderRatioX=1,this._renderRatioY=this.#hu/this.#cu):(this._renderRatioX=this.#cu/this.#hu,this._renderRatioY=1),this.dirtyTransform=!0)}else this.#cu=1,this.#hu=1}),this._geometry=new Plane(i)}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("SpriteSheet3D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("SpriteSheet3D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_3D",oa,ua,sa)}}br.definePositiveNumber(SpriteSheet3D,[["_renderRatioX",1],["_renderRatioY",1]]),br.defineByPreset(SpriteSheet3D,[[br.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],[br.PRESET_BOOLEAN.USE_BILLBOARD,!0],[br.PRESET_POSITIVE_NUMBER.BILLBOARD_FIXED_SCALE,.1,.1]]),Object.freeze(SpriteSheet3D);class SpriteSheetInfo{#fu=0;#du=0;#mu=0;#pu=0;#ru=0;#su=!0;#gu;constructor(i,m,g,x,_,b,y=!0,T=60){validateRedGPUContext(i),validateUintRange(g),validateUintRange(x),validateUintRange(_),validateUintRange(b),validateUintRange(T),this.#fu=g,this.#du=x,this.#mu=_,this.#pu=b,this.#gu=new BitmapTexture(i,m),this.#su=y,this.#ru=T}get segmentW(){return this.#fu}get segmentH(){return this.#du}get totalFrame(){return this.#mu}get startIndex(){return this.#pu}get texture(){return this.#gu}get frameRate(){return this.#ru}get loop(){return this.#su}}Object.freeze(SpriteSheetInfo);const la=parseWGSL("#redgpu_include drawPicking;\r\nstruct Uniforms {\r\topacity:f32\r\n};\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexColor:vec4<f32>,\r@location(15) pickingId:vec4<f32>,\r\n}\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\rreturn inputData.vertexColor;\r\n}\r\n\r\n\r\n");class LineMaterial extends ABaseMaterial{constructor(i,m){super(i,"LINE_MATERIAL",la,2),m&&(this.name=m),this.initGPURenderInfos()}}Object.freeze(LineMaterial);class LinePoint{position;colorRGBA;constructor(i=0,m=0,g=0,x){this.position=[i,m,g],this.colorRGBA=x}}const getPointsOnBezierCurveWithSplitting=(i,m,g,x)=>{let _=x||[];if(((i,m)=>{let g=i[m].position,x=i[m+1].position,_=i[m+2].position,b=i[m+3].position,y=3*x[0]-2*g[0]-b[0],T=3*x[1]-2*g[1]-b[1],w=3*_[0]-2*b[0]-g[0],P=3*_[1]-2*b[1]-g[1];return y*=y,T*=T,w*=w,P*=P,y<w&&(y=w),T<P&&(T=P),y+T})(i,m)<g)_.push(i[m],i[m+3]);else{let x=.5,b=i[m],y=i[m+1],T=i[m+2],w=i[m+3],P=lerp$4(create$4(),b.position,y.position,x),$=lerp$4(create$4(),y.position,T.position,x),H=lerp$4(create$4(),T.position,w.position,x),z=lerp$4(create$4(),P,$,x),q=lerp$4(create$4(),$,H,x),W=lerp$4(create$4(),z,q,x);W=new LinePoint(W[0],W[1],W[2],b.colorRGBA),P=new LinePoint(P[0],P[1],P[2],P.colorRGBA),H=new LinePoint(H[0],H[1],H[2],H.colorRGBA),z=new LinePoint(z[0],z[1],z[2],z.colorRGBA),q=new LinePoint(q[0],q[1],q[2],q.colorRGBA),getPointsOnBezierCurveWithSplitting([b,P,z,W],0,g,_),getPointsOnBezierCurveWithSplitting([W,q,H,w],0,g,_)}return _};class LinePointWithInOut{inLinePoint;linePoint;outLinePoint;constructor(i=0,m=0,g=0,x=0,_=0,b=0,y=0,T=0,w=0,P,$){let H=[...convertHexToRgb(P,!0)];H=[H[0]/255,H[1]/255,H[2]/255,$],this.inLinePoint=new LinePoint(x,_,b,H),this.linePoint=new LinePoint(i,m,g,H),this.outLinePoint=new LinePoint(y,T,w,H)}}const lineVec2DistanceToSegmentSq=function(i,m,g){i=[i[0],i[1]],m=[m[0],m[1]],g=[g[0],g[1]];let x=hr(m,g);if(0===x)return hr(i,m);let _=((i[0]-m[0])*(g[0]-m[0])+(i[1]-m[1])*(g[1]-m[1]))/x;return _=Math.max(0,Math.min(1,_)),hr(i,lerp([0,0],m,g,_))},lineSimplifyPoints=(i,m,g,x,_)=>{let b=_||[],y=i[m],T=i[g-1],w=0,P=1,$=m+1;for(;$<g-1;++$){let m=lineVec2DistanceToSegmentSq(i[$].position,y.position,T.position);m>w&&(w=m,P=$)}return Math.sqrt(w)>x?(lineSimplifyPoints(i,m,P+1,x,b),lineSimplifyPoints(i,P,g,x,b)):b.push(y,T),b},ca={LINEAR:"linear",CATMULL_ROM:"catmullRom",BEZIER:"bezier"};Object.freeze(ca);var ha="#redgpu_include SYSTEM_UNIFORM;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\r\n};\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexColor:vec4<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexColor:vec4<f32>,\r\n\r\n\r\n\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_resolution=systemUniforms.resolution;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\rlet input_position=inputData.position;\rlet input_vertexColor=inputData.vertexColor;\r\n\rvar position:vec4<f32>;\rposition=u_modelMatrix * vec4<f32>(input_position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexColor=input_vertexColor;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\r\n\rvar output:OutputData;\rreturn output;\r\n}\r\n";const fa=parseWGSL(ha),da=fa.uniforms.vertexUniforms;class Line3D extends Mesh{baseColor;#xu;#_u=1;#vu=.01;#rn=.01;#bu=[];#yu=[];#Tu;constructor(i,m=ca.LINEAR,g="#fff"){super(i),this.primitiveState.topology=yr.LINE_STRIP,this.baseColor=g,this.#xu=m,this._geometry=new Geometry(i,new VertexBuffer(i,this.#bu,new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexColor:InterleaveType.float32x4}))),this._material=new LineMaterial(i)}get originalPoints(){return this.#yu}get type(){return this.#xu}set type(i){this.#xu=i,this.#Su()}get interleaveData(){return this.#bu}get tension(){return this.#_u}set tension(i){validatePositiveNumberRange(i),this.#_u=i,this.#Su()}get tolerance(){return this.#vu}set tolerance(i){validatePositiveNumberRange(i),this.#vu=i,this.#Su()}get distance(){return this.#rn}set distance(i){validatePositiveNumberRange(i),this.#rn=i,this.#Su()}get numPoints(){return this.#yu.length}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("Line3D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("Line3D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_3D",fa,da,ha)}addPoint(i=0,m=0,g=0,x=this.baseColor,_=1,b=0,y=0,T=0,w=0,P=0,$=0){this.#yu.push(new LinePointWithInOut(i,m,g,b,y,T,w,P,$,x,_)),this.#Su()}addPointAt(i,m=0,g=0,x=0,_=this.baseColor,b=1,y=0,T=0,w=0,P=0,$=0,H=0){this.#yu.length<i&&(i=this.#yu.length),null!=i?this.#yu.splice(i,0,new LinePointWithInOut(m,g,x,y,T,w,P,$,H,_,b)):this.#yu.push(new LinePointWithInOut(m,g,x,y,T,w,P,$,H,_,b)),this.#Su()}removePointAt(i){validateUintRange(i),this.#yu[i]?this.#yu.splice(i,1):consoleAndThrowError("removeChildAt","index 해당인덱스에 위치한 포인트가 없음.","입력값:"+i),this.#Su()}removeAllPoint(){this.#yu.length=0,this.#Su()}#V(){if(this._geometry,this.#yu.length){const{redGPUContext:i}=this;this._geometry=new Geometry(i,new VertexBuffer(i,this.#bu,new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexColor:InterleaveType.float32x4})))}this.dirtyPipeline=!0}#Su(){const i=this.#yu,m=this.#_u,g=this.#vu,x=this.#rn;let _,b,y,T;switch(this.#bu.length=0,this.#xu){case ca.CATMULL_ROM:case ca.BEZIER:if(i.length>1)for(this.#Tu=(i=>{let m,g=[],x=0,_=0;const b=i.length;for(;x<b;x++){m=i[x];const{inLinePoint:b,linePoint:y,outLinePoint:T}=m;0===_?(g[_++]=y,g[_++]=T):(g[_++]=b,g[_++]=y,i[x+1]&&(g[_++]=T))}return g})(ca.CATMULL_ROM===this.#xu?((i,m=1)=>{const g=i.length,x=g-2;for(let _=0;_<g-1;_++){const g=_?i[_-1].linePoint.position:i[_].linePoint.position,b=i[_].linePoint.position,y=i[_+1].linePoint.position,T=_===x?y:i[_+2].linePoint.position;i[_].outLinePoint.position=[b[0]+(y[0]-g[0])/6*m,b[1]+(y[1]-g[1])/6*m,b[2]+(y[2]-g[2])/6*m],i[_+1].inLinePoint.position=[y[0]-(T[0]-b[0])/6*m,y[1]-(T[1]-b[1])/6*m,y[2]-(T[2]-b[2])/6*m]}return i})(i,m):i),_=((i,m)=>{let g=[],x=(i.length-1)/3;x=Math.floor(x);let _,b=0;for(;b<x;++b)_=3*b,getPointsOnBezierCurveWithSplitting(i,_,m,g);return g})(this.#Tu,g),_=lineSimplifyPoints(_,0,_.length,x),b=0,y=_.length;b<y;b++)T=_[b],this.#bu.push(...T.position,...T.colorRGBA);else this.#bu.push(0,0,0,1,1,1,1);break;default:for(b=0,y=i.length;b<y;b++){const{linePoint:m}=i[b],g=m.colorRGBA;this.interleaveData.push(...m.position,...g)}}this.#V()}}Object.freeze(Line3D);const ma=parseWGSL(ha),pa=ma.uniforms.vertexUniforms;const ga=";box-sizing:content-box;white-space:nowrap;",xa={padding:0,background:"transparent",color:"#fff",fontFamily:"Arial",fontSize:16,fontWeight:"normal",fontStyle:"normal",letterSpacing:0,wordBreak:"keep-all",verticalAlign:"middle",textAlign:"center",lineHeight:1.4,border:"",boxShadow:"none",boxSizing:"border-box",filter:""};class ATextField extends Mesh{#wu;#Mu;#Ru;#Pu;#Cu;#Iu;#Eu;#Lu=!0;#_;#Bu;#Du=!1;#Uu=!1;#Au=!1;constructor(i,m,g=!0){super(i),this.#_=i,this.#Lu=g,this.#Eu=m,this._material=new BitmapMaterial(i,new BitmapTexture(i)),this._material.transparent=!0,this._material.diffuseTextureSampler=new Sampler(i,g?{minFilter:kn.LINEAR,magFilter:kn.LINEAR,mipmapFilter:On.LINEAR}:{minFilter:kn.NEAREST,magFilter:kn.NEAREST,mipmapFilter:null}),this.depthStencilState.depthWriteEnabled=!1,this.#ku(),this.#Ou(),this.#Nu(),this.#Fu(),this.#Gu()}get text(){return this.#Iu}set text(i){this.#Iu=i;const m=this.#Ru.querySelector("foreignObject div"),g=this.#Vu(i);this.#Pu.innerHTML=g,m.innerHTML=g,this.#$u()}render(i){this.#Eu(this.#Cu.width,this.#Cu.height),super.render(i)}#Vu(i){return i.toString().replace(/\<br\/>/gi,"<div/>")}#ku(){"undefined"!=typeof OffscreenCanvas?this.#wu=new OffscreenCanvas(100,100):this.#wu=document.createElement("canvas"),this.#Mu=this.#wu.getContext("2d")}#Hu(){const i=this.#Pu.getBoundingClientRect();const m=i.width+3+3,g=i.height+3+3;return{width:-2&Math.ceil(m),height:-2&Math.ceil(g),extraTop:3,extraRight:3,extraBottom:3,extraLeft:3}}#$u(){if(this.#Du=!0,this.#Uu)return void(this.#Au=!0);this.#Uu=!0;const updateFrame=()=>{if(this.#Du){this.#Du=!1;const i=this.#Ru,m=i.querySelector("foreignObject"),{width:g,height:x,extraTop:_,extraRight:b,extraBottom:y,extraLeft:T}=this.#Hu();m.setAttribute("width",g.toString()),m.setAttribute("height",x.toString()),m.style.padding=`${_}px ${b}px ${y}px ${T}px`,i.setAttribute("width",g.toString()),i.setAttribute("height",x.toString()),this.#Cu.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(i.outerHTML)}this.#Au?(this.#Du=!0,this.#Au=!1,requestAnimationFrame(updateFrame)):this.#Uu=!1};requestAnimationFrame(updateFrame)}#Fu(){this.#Cu=new Image,this.#Cu.style.cssText="position:absolute;bottom:0px;left:0;",this.#Cu.onload=i=>{let m,g;const{width:x,height:_}=this.#Hu(),b=(this.#Lu,2),y=this.#Lu?1:2;m=x*b,g=_*b,this.#Cu.width=m/y,this.#Cu.height=g/y,this.#wu.width=m,this.#wu.height=g,this.#wu instanceof OffscreenCanvas||(this.#wu.style.width=m/b+"px",this.#wu.style.height=g/b+"px"),this.#Mu.imageSmoothingEnabled=!0,this.#Mu.imageSmoothingQuality="high",this.#Mu.clearRect(0,0,m,g),this.#Mu.fillStyle="rgba(0,0,0,0)",this.#Mu.fillRect(0,0,m,g),this.#Mu.drawImage(this.#Cu,0,0,m,g),this.dirtyTransform=!0;const callback=i=>{this.material.diffuseTexture.src=URL.createObjectURL(i)};this.#wu instanceof OffscreenCanvas?this.#wu.convertToBlob({type:"image/png"}).then(callback):this.#wu.toBlob(callback,"image/png")}}#zu=(i,m)=>{const g=this.#Ru.querySelector("foreignObject > div").style,x=this.#Pu.style,_=`_${i}`;this[_]=m,Object.defineProperty(this,i,{get:()=>this[_],set:m=>{this[_]=m,(i=>"number"==typeof i)(m)&&(i=>!["lineHeight","fontWeight"].includes(i))(i)&&(m=`${m}px`),g[i]=m,x[i]=m,this.#Bu&&cancelAnimationFrame(this.#Bu),this.#Bu=requestAnimationFrame(()=>{this.#$u()})}}),this[i]=m};#Ou(){this.#Pu=document.createElement("div"),this.#Pu.style.cssText=ga+";position:absolute;top:200px;left:0;visibility:hidden;text-rendering:optimizeLegibility",document.body.appendChild(this.#Pu)}#Nu(){const i=this.#Ru=document.createElementNS("http://www.w3.org/2000/svg","svg");i.setAttribute("xmlns","http://www.w3.org/2000/svg"),i.setAttribute("text-rendering","optimizeLegibility"),i.style.cssText="position:absolute;top:0px;left:0px;z-index:1;margin:0;padding:0;overflow:visible;background:transparent",i.innerHTML=`<rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,0)"/><foreignObject width="100%" height="100%" style="margin:0;padding:0;" overflow="visible"><div xmlns="http://www.w3.org/1999/xhtml" style="${ga}"></div></foreignObject>`}#Gu(){for(const[i,m]of Object.entries(xa))this.#zu(i,m)}}Object.freeze(ATextField);const _a=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include drawPicking;\r\n\r\nstruct Uniforms {\ruseDiffuseTexture:u32,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n};\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\r\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\rvar finalColor:vec4<f32>=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv);\r\n\rfinalColor=vec4<f32>(finalColor.rgb/finalColor.a,finalColor.a * uniforms.opacity * inputData.combinedOpacity);\r\n\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\r\n\r\rif (finalColor.a==0.0) {\rdiscard;\r}\r\n\rreturn finalColor;\r\n};\r\n");class TextFieldMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,m,g){super(i,"TEXT_FILED_MATERIAL",_a,2),g&&(this.name=g),this.diffuseTexture=m,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}Br.defineByPreset(TextFieldMaterial,[Br.PRESET_TEXTURE.DIFFUSE_TEXTURE,Br.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(TextFieldMaterial);var va="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t useBillboardPerspective:u32,\r\n\t useBillboard:u32,\r\n\t combinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_resolution=systemUniforms.resolution;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rlet input_vertexNormalVec4=vec4<f32>(input_vertexNormal,1.0);\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\r\n\r\nvar scaleMatrix:mat4x4<f32>;\r\rlet cameraPosition=vec3<f32>((u_cameraMatrix * u_modelMatrix)[3].xyz);\rlet objectPosition=input_position.xyz;\rlet distance=length(cameraPosition - objectPosition);\r\n\r\rlet scaleFactor=distance;\rscaleMatrix=mat4x4<f32>(\r10,0.0,0.0,0.0,\r0.0,10,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r\n\r\n\r\n\r\rif (u_useBillboard==1) {\r\r\rif (u_useBillboardPerspective==1) {\r\r\n\r} else {\r\rscaleMatrix=mat4x4<f32>(\rscaleFactor,0.0,0.0,0.0,\r0.0,scaleFactor,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r}\r\n\r\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(objectPosition,1.0);\rnormalPosition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(input_vertexNormal.xyz,1.0);\r\n\r\rvar temp=output.position/output.position.w;\routput.position=vec4<f32>(\rtemp.xy + objectPosition.xy * vec2<f32>(\r(u_projectionMatrix * u_modelMatrix)[0][0],\r(u_projectionMatrix * u_modelMatrix)[1][1]\r),\rtemp.zw\r);\r\n\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * scaleMatrix * vec4<f32>(objectPosition,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * scaleMatrix * vec4<f32>(input_vertexNormal.xyz,1.0);\r}\r\n\r\routput.position=u_projectionMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\r\n\r\rlet input_position=inputData.position;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\r\n\r\n\rvar scaleMatrix:mat4x4<f32>;\r\rlet cameraPosition=vec3<f32>((u_cameraMatrix * u_modelMatrix)[3].xyz);\rlet objectPosition=input_position.xyz;\rlet distance=length(cameraPosition - objectPosition);\r\n\r\rlet scaleFactor=distance;\rscaleMatrix=mat4x4<f32>(\r10,0.0,0.0,0.0,\r0.0,10,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r\rif (u_useBillboard==1) {\r\rif (u_useBillboardPerspective==1) {\r\r\n\r} else {\r\rscaleMatrix=mat4x4<f32>(\rscaleFactor,0.0,0.0,0.0,\r0.0,scaleFactor,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r}\r\n\r\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(objectPosition,1.0);\r\n\r\rvar temp=output.position/output.position.w;\routput.position=vec4<f32>(\rtemp.xy + objectPosition.xy * vec2<f32>(\r(u_projectionMatrix * u_modelMatrix)[0][0],\r(u_projectionMatrix * u_modelMatrix)[1][1]\r),\rtemp.zw\r);\r\n\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * scaleMatrix * vec4<f32>(objectPosition,1.0);\r}\routput.position=u_projectionMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";const ba=parseWGSL(va),ya=ba.uniforms.vertexUniforms;class TextField3D extends ATextField{#cu=1;#hu=1;constructor(i){super(i,(i,m)=>{this.#cu=i/1024,this.#hu=m/1024}),this._geometry=new Plane(i),this._material=new TextFieldMaterial(i,new BitmapTexture(i)),this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0}get geometry(){return this._geometry}set geometry(i){console.error("TextField3D can not change geometry")}get material(){return this._material}set material(i){console.error("TextField3D can not change material")}get renderTextureWidth(){return this.#cu}get renderTextureHeight(){return this.#hu}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_3D",ba,ya,va)}}br.defineByPreset(TextField3D,[[br.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],br.PRESET_BOOLEAN.USE_BILLBOARD]),Object.freeze(TextField3D);var Ta="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t combinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\routput.position=u_projectionMatrix * position;\r\n\r\n\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\routput.position=u_projectionMatrix * position;\r\n\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";const Sa=parseWGSL(Ta),wa=Sa.uniforms.vertexUniforms,Ma=mixInMesh2D(ATextField);class TextField2D extends Ma{#pn=1;#gn=1;#qu=!1;constructor(i,m=!1){super(i,(i,m)=>{this.#pn=i,this.#gn=m},!1),this._geometry=new Plane(i,1,1,1,1,1,!0),this._material=new TextFieldMaterial(i,new BitmapTexture(i)),this._material.transparent=!0,this.useSmoothing=m,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.primitiveState.cullMode=ni.FRONT}get useSmoothing(){return this.#qu}set useSmoothing(i){this.#qu=i,this.useSmoothing?(this._material.diffuseTextureSampler.minFilter=kn.LINEAR,this._material.diffuseTextureSampler.magFilter=kn.LINEAR,this._material.diffuseTextureSampler.mipmapFilter=On.LINEAR):(this._material.diffuseTextureSampler.minFilter=kn.NEAREST,this._material.diffuseTextureSampler.magFilter=kn.NEAREST,this._material.diffuseTextureSampler.mipmapFilter=null)}get width(){return this.#pn}get height(){return this.#gn}get geometry(){return this._geometry}set geometry(i){console.error("TextField2D can not change geometry")}get material(){return this._material}set material(i){console.error("TextField2D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_2D",Sa,wa,Ta)}}Object.freeze(TextField2D);var Ra=Object.freeze({__proto__:null,Group2D:Group2D,Group3D:Group3D,InstancingMesh:InstancingMesh,LINE_TYPE:ca,Line2D:class extends Line3D{constructor(i,m=ca.LINEAR,g="#fff"){super(i,m,g),this._material=new LineMaterial(i)}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("Line2D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("Line2D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_2D",ma,pa,ha)}addPoint(i=0,m=0,g=this.baseColor,x=1,_=0,b=0,y=0,T=0){super.addPoint(i,m,0,g,x,_,b,0,y,T,0)}addPointAt(i,m=0,g=0,x=this.baseColor,_=1,b=0,y=0,T=0,w=0){super.addPointAt(i,m,g,0,x,_,b,y,0,T,w,0)}},Line3D:Line3D,Mesh:Mesh,Object3DContainer:Object3DContainer,PARTICLE_EASE:Xi,ParticleEmitter:ParticleEmitter,Scene:Scene,SkyBox:class{dirtyPipeline=!0;modelMatrix=create$5();gpuRenderInfo;_geometry;_material;#_;#vr;#br;constructor(i,m){validateRedGPUContext(i),this.#_=i,this._geometry=new Box(i),this._material=new SkyBoxMaterial(i,m),this.#vr=new PrimitiveState(this),this.#vr.cullMode=ni.NONE,this.#br=new DepthStencilState(this),this.#br.depthWriteEnabled=!1}get skyboxTexture(){return this._material.skyboxTexture}set skyboxTexture(i){i?this._material.skyboxTexture=i:consoleAndThrowError("SkyBox requires a valid CubeTexture")}render(i){const{currentRenderPassEncoder:m}=i;this.#Ku(),this.gpuRenderInfo||this.#to(this.#_),this.dirtyPipeline&&(this.gpuRenderInfo.pipeline=this.#Wu(),this.dirtyPipeline=!1,i.numDirtyPipelines++);const{gpuRenderInfo:g}=this,{vertexUniformBindGroup:x,pipeline:_}=g,{indexBuffer:b}=this._geometry,{triangleCount:y,indexNum:T}=b;m.setPipeline(_),m.setVertexBuffer(0,this._geometry.vertexBuffer.gpuBuffer),m.setBindGroup(1,x),m.setBindGroup(2,this._material.gpuRenderInfo.fragmentUniformBindGroup),m.setIndexBuffer(b.gpuBuffer,"uint32"),m.drawIndexed(b.indexNum,1,0,0,0),i.num3DObjects++,i.numDrawCalls++,i.numTriangles+=y,i.numPoints+=T}#Ku(){const{changedMSAA:i}=this.#_.antialiasingManager;i&&(this.dirtyPipeline=!0)}#to(i){const{resourceManager:m}=this.#_,g=m.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||m.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(qi,1)),x=new ArrayBuffer(Ki.arrayBufferByteLength),_=new UniformBuffer(i,x);identity$2(this.modelMatrix),scale$5(this.modelMatrix,this.modelMatrix,[1e4,1e4,1e4]),_.writeBuffer(Ki.members.modelMatrix,this.modelMatrix);const b={layout:g,label:"VERTEX_BIND_GROUP_DESCRIPTOR_SKYBOX",entries:[{binding:0,resource:{buffer:_.gpuBuffer,offset:0,size:_.size}}]},y=i.gpuDevice.createBindGroup(b);this.gpuRenderInfo=new VertexGPURenderInfo(null,Ki,g,_,y,this.#Wu())}#Wu(){const{resourceManager:i,gpuDevice:m,antialiasingManager:g}=this.#_,x={code:Hi},_={module:i.createGPUShaderModule("VERTEX_MODULE_SKYBOX",x),entryPoint:"main",buffers:this._geometry.gpuRenderInfo.buffers},b=i.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||i.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(qi,1)),y={bindGroupLayouts:[i.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),b,this._material.gpuRenderInfo.fragmentBindGroupLayout]},T={label:"PIPELINE_DESCRIPTOR_SKYBOX",layout:m.createPipelineLayout(y),vertex:_,fragment:this._material.gpuRenderInfo.fragmentState,primitive:this.#vr.state,depthStencil:this.#br.state,multisample:{count:g.useMSAA?4:1}};return m.createRenderPipeline(T)}},Sprite2D:Sprite2D,Sprite3D:Sprite3D,SpriteSheet2D:SpriteSheet2D,SpriteSheet3D:SpriteSheet3D,SpriteSheetInfo:SpriteSheetInfo,TextField2D:TextField2D,TextField3D:TextField3D,View2D:View2D,View3D:View3D}),Pa=Object.freeze({__proto__:null,AmbientLight:AmbientLight,DirectionalLight:DirectionalLight,PointLight:PointLight,SpotLight:SpotLight});function calculatePositionOnCurve(i,m,g,x,_){const b=Math.cos(i),y=Math.sin(i),T=g/m*i,w=Math.cos(T);_[0]=x*(2+w)*.5*b,_[1]=x*(2+w)*y*.5,_[2]=x*Math.sin(T)*.5}var Ca=Object.freeze({__proto__:null,Box:Box,Circle:class extends Primitive{#ta=function(){return function(i,m,g,x,_,b){const y=[],T=[];let w,P,$;y.push(0,0,0,0,0,1,.5,.5);let H=0,z=3;for(;H<=x;)w=_+H/x*b,P=Math.cos(w),$=Math.sin(w),y.push(g*P,g*$,0,0,0,1,(P/g+1)/2,($/g+1)/2),H++,z+=3;for(z=1;z<=x;)T.push(z,z+1,0),z++;return createPrimitiveGeometry(m,y,T,i)}}();constructor(i,m=1,g=32,x=0,_=2*Math.PI){super(i);const b=`PRIMITIVE_CIRCLE_R${m}_S${g}_TS${x}_TL${_}`,y=i.resourceManager.cachedBufferState;let T=y[b];T||(T=y[b]=this.#ta(b,i,m,g,x,_)),this._setData(T)}},Cylinder:Cylinder,Plane:Plane,Primitive:Primitive,Sphere:Sphere,Torus:class extends Primitive{#ta=function(){return function(i,m,g,x,_,b,y,T){y=y||0;const w=(T=T||2*Math.PI)-y,P=_+1,$=b+1,H=[],z=[];for(let i=0;i<$;++i){const m=i/b,T=m*Math.PI*2,$=Math.sin(T),z=g+$*x,q=Math.cos(T),W=q*x;for(let i=0;i<P;++i){const g=i/_,x=y+g*w,b=Math.sin(x),T=Math.cos(x),P=b*z,ye=T*z,Ge=b*$,Ke=T*$;H.push(P,W,ye,Ge,q,Ke,g,1-m)}}for(let i=0;i<b;++i)for(let m=0;m<_;++m){const g=1+m,x=1+i;z.push(P*i+m,P*x+m,P*i+g),z.push(P*x+m,P*x+g,P*i+g)}return createPrimitiveGeometry(m,H,z,i)}}();constructor(i,m=1,g=.5,x=16,_=16,b=0,y=2*Math.PI){if(super(i),x<3)throw new Error("radialSubdivisions must be 3 or greater");if(_<3)throw new Error("verticalSubdivisions must be 3 or greater");const T=`PRIMITIVE_TORUS_R${m}_T${g}_RSD${x}_BSD${_}_SA${b}_EA${y}`,w=i.resourceManager.cachedBufferState;let P=w[T];P||(P=w[T]=this.#ta(T,i,m,g,x,_,b,y)),this._setData(P)}},TorusKnot:class extends Primitive{#ta=function(){return function(i,m,g,x,_,b,y,T){_=Math.floor(_),b=Math.floor(b);const w=[],P=[],$=[],H=[],z=[0,0,0],q=[0,0,0],W=[0,0,0],ye=[0,0,0],Ge=[0,0,0];for(let i=0;i<=_;++i){const m=i/_*y*Math.PI*2;calculatePositionOnCurve(m,y,T,g,z),calculatePositionOnCurve(m+.01,y,T,g,q),ye[0]=q[0]-z[0],ye[1]=q[1]-z[1],ye[2]=q[2]-z[2],Ge[0]=q[0]+z[0],Ge[1]=q[1]+z[1],Ge[2]=q[2]+z[2];{const i=ye[0],m=ye[1],g=ye[2],x=Ge[0],_=Ge[1],b=Ge[2];W[0]=m*b-g*_,W[1]=g*x-i*b,W[2]=i*_-m*x}{const i=W[0],m=W[1],g=W[2],x=ye[0],_=ye[1],b=ye[2];Ge[0]=m*b-g*_,Ge[1]=g*x-i*b,Ge[2]=i*_-m*x}{let i=W[0],m=W[1],g=W[2],x=i*i+m*m+g*g;x>0&&(x=1/Math.sqrt(x||1)),W[0]=W[0]*x,W[1]=W[1]*x,W[2]=W[2]*x}{let i=Ge[0],m=Ge[1],g=Ge[2],x=i*i+m*m+g*g;x>0&&(x=1/Math.sqrt(x)),Ge[0]=Ge[0]*x,Ge[1]=Ge[1]*x,Ge[2]=Ge[2]*x}for(let m=0;m<=b;++m){const g=m/b*Math.PI*2,y=-x*Math.cos(g),T=x*Math.sin(g);$[0]=z[0]+(y*Ge[0]+T*W[0]),$[1]=z[1]+(y*Ge[1]+T*W[1]),$[2]=z[2]+(y*Ge[2]+T*W[2]),w.push($[0],$[1],$[2]);{H[0]=$[0]-z[0],H[1]=$[1]-z[1],H[2]=$[2]-z[2];let i=H[0],m=H[1],g=H[2],x=i*i+m*m+g*g;x>0&&(x=1/Math.sqrt(x)),H[0]=H[0]*x,H[1]=H[1]*x,H[2]=H[2]*x}w.push(H[0],H[1],H[2],i/_,m/b)}}for(let i=1;i<=_;i++)for(let m=1;m<=b;m++){const g=(b+1)*(i-1)+(m-1),x=(b+1)*i+(m-1),_=(b+1)*i+m,y=(b+1)*(i-1)+m;P.push(g,x,y),P.push(x,_,y)}return createPrimitiveGeometry(m,w,P,i)}}();constructor(i,m=1,g=.4,x=64,_=8,b=2,y=3){super(i);const T=`PRIMITIVE_TORUS_NUT_R${m}_T${g}_TS${x}_RS${_}_P${b}_Q${y}`,w=i.resourceManager.cachedBufferState;let P=w[T];P||(P=w[T]=this.#ta(T,i,m,g,x,_,b,y)),this._setData(P)}}});async function float32ToUint8WithToneMapping(i,m,g){const x=performance.now(),{gpuDevice:_}=i,{exposure:b,width:y,height:T,workgroupSize:w=[8,8]}=g,P=m.length/4,$=function(i){return`struct Constants {exposure:f32,width:u32,height:u32,}@group(0) @binding(0) var<storage,read> inputData:array<f32>;@group(0) @binding(1) var<storage,read_write> outputData:array<u32>;@group(0) @binding(2) var<uniform> constants:Constants;/* ACES 톤매핑 함수 */fn acesToneMapping(x:f32) -> f32 {let a=2.51;let b=0.03;let c=2.43;let d=0.59;let e=0.14;return max(0.0,(x * (a * x + b))/(x * (c * x + d) + e));}/* Linear → sRGB 감마 보정 */fn linearToSRGB(linearValue:f32) -> f32 {if (linearValue <=0.0031308) {return 12.92 * linearValue;} else {return 1.055 * pow(linearValue,1.0/2.4) - 0.055;}}@compute @workgroup_size(${i[0]},${i[1]})fn main(@builtin(global_invocation_id) global_id:vec3<u32>) {let x=global_id.x;let y=global_id.y;/* 범위 체크 */if (x >=constants.width || y >=constants.height) {return;}let pixelIndex=y * constants.width + x;let baseIndex=pixelIndex * 4u;/* 🎯 RGBA 각 채널 처리 */var processedPixel=0u;for (var channel=0u;channel < 4u;channel++) {let inputIndex=baseIndex + channel;let originalVal=inputData[inputIndex];/* 🎯 노출값 적용 */let exposedVal=originalVal * constants.exposure;/* 🎬 ACES 톤매핑 적용 */let toneMappedVal=acesToneMapping(exposedVal);/* 🔧 감마 보정 적용 (sRGB) */let gammaCorrectedVal=linearToSRGB(toneMappedVal);/* 🎯 최종 8bit 변환 */let uint8Val=u32(round(clamp(gammaCorrectedVal,0.0,1.0) * 255.0));/* 🔧 4개 채널을 하나의 u32에 패킹 */processedPixel |=(uint8Val << (channel * 8u));}outputData[pixelIndex]=processedPixel;}`}(w);try{const i=_.createShaderModule({code:$,label:"hdr_tonemapping_shader"}),g=function(i,m,g){const x=i.createBuffer({size:m.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"hdr_input_float32_buffer"}),_=i.createBuffer({size:4*g,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"hdr_output_uint8_buffer"}),b=i.createBuffer({size:12,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"hdr_constants_buffer"}),y=i.createBuffer({size:4*g,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"hdr_read_buffer"});return i.queue.writeBuffer(x,0,m),{inputBuffer:x,outputBuffer:_,constantsBuffer:b,readBuffer:y}}(_,m,P);!function(i,m,g,x,_){const b=new ArrayBuffer(12),y=new DataView(b);y.setFloat32(0,g,!0),y.setUint32(4,x,!0),y.setUint32(8,_,!0),i.queue.writeBuffer(m,0,b)}(_,g.constantsBuffer,b,y,T);const{computePipeline:H,bindGroup:z}=function(i,m,g){const x=i.createComputePipeline({layout:"auto",compute:{module:m,entryPoint:"main"},label:"hdr_tonemapping_pipeline"}),_=i.createBindGroup({layout:x.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g.inputBuffer}},{binding:1,resource:{buffer:g.outputBuffer}},{binding:2,resource:{buffer:g.constantsBuffer}}],label:"hdr_tonemapping_bindgroup"});return{computePipeline:x,bindGroup:_}}(_,i,g),q=await async function(i,m,g,x,_,b,y,T,w){const P=i.createCommandEncoder({label:"hdr_tonemapping_encoder"}),$=P.beginComputePass({label:"hdr_tonemapping_pass"});$.setPipeline(m),$.setBindGroup(0,g);const H=Math.ceil(b/T[0]),z=Math.ceil(y/T[1]);if(H>65535||z>65535)throw new Error(`이미지가 너무 큽니다. 최대 크기:${65535*T[0]} × ${65535*T[1]}`);$.dispatchWorkgroups(H,z),$.end(),P.copyBufferToBuffer(x,0,_,0,4*w),i.queue.submit([P.finish()]),await _.mapAsync(GPUMapMode.READ);const q=new Uint32Array(_.getMappedRange()),W=q.byteLength>0?new Uint8Array(q.buffer.slice(q.byteOffset,q.byteOffset+q.byteLength)):new Uint8Array(4);return _.unmap(),W}(_,H,z,g.outputBuffer,g.readBuffer,y,T,w,P);!function(i){i.inputBuffer.destroy(),i.outputBuffer.destroy(),i.constantsBuffer.destroy(),i.readBuffer.destroy()}(g);return{data:q,processedPixels:P,executionTime:performance.now()-x}}catch(i){throw console.error("톤매핑 처리 실패:",i),i}}class HDRLoader{#Xu=!0;constructor(i=!0){this.#Xu=i}get enableDebugLogs(){return this.#Xu}set enableDebugLogs(i){this.#Xu=i}async loadHDRFile(i){this.#Xu&&En(`HDR 파일 로딩 시작:${i}`);const m=await fetch(i);if(!m.ok)throw new Error(`HTTP ${m.status}:${m.statusText}`);const g=await m.arrayBuffer(),x=new Uint8Array(g),_=this.#ju(x,i);return this.#Yu(_)}#Yu(i){this.#Xu&&En("HDR 데이터 분석 시작 (원본 데이터 보존)...");const m=this.#Zu(i),g=this.#Ju(m);return this.#Xu&&En(`권장 노출값 계산:${g.toFixed(3)} (원본 데이터는 보존)`),{...i,recommendedExposure:g,luminanceStats:m}}#Zu(i){let m=1/0,g=0,x=0;const _=i.width*i.height;for(let _=0;_<i.data.length;_+=4){const b=.2126*i.data[_]+.7152*i.data[_+1]+.0722*i.data[_+2];m=Math.min(m,b),g=Math.max(g,b),x+=b}return{min:Math.max(.001,m),max:g,average:Math.max(.001,x/_),median:Math.max(.001,x/_)}}#Ju(i){const{average:m,median:g,max:x}=i;let _=.18;m<.01?_=.5:m<.05?_=.36:m>2?_=.09:m>.8&&(_=.12);let b=_/Math.max(Math.pow(m*g,.5),.001);const y=x/Math.max(i.min,.001);m<.05?b*=2.5:m<.1&&(b*=1.8),y>1e3?b*=.8:y>100&&(b*=.9),x>10?b*=.5:x>5?b*=.7:x>2&&(b*=.85);const T=g/m;return T<.3?b*=.8:T>1.5&&(b*=1.2),b=Math.max(1,Math.min(15,b)),b}#ju(i,m){const g=this.#Qu(i);if(this.#Xu&&En(`파일 형식:${g.format}`),!g.isValid)throw new Error(g.error||"지원되지 않는 파일 형식입니다");if(m.toLowerCase().endsWith(".hdr")){this.#Xu&&(En("파일 첫 200바이트:"),this.#el(i.slice(0,200)));const m=this.#tl(i);return this.#Xu&&this.#rl(m),m}throw m.toLowerCase().endsWith(".exr")?new Error("EXR format not supported yet"):new Error(`Unsupported HDR format:${m}`)}#tl(i){let m=0,g="";const x={};for(;m<i.length;){const x=String.fromCharCode(i[m++]);if("\n"===x)break;g+=x}if(!g.startsWith("#?RADIANCE")&&!g.startsWith("#?RGBE"))throw new Error("Invalid HDR file header");for(;m<i.length;){for(g="";m<i.length;){const x=String.fromCharCode(i[m++]);if("\n"===x)break;g+=x}if(""===g.trim())break;const _=g.indexOf("=");if(_>0){const i=g.substring(0,_).trim(),m=g.substring(_+1).trim();x[i]=m}}for(g="";m<i.length;){const x=String.fromCharCode(i[m++]);if("\n"===x)break;g+=x}const _=g.match(/-Y\s+(\d+)\s+\+X\s+(\d+)/);if(!_)throw new Error("Invalid resolution format in HDR file");const b=parseInt(_[1]),y=parseInt(_[2]);let T;x.EXPOSURE&&(T=parseFloat(x.EXPOSURE),this.#Xu&&En(`파일 노출값:${T.toFixed(3)}`));const w=new Float32Array(y*b*4);let P=0;for(let g=0;g<b;g++){const g=this.#nl(i,m,y);m=g.nextOffset;for(let i=0;i<y;i++){const m=4*i,x=g.data[m],_=g.data[m+1],b=g.data[m+2],y=g.data[m+3];if(0===y)w[P++]=0,w[P++]=0,w[P++]=0,w[P++]=1;else{const i=Math.pow(2,y-128-8);w[P++]=x*i,w[P++]=_*i,w[P++]=b*i,w[P++]=1}}}return{data:w,width:y,height:b,exposure:T}}#Qu(i){if(i.length<50)return{isValid:!1,format:"unknown",error:"파일이 너무 작습니다"};const m=new TextDecoder("ascii",{fatal:!1}).decode(i.slice(0,50));return m.startsWith("#?RADIANCE")||m.startsWith("#?RGBE")?{isValid:!0,format:"RGBE/Radiance"}:m.includes("RADIANCE")||m.includes("RGBE")?{isValid:!0,format:"RGBE/Radiance (variant)"}:{isValid:!1,format:"unknown",error:"지원되지 않는 HDR 형식입니다"}}#nl(i,m,g){const x=new Uint8Array(4*g);if(2===i[m]&&2===i[m+1]&&i[m+2]===(g>>8&255)&&i[m+3]===(255&g)){m+=4;for(let _=0;_<4;_++){let b=_;for(;b<4*g;){const _=i[m++];if(_>128){const y=_-128,T=i[m++];for(let i=0;i<y&&b<4*g;i++)x[b]=T,b+=4}else{const y=_;for(let _=0;_<y&&b<4*g;_++)x[b]=i[m++],b+=4}}}}else for(let _=0;_<4*g;_++)x[_]=i[m++];return{data:x,nextOffset:m}}#rl(i){if(this.#Xu){En("HDR 정보:"),En(`크기:${i.width} x ${i.height}`),En(`데이터 길이:${i.data.length}`),En("예상 픽셀 수:"+i.width*i.height*4),En("첫 4픽셀 값 (원본):");for(let m=0;m<Math.min(16,i.data.length);m+=4){const g=i.data[m],x=i.data[m+1],_=i.data[m+2],b=i.data[m+3];En(`픽셀 ${m/4}:R=${g.toFixed(3)},G=${x.toFixed(3)},B=${_.toFixed(3)},A=${b.toFixed(3)}`)}}}#el(i){if(this.#Xu)for(let m=0;m<i.length;m+=16){const g=Array.from(i.slice(m,m+16)).map(i=>i.toString(16).padStart(2,"0")).join(" "),x=Array.from(i.slice(m,m+16)).map(i=>i>=32&&i<=126?String.fromCharCode(i):".").join("");En(`${m.toString(16).padStart(8,"0")}:${g.padEnd(48," ")} |${x}|`)}}}class HDRTexture extends ManagedResourceBase{#j;#bt;#Z;#J;#Q;#il;#te=0;#al=1024;#sl=new HDRLoader;#re;#ol=1;#ul=1;#ll;#ne;#ie;#cl=!1;constructor(i,m,g,x,_=1024,b=!0){if(super(i,"managedHDRTextureState"),this.#ne=g,this.#ie=x,this.#Q=b,this.#re="rgba8unorm",this.#al=_,m){this.#hl(m),this.#bt=m,this.#Z=m||this.uuid;const{table:i}=this.targetResourceManagedState;let g;for(const m in i)if(i[m].cacheKey===this.#Z){g=i[m];break}if(g){const m=i[g.uuid].texture;return this.#ne?.(m),m}this.src=m,this.#ae()}}#hl(i){if(!i||"string"!=typeof i)throw new Error("HDR 파일 경로가 필요합니다");if(!i.toLowerCase().endsWith(".hdr"))throw new Error(`지원되지 않는 형식입니다. .hdr 형식만 지원됩니다. 입력된 파일:${i}`)}get cacheKey(){return this.#Z}get videoMemorySize(){return this.#te}get gpuTexture(){return this.#j}get mipLevelCount(){return this.#J}get src(){return this.#bt}set src(i){const m=i?.src||i;this.#hl(m),this.#bt=m,this.#Z=i?.cacheKey||m||this.uuid,this.#cl=!1,this.#bt&&this.#fl(this.#bt)}get useMipmap(){return this.#Q}set useMipmap(i){this.#Q!==i&&(this.#Q=i,this.#cl=!1,this.#oe())}get exposure(){return this.#ol}#dl=null;set exposure(i){const m=Math.max(.01,Math.min(20,i));this.#ol!==m&&(this.#ol=m,this.#dl&&clearTimeout(this.#dl),this.#dl=setTimeout(()=>{this.#il&&(this.#cl&&this.#j?this.#ml():this.#oe()),this.#dl=null},50))}get recommendedExposure(){return this.#ul}get luminanceAnalysis(){return this.#ll}resetToRecommendedExposure(){this.exposure=this.#ul}static isSupportedFormat(i){return!(!i||"string"!=typeof i)&&i.toLowerCase().endsWith(".hdr")}static getSupportedFormats(){return[".hdr"]}destroy(){const i=this.#j;this.#ue(null),this.#cl=!1,this.__fireListenerList(!0),this.#bt=null,this.#Z=null,this.#ll=null,this.#le(),i&&i.destroy()}async#fl(i){try{const m=await this.#sl.loadHDRFile(i);this.#il=m,this.#ul=m.recommendedExposure||1,this.#ol=this.#ul,m.luminanceStats&&(this.#ll={averageLuminance:m.luminanceStats.average,maxLuminance:m.luminanceStats.max,minLuminance:m.luminanceStats.min,medianLuminance:m.luminanceStats.median,percentile95:.95*m.luminanceStats.max,percentile99:.99*m.luminanceStats.max,recommendedExposure:this.#ul},En("휘도 분석 완료:",this.#ll)),En(`HDR 데이터 로드 완료:${m.width}x${m.height},권장 노출:${this.#ul.toFixed(3)},현재 노출:${this.#ol.toFixed(3)}`),await this.#oe(),this.#ne?.(this)}catch(i){console.error("HDR loading error (.hdr 형식):",i),this.#ie?.(i)}}#ue(i){this.#j=i,i||(this.#il=null,this.#cl=!1),this.__fireListenerList()}#ae(){basicRegisterResource(this,new ResourceStateBitmapTexture(this))}#le(){basicUnregisterResource(this)}async#oe(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext;if(this.#cl&&this.#j)return void await this.#ml();await i.queue.onSubmittedWorkDone();const g=this.#j;this.#j=null,this.targetResourceManagedState.videoMemory-=this.#te,this.#te=0;const x={size:[this.#al,this.#al,6],format:this.#re,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,mipLevelCount:this.#Q?getMipLevelCount(this.#al,this.#al):1,dimension:"2d",label:`${this.#bt}_cubemap_exp${this.#ol.toFixed(2)}`},_=i.createTexture(x);this.#ue(_),this.#J=x.mipLevelCount||1,this.#te=calculateTextureByteSize(x),this.targetResourceManagedState.videoMemory+=this.#te,await this.#ml(),this.#cl=!0,g&&(await i.queue.onSubmittedWorkDone(),g.destroy())}async#ml(){if(!this.#j||!this.#il)return void console.warn("큐브맵 텍스처 또는 HDR 데이터가 없어 업데이트를 건너뜁니다.");const{gpuDevice:i}=this.redGPUContext,{width:m,height:g}=this.#il,x={size:[m,g],format:this.#re,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:`${this.#bt}_temp_exp${this.#ol.toFixed(2)}`},_=await this.#pl(i,this.#il,x);await this.#gl(_),_.destroy()}async#gl(i){const{gpuDevice:m,resourceManager:g}=this.redGPUContext,{mipmapGenerator:x}=g,_=m.createShaderModule({code:"struct VertexOutput {\r@builtin(position) position:vec4<f32>,\r@location(0) texCoord:vec2<f32>,\r\n}\r\n\r\n@vertex fn vs_main(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput {\rvar pos=array<vec2<f32>,6>(\rvec2<f32>(-1.0,-1.0),vec2<f32>( 1.0,-1.0),vec2<f32>(-1.0, 1.0),\rvec2<f32>(-1.0, 1.0),vec2<f32>( 1.0,-1.0),vec2<f32>( 1.0, 1.0)\r);\r\n\rvar texCoord=array<vec2<f32>,6>(\rvec2<f32>(1.0,0.0),vec2<f32>(0.0,0.0),vec2<f32>(1.0,1.0),\rvec2<f32>(1.0,1.0),vec2<f32>(0.0,0.0),vec2<f32>(0.0,1.0)\r);\r\n\rvar output:VertexOutput;\routput.position=vec4<f32>(pos[vertexIndex],0.0,1.0);\routput.texCoord=texCoord[vertexIndex];\rreturn output;\r\n}\r\n\r\n@group(0) @binding(0) var equirectangularTexture:texture_2d<f32>;\r\n@group(0) @binding(1) var textureSampler:sampler;\r\n@group(0) @binding(2) var<uniform> faceMatrix:mat4x4<f32>;\r\n\r\n@fragment fn fs_main(input:VertexOutput) -> @location(0) vec4<f32> {\rlet ndc=vec2<f32>(\rinput.texCoord.x * 2.0 - 1.0,\r(1.0 - input.texCoord.y) * 2.0 - 1.0\r);\r\n\rvar localDirection=vec3<f32>(ndc.x,ndc.y,1.0);\rlet worldDirection=normalize((faceMatrix * vec4<f32>(localDirection,0.0)).xyz);\r\n\rlet theta=atan2(worldDirection.z,worldDirection.x);\rlet phi=acos(clamp(worldDirection.y,-1.0,1.0));\r\n\rvar u=(theta + 3.14159265359)/(2.0 * 3.14159265359);\rvar v=phi/3.14159265359;\r\n\ru=fract(u + 1.0);\rv=clamp(v,0.0001,0.9999);\r\n\rlet color=textureSample(equirectangularTexture,textureSampler,vec2<f32>(u,v));\rreturn color;\r\n}\r\n"}),b=m.createRenderPipeline({layout:"auto",vertex:{module:_,entryPoint:"vs_main"},fragment:{module:_,entryPoint:"fs_main",targets:[{format:this.#re}]}}),y=new Sampler(this.redGPUContext,{magFilter:kn.LINEAR,minFilter:kn.LINEAR,mipmapFilter:On.LINEAR,addressModeU:An.CLAMP_TO_EDGE,addressModeV:An.CLAMP_TO_EDGE,addressModeW:An.CLAMP_TO_EDGE}),T=this.#xl();for(let m=0;m<6;m++)await this.#_l(b,y,m,T[m],i);this.#Q&&x.generateMipmap(this.#j,{size:[this.#al,this.#al,6],format:this.#re,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,mipLevelCount:this.#J,dimension:"2d"})}async#pl(i,m,g){const x=i.createTexture(g);let _,b;if("rgba8unorm"!==this.#re)throw new Error(`지원되지 않는 텍스처 포맷:${this.#re}`);_=4;b=(await this.#vl(m.data)).buffer;return i.queue.writeTexture({texture:x},b,{bytesPerRow:m.width*_,rowsPerImage:m.height},{width:m.width,height:m.height}),x}async#vl(i){return(await float32ToUint8WithToneMapping(this.redGPUContext,i,{exposure:this.#ol,width:this.#il.width,height:this.#il.height,workgroupSize:[8,8]})).data}#xl(){return[new Float32Array([0,0,-1,0,0,-1,0,0,-1,0,0,0,0,0,0,1]),new Float32Array([0,0,1,0,0,-1,0,0,1,0,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,-1,0,0,1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1]),new Float32Array([-1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1])]}async#_l(i,m,g,x,_){const{gpuDevice:b}=this.redGPUContext,y=b.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`hdr_face_${g}_uniform`});b.queue.writeBuffer(y,0,x);const T=b.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:_.createView()},{binding:1,resource:m.gpuSampler},{binding:2,resource:{buffer:y}}]}),w=b.createCommandEncoder(),P=w.beginRenderPass({colorAttachments:[{view:this.#j.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:g,arrayLayerCount:1}),clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}]});P.setPipeline(i),P.setBindGroup(0,T),P.draw(6,1,0,0),P.end(),b.queue.submit([w.finish()]),y.destroy()}}Object.freeze(HDRTexture);class IBL{#_;#bl;#yl;#Tl;#Sl;#wl;#x=createUUID();#re="rgba8unorm";#Ml;get exposure(){if(this.#Ml instanceof HDRTexture)return this.#Ml.exposure}set exposure(i){validatePositiveNumberRange(i),this.#Ml instanceof HDRTexture&&(this.#Ml.exposure=i)}constructor(i,m,g=1024){this.#_=i,this.#yl=new CubeTexture(i,[],!1,void 0,void 0,this.#re),this.#Tl=new CubeTexture(i,[],!1,void 0,void 0,this.#re),this.#Ml="string"==typeof m?new HDRTexture(i,m,i=>{this.#bl=i.gpuTexture,this.#Vi()},void 0,g,!0):new CubeTexture(i,m,!0,i=>{this.#bl=i.gpuTexture,this.#Vi()})}get irradianceTexture(){return this.#Tl}get environmentTexture(){return this.#yl}async#Vi(){this.#yl.setGPUTextureDirectly(this.#bl,`${this.#x}_environmentTexture`);const i=await this.#Rl(this.#bl);this.#Tl.setGPUTextureDirectly(i,`${this.#x}_irradianceTexture`,!1)}async#Rl(i){const{gpuDevice:m}=this.#_,g=m.createTexture({size:[32,32,6],format:this.#re,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:1,label:`${this.#x}_irradianceTexture`}),x=m.createShaderModule({code:"struct VertexOutput {\r@builtin(position) position:vec4<f32>,\r@location(0) texCoord:vec2<f32>,\r\n}\r\n\r\n@vertex fn vs_main(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput {\rvar pos=array<vec2<f32>,6>(\rvec2<f32>(-1.0,-1.0),vec2<f32>( 1.0,-1.0),vec2<f32>(-1.0, 1.0),\rvec2<f32>(-1.0, 1.0),vec2<f32>( 1.0,-1.0),vec2<f32>( 1.0, 1.0)\r);\r\n\rvar texCoord=array<vec2<f32>,6>(\rvec2<f32>(1.0,0.0),vec2<f32>(0.0,0.0),vec2<f32>(1.0,1.0),\rvec2<f32>(1.0,1.0),vec2<f32>(0.0,0.0),vec2<f32>(0.0,1.0)\r);\r\n\rvar output:VertexOutput;\routput.position=vec4<f32>(pos[vertexIndex],0.0,1.0);\routput.texCoord=texCoord[vertexIndex];\rreturn output;\r\n}\r\n\r\n@group(0) @binding(0) var environmentTexture:texture_cube<f32>;\r\n@group(0) @binding(1) var environmentSampler:sampler;\r\n@group(0) @binding(2) var<uniform> faceMatrix:mat4x4<f32>;\r\n\r\nconst PI=3.14159265359;\r\n\r\n@fragment fn fs_main(input:VertexOutput) -> @location(0) vec4<f32> {\r\rlet ndc=vec2<f32>(\rinput.texCoord.x * 2.0 - 1.0,\r1.0 - input.texCoord.y * 2.0 \r);\r\n\r\rlet localDirection=vec3<f32>(ndc.x,ndc.y,1.0);\r\n\r\rlet worldDirection=normalize((faceMatrix * vec4<f32>(localDirection,0.0)).xyz);\rlet normal=worldDirection;\r\n\rvar irradiance=vec3<f32>(0.0);\r\n\r\rvar up=vec3<f32>(0.0,1.0,0.0);\rlet tangent=normalize(cross(up,normal));\rlet bitangent=normalize(cross(normal,tangent));\r\n\r\rlet sampleCount=32u;\rlet invSampleCount=1.0/f32(sampleCount);\r\n\rfor (var i=0u;i < sampleCount;i++) {\rfor (var j=0u;j < sampleCount;j++) {\rlet u1=(f32(i) + 0.5) * invSampleCount;\rlet u2=(f32(j) + 0.5) * invSampleCount;\r\n\rlet cosTheta=sqrt(u1);\rlet sinTheta=sqrt(1.0 - u1);\rlet phi=2.0 * PI * u2;\r\n\rlet cosPhi=cos(phi);\rlet sinPhi=sin(phi);\r\n\rlet sampleVec=vec3<f32>(\rsinTheta * cosPhi,\rsinTheta * sinPhi,\rcosTheta\r);\r\n\rlet worldSample=sampleVec.x * tangent +\rsampleVec.y * bitangent +\rsampleVec.z * normal;\r\n\rlet sampleColor=textureSample(environmentTexture,environmentSampler,worldSample);\rirradiance +=sampleColor.rgb * cosTheta;\r}\r}\r\n\rirradiance=irradiance * PI * invSampleCount * invSampleCount;\r\n\rreturn vec4<f32>(irradiance,1.0);\r\n}\r\n"}),_=m.createRenderPipeline({layout:"auto",vertex:{module:x,entryPoint:"vs_main"},fragment:{module:x,entryPoint:"fs_main",targets:[{format:this.#re}]}}),b=new Sampler(this.#_,{magFilter:kn.LINEAR,minFilter:kn.LINEAR,mipmapFilter:On.LINEAR,addressModeU:An.CLAMP_TO_EDGE,addressModeV:An.CLAMP_TO_EDGE,addressModeW:An.CLAMP_TO_EDGE}),y=this.#xl();for(let m=0;m<6;m++)await this.#Pl(_,b,m,y[m],i,g);return g}async#Pl(i,m,g,x,_,b){const{gpuDevice:y}=this.#_,T=y.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`irradiance_face_${g}_uniform`});y.queue.writeBuffer(T,0,x);const w=y.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:_.createView({dimension:"cube"})},{binding:1,resource:m.gpuSampler},{binding:2,resource:{buffer:T}}]}),P=y.createCommandEncoder({label:`ibl_irradiance_face_${g}_encoder`}),$=P.beginRenderPass({colorAttachments:[{view:b.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:g,arrayLayerCount:1}),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],label:`irradiance_face_${g}_renderpass`});$.setPipeline(i),$.setBindGroup(0,w),$.draw(6,1,0,0),$.end(),y.queue.submit([P.finish()]),T.destroy()}#xl(){return[new Float32Array([0,0,-1,0,0,-1,0,0,-1,0,0,0,0,0,0,1]),new Float32Array([0,0,1,0,0,-1,0,0,1,0,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,-1,0,0,1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1]),new Float32Array([-1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1])]}}Object.freeze(IBL);const Ia={animationSpeed:1,animationX:.1,animationY:.1};class ANoiseTexture extends ManagedResourceBase{cacheKey;mipLevelCount;videoMemorySize;useMipmap;src;#j;#Bi=8;#Di=8;#Ui=1;#ki;#Oi;#Ni;#Fi;#ui;#li;#pn;#gn;#Cl;#Il=0;#El=1;#Ll=Ia.animationX;#Bl=Ia.animationY;constructor(i,m=1024,g=1024,x){super(i,"managedBitmapTextureState"),validateUintRange(m,2,2048),validateUintRange(g,2,2048),this.#pn=m,this.#gn=g,this.#Cl=x,this.#Vi(i),this.#j=this.#Ki(i,m,g),this.#Xi(),this.#ae()}get animationSpeed(){return this.#El}set animationSpeed(i){validatePositiveNumberRange(i),this.#El=i,this.updateUniform("animationSpeed",i)}get animationX(){return this.#Ll}set animationX(i){validateNumber(i),this.#Ll=i,this.updateUniform("animationX",i)}get animationY(){return this.#Bl}set animationY(i){validateNumber(i),this.#Bl=i,this.updateUniform("animationY",i)}get uniformInfo(){return this.#li}get gpuTexture(){return this.#j}get time(){return this.#Il}set time(i){validatePositiveNumberRange(i),this.#Il=i,this.updateUniform("time",i/1e3)}updateUniform(i,m){this.#li.members[i]&&(this.#ui.writeBuffer(this.#li.members[i],m),this.#Cl[i]=m),this.#Xi()}updateUniforms(i){Object.entries(i).forEach(([i,m])=>{this.#li.members[i]&&(this.#ui.writeBuffer(this.#li.members[i],m),this.#Cl[i]=m)}),this.#Xi()}render(i){this.updateUniform("time",i),this.#Xi()}#Vi(i){const{gpuDevice:m}=i,g=this.#Dl();this.cacheKey=createUUID(),this.#ki=m.createShaderModule({code:g}),this.#Ni=this.#zi(i),this.#Fi=this.#qi(m,this.#ki,this.#Ni);const x=parseWGSL(g);this.#li=x.uniforms.uniforms;const _=new ArrayBuffer(this.#li.arrayBufferByteLength);this.#ui=new UniformBuffer(i,_,`${this.constructor.name}_UniformBuffer`),this.#Cl.uniformDefaults&&this.updateUniforms({...Ia,...this.#Cl.uniformDefaults})}#Dl(){return`${`struct Uniforms {time:f32,animationSpeed:f32,animationX:f32,animationY:f32,${this.#Cl.uniformStruct||""}};`}@group(0) @binding(0) var<uniform> uniforms:Uniforms;@group(0) @binding(1) var outputTexture:texture_storage_2d<rgba8unorm,write>;${this.#Cl.helperFunctions||""}@compute @workgroup_size(${this.#Bi},${this.#Di},${this.#Ui})fn main (@builtin(global_invocation_id) global_id:vec3<u32>,){let index=vec2<u32>(global_id.xy);let dimensions:vec2<u32>=textureDimensions(outputTexture);/* 경계 체크 */if (index.x >=dimensions.x || index.y >=dimensions.y) {return;}let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let base_uv=vec2<f32>((f32(index.x) + 0.5)/dimW,(f32(index.y) + 0.5)/dimH);${this.#Cl.mainLogic}textureStore(outputTexture,index,finalColor);}`}#Xi(){if(!this.#Oi)return;const i=this.redGPUContext.gpuDevice.createCommandEncoder(),m=i.beginComputePass();m.setPipeline(this.#Fi),m.setBindGroup(0,this.#Oi),m.dispatchWorkgroups(Math.ceil(this.#pn/this.#Bi),Math.ceil(this.#gn/this.#Di)),m.end(),this.redGPUContext.gpuDevice.queue.submit([i.finish()])}#zi(i){return i.resourceManager.createBindGroupLayout("NoiseTextureBindGroupLayout",{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm"}}]})}#Ki(i,m,g){const x=i.gpuDevice.createTexture({size:{width:m,height:g},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,label:`NoiseTexture_${m}x${g}_${Date.now()}`}),_=x.createView();return this.#Oi=this.#Wi(i,this.#Ni,_),x}#Wi(i,m,g){return i.gpuDevice.createBindGroup({layout:m,entries:[{binding:0,resource:{buffer:this.#ui.gpuBuffer,offset:0,size:this.#ui.gpuBuffer.size}},{binding:1,resource:g}]})}#qi(i,m,g){return i.createComputePipeline({layout:i.createPipelineLayout({bindGroupLayouts:[g]}),compute:{module:m,entryPoint:"main"}})}#ae(){basicRegisterResource(this,new mn(this))}#le(){basicUnregisterResource(this)}}const Ea={MODE_1D:1,MODE_2D:2,MODE_3D:3};Object.freeze(Ea);const mergerNoiseUniformStruct=(i,m)=>[i,m].filter(Boolean).join("\n"),mergerNoiseUniformDefault=(i,m)=>({...i,...m||{}}),mergerNoiseHelperFunctions=(i,m)=>[i,m].filter(Boolean).join("\n");const La=Object.values(Ea),Ba={frequency:8,amplitude:1,octaves:1,persistence:.5,lacunarity:2,seed:0,noiseDimension:Ea.MODE_2D};const Da={EUCLIDEAN:0,MANHATTAN:1,CHEBYSHEV:2};Object.freeze(Da);const Ua={F1:0,F2:1,F2_MINUS_F1:2,F1_PLUS_F2:3,CELL_ID:4,CELL_ID_COLOR:5};Object.freeze(Ua);const Aa=Object.values(Da),ka=Object.values(Ua),Oa={frequency:8,distanceScale:1,octaves:1,persistence:.5,lacunarity:2,seed:0,distanceType:Da.EUCLIDEAN,outputType:Ua.F1,jitter:1,cellIdColorIntensity:1};var Na=Object.freeze({__proto__:null,ANoiseTexture:ANoiseTexture,AUniformBaseBuffer:AUniformBaseBuffer,BitmapTexture:BitmapTexture,CubeTexture:CubeTexture,HDRTexture:HDRTexture,IBL:IBL,IndexBuffer:IndexBuffer,InterleavedStructElement:InterleavedStructElement,NOISE_DIMENSION:Ea,ResourceBase:ResourceBase,ResourceManager:ResourceManager,ResourceState:ResourceState,Sampler:Sampler,SimplexTexture:class extends ANoiseTexture{#Ul=Ba.frequency;#Al=Ba.amplitude;#kl=Ba.octaves;#Ol=Ba.persistence;#Nl=Ba.lacunarity;#Fl=Ba.seed;#Gl=Ba.noiseDimension;constructor(i,m=1024,g=1024,x){super(i,m,g,{...x,mainLogic:x?.mainLogic||"let uv=vec2<f32>((base_uv.x + uniforms.time * ( uniforms.animationX * uniforms.animationSpeed )),(base_uv.y + uniforms.time * ( uniforms.animationY * uniforms.animationSpeed )) );let noise=getSimplexNoiseByDimension( uv,uniforms );/* 최종 색상 (그레이스케일) */let finalColor=vec4<f32>(noise,noise,noise,1.0);",uniformStruct:mergerNoiseUniformStruct("noiseDimension:f32,frequency:f32,amplitude:f32,octaves:i32,persistence:f32,lacunarity:f32,seed:f32,",x?.uniformStruct),uniformDefaults:mergerNoiseUniformDefault(Ba,x?.uniformDefaults),helperFunctions:mergerNoiseHelperFunctions("/* Simplex Noise 1D,2D,3D 기본 함수들 */\r\nfn mod289_vec3(x:vec3<f32>) -> vec3<f32> {\rreturn x - floor(x * (1.0/289.0)) * 289.0;\r\n}\r\n\r\nfn mod289_vec2(x:vec2<f32>) -> vec2<f32> {\rreturn x - floor(x * (1.0/289.0)) * 289.0;\r\n}\r\n\r\nfn mod289_vec4(x:vec4<f32>) -> vec4<f32> {\rreturn x - floor(x * (1.0/289.0)) * 289.0;\r\n}\r\n\r\nfn mod289_f32(x:f32) -> f32 {\rreturn x - floor(x * (1.0/289.0)) * 289.0;\r\n}\r\n\r\nfn permute(x:vec3<f32>) -> vec3<f32> {\rreturn mod289_vec3(((x * 34.0) + 1.0) * x);\r\n}\r\n\r\nfn permute4(x:vec4<f32>) -> vec4<f32> {\rreturn mod289_vec4(((x * 34.0) + 1.0) * x);\r\n}\r\n\r\nfn permute_f32(x:f32) -> f32 {\rreturn mod289_f32(((x * 34.0) + 1.0) * x);\r\n}\r\n\r\nfn taylorInvSqrt4(r:vec4<f32>) -> vec4<f32> {\rreturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfn simplex1D(x:f32) -> f32 {\rvar i=floor(x);\rlet f=fract(x);\r\n\r/* 1D에서는 그래디언트가 단순히 +1 또는 -1 */\rlet g0=select(-1.0,1.0,(permute_f32(i) * 0.024390243902439) >=0.5);\rlet g1=select(-1.0,1.0,(permute_f32(i + 1.0) * 0.024390243902439) >=0.5);\r\n\r/* 거리 계산 */\rlet d0=f;\rlet d1=f - 1.0;\r\n\r/* 가중치 계산 (6t^5 - 15t^4 + 10t^3 smoothstep curve) */\rlet t=f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\r\n\r/* 인터폴레이션 */\rlet n0=g0 * d0;\rlet n1=g1 * d1;\r\n\rreturn mix(n0,n1,t) * 0.395;/* 정규화 상수 */\r\n}\r\n\r\nfn simplex2D(v:vec2<f32>) -> f32 {\rlet C=vec4<f32>(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\rvar i=floor(v + dot(v,C.yy));\rlet x0=v - i + dot(i,C.xx);\rlet i1=select(vec2<f32>(0.0,1.0),vec2<f32>(1.0,0.0),x0.x > x0.y);\rvar x12=x0.xyxy + C.xxzz;\rx12.x=x12.x - i1.x;\rx12.y=x12.y - i1.y;\ri=mod289_vec2(i);\rlet p=permute(permute(i.y + vec3<f32>(0.0,i1.y,1.0)) + i.x + vec3<f32>(0.0,i1.x,1.0));\rvar m=max(0.5 - vec3<f32>(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),vec3<f32>(0.0));\rm=m * m;\rm=m * m;\rlet x=2.0 * fract(p * C.www) - 1.0;\rlet h=abs(x) - 0.5;\rlet ox=floor(x + 0.5);\rlet a0=x - ox;\rm=m * (1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h));\rlet g=vec3<f32>(a0.x * x0.x + h.x * x0.y,a0.y * x12.x + h.y * x12.y,a0.z * x12.z + h.z * x12.w);\rreturn 130.0 * dot(m,g);\r\n}\r\n\r\nfn simplex3D(v:vec3<f32>) -> f32 {\rlet C=vec2<f32>(1.0/6.0,1.0/3.0);\rlet D=vec4<f32>(0.0,0.5,1.0,2.0);\r\n\r/* First corner */\rvar i=floor(v + dot(v,C.yyy));\rlet x0=v - i + dot(i,C.xxx);\r\n\r/* Other corners */\rlet g=step(x0.yzx,x0.xyz);\rlet l=1.0 - g;\rlet i1=min(g.xyz,l.zxy);\rlet i2=max(g.xyz,l.zxy);\r\n\rlet x1=x0 - i1 + C.xxx;\rlet x2=x0 - i2 + C.yyy;\rlet x3=x0 - D.yyy; \r\n\r/* Permutations */\ri=mod289_vec3(i);\rlet p=permute4(permute4(permute4(\ri.z + vec4<f32>(0.0,i1.z,i2.z,1.0 )) +\ri.y + vec4<f32>(0.0,i1.y,i2.y,1.0 )) +\ri.x + vec4<f32>(0.0,i1.x,i2.x,1.0 ));\r\n\r/* Gradients:7x7 points over a square,mapped onto an octahedron. */\r/* The ring size 17*17=289 is close to a multiple of 49 (49*6=294) */\rlet n_=0.142857142857;\rlet ns=n_ * D.wyz - D.xzx;\r\n\rlet j=p - 49.0 * floor(p * ns.z * ns.z); \r\n\rlet x_=floor(j * ns.z);\rlet y_=floor(j - 7.0 * x_ ); \r\n\rlet x=x_ *ns.x + ns.yyyy;\rlet y=y_ *ns.x + ns.yyyy;\rlet h=1.0 - abs(x) - abs(y);\r\n\rlet b0=vec4<f32>( x.xy,y.xy );\rlet b1=vec4<f32>( x.zw,y.zw );\r\n\rlet s0=floor(b0)*2.0 + 1.0;\rlet s1=floor(b1)*2.0 + 1.0;\rlet sh=-step(h,vec4<f32>(0.0));\r\n\rlet a0=b0.xzyw + s0.xzyw*sh.xxyy;\rlet a1=b1.xzyw + s1.xzyw*sh.zzww;\r\n\rvar p0=vec3<f32>(a0.xy,h.x);\rvar p1=vec3<f32>(a0.zw,h.y);\rvar p2=vec3<f32>(a1.xy,h.z);\rvar p3=vec3<f32>(a1.zw,h.w);\r\n\r/* Normalise gradients */\rlet norm=taylorInvSqrt4(vec4<f32>(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\rp0 *=norm.x;\rp1 *=norm.y;\rp2 *=norm.z;\rp3 *=norm.w;\r\n\r/* Mix final noise value */\rvar m=max(0.6 - vec4<f32>(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),vec4<f32>(0.0));\rm=m * m;\rreturn 42.0 * dot( m*m,vec4<f32>( dot(p0,x0),dot(p1,x1),\rdot(p2,x2),dot(p3,x3) ) );\r\n}\r\n\r\nfn fbm1D(pos:f32,octaves:i32) -> f32 {\rvar value=0.0;\rvar amplitude=0.5;\rvar frequency=1.0;\rvar max_value=0.0;\r\n\rfor (var i=0;i < octaves;i++) {\rif (i >=octaves) { break;}\rvalue +=simplex1D(pos * frequency) * amplitude;\rmax_value +=amplitude;\ramplitude *=0.5;\rfrequency *=2.0;\r}\r\n\rreturn value/max_value;\r\n}\r\n\r\nfn fbm(pos:vec2<f32>,octaves:i32) -> f32 {\rvar value=0.0;\rvar amplitude=0.5;\rvar frequency=1.0;\rvar max_value=0.0;\r\n\rfor (var i=0;i < octaves;i++) {\rif (i >=octaves) { break;}\rvalue +=simplex2D(pos * frequency) * amplitude;\rmax_value +=amplitude;\ramplitude *=0.5;\rfrequency *=2.0;\r}\r\n\rreturn value/max_value;\r\n}\r\n\r\nfn fbm3D(pos:vec3<f32>,octaves:i32) -> f32 {\rvar value=0.0;\rvar amplitude=0.5;\rvar frequency=1.0;\rvar max_value=0.0;\r\n\rfor (var i=0;i < octaves;i++) {\rif (i >=octaves) { break;}\rvalue +=simplex3D(pos * frequency) * amplitude;\rmax_value +=amplitude;\ramplitude *=0.5;\rfrequency *=2.0;\r}\r\n\rreturn value/max_value;\r\n}\r\n\r\nfn getSimplexNoise1D(pos:f32,uniforms:Uniforms) -> f32 {\rvar total_amplitude:f32=0.0;\rvar noise_value:f32=0.0;\rvar current_amplitude:f32=1.0;\rvar current_frequency:f32=uniforms.frequency;\r\n\r/* Fractal Brownian Motion (FBM) - 여러 옥타브 합성 */\rfor (var i:i32=0;i < uniforms.octaves;i++) {\rlet noise_pos=(pos + uniforms.seed) * current_frequency;\rlet octave_noise=simplex1D(noise_pos);\r\n\rnoise_value +=octave_noise * current_amplitude;\rtotal_amplitude +=current_amplitude;\r\n\rcurrent_amplitude *=uniforms.persistence;\rcurrent_frequency *=uniforms.lacunarity;\r}\r\n\r/* 정규화 */\rnoise_value/=total_amplitude;\r\n\r/* amplitude를 최종 결과에 적용 */\rnoise_value *=uniforms.amplitude;\r\n\r/* -1 ~ 1 범위를 0 ~ 1로 변환 */\rlet normalized_noise=(noise_value + 1.0) * 0.5;\rreturn normalized_noise;\r\n}\r\n\r\nfn getSimplexNoise2D(uv:vec2<f32>,uniforms:Uniforms) -> f32 {\rvar total_amplitude:f32=0.0;\rvar noise_value:f32=0.0;\rvar current_amplitude:f32=1.0;\rvar current_frequency:f32=uniforms.frequency;\r\n\r/* Fractal Brownian Motion (FBM) - 여러 옥타브 합성 */\rfor (var i:i32=0;i < uniforms.octaves;i++) {\rlet noise_pos=(uv + uniforms.seed) * current_frequency;\rlet octave_noise=simplex2D(noise_pos);\r\n\rnoise_value +=octave_noise * current_amplitude;\rtotal_amplitude +=current_amplitude;\r\n\rcurrent_amplitude *=uniforms.persistence;\rcurrent_frequency *=uniforms.lacunarity;\r}\r\n\r/* 정규화 */\rnoise_value/=total_amplitude;\r\n\r/* amplitude를 최종 결과에 적용 */\rnoise_value *=uniforms.amplitude;\r\n\r/* -1 ~ 1 범위를 0 ~ 1로 변환 */\rlet normalized_noise=(noise_value + 1.0) * 0.5;\rreturn normalized_noise;\r\n}\r\n\r\nfn getSimplexNoise3D(pos:vec3<f32>,uniforms:Uniforms) -> f32 {\rvar total_amplitude:f32=0.0;\rvar noise_value:f32=0.0;\rvar current_amplitude:f32=1.0;\rvar current_frequency:f32=uniforms.frequency;\r\n\r/* Fractal Brownian Motion (FBM) - 여러 옥타브 합성 */\rfor (var i:i32=0;i < uniforms.octaves;i++) {\rlet noise_pos=(pos + vec3<f32>(uniforms.seed)) * current_frequency;\rlet octave_noise=simplex3D(noise_pos);\r\n\rnoise_value +=octave_noise * current_amplitude;\rtotal_amplitude +=current_amplitude;\r\n\rcurrent_amplitude *=uniforms.persistence;\rcurrent_frequency *=uniforms.lacunarity;\r}\r\n\r/* 정규화 */\rnoise_value/=total_amplitude;\r\n\r/* amplitude를 최종 결과에 적용 */\rnoise_value *=uniforms.amplitude;\r\n\r/* -1 ~ 1 범위를 0 ~ 1로 변환 */\rlet normalized_noise=(noise_value + 1.0) * 0.5;\rreturn normalized_noise;\r\n}\r\nfn getSimplexNoiseByDimension(uv:vec2<f32>,uniforms:Uniforms) -> f32 {\rif (uniforms.noiseDimension < 1.1) {\rreturn getSimplexNoise1D(uv.x,uniforms);\r} else if (uniforms.noiseDimension < 2.1) {\rreturn getSimplexNoise2D(uv,uniforms);\r} else if (uniforms.noiseDimension < 3.1) {\rreturn getSimplexNoise3D(vec3<f32>(uv.x,uv.y,uniforms.seed * 0.1),uniforms);\r} else {\rreturn getSimplexNoise2D(uv,uniforms);\r}\r\n}\r\n",x?.helperFunctions)})}get noiseDimension(){return this.#Gl}set noiseDimension(i){La.includes(i)?(this.#Gl=i,this.updateUniform("noiseDimension",i)):consoleAndThrowError(`Invalid value for noiseDimension. Received ${i}. Expected one of:${La.join(",")}`)}get frequency(){return this.#Ul}set frequency(i){validatePositiveNumberRange(i),this.#Ul=i,this.updateUniform("frequency",i)}get amplitude(){return this.#Al}set amplitude(i){validatePositiveNumberRange(i),this.#Al=i,this.updateUniform("amplitude",i)}get octaves(){return this.#kl}set octaves(i){validateUintRange(i,1,8),this.#kl=i,this.updateUniform("octaves",i)}get persistence(){return this.#Ol}set persistence(i){validatePositiveNumberRange(i,0,1),this.#Ol=i,this.updateUniform("persistence",i)}get lacunarity(){return this.#Nl}set lacunarity(i){validatePositiveNumberRange(i),this.#Nl=i,this.updateUniform("lacunarity",i)}get seed(){return this.#Fl}set seed(i){this.#Fl=i,this.updateUniform("seed",i)}randomizeSeed(){this.seed=1e3*Math.random()}getSettings(){return{frequency:this.#Ul,amplitude:this.#Al,octaves:this.#kl,persistence:this.#Ol,lacunarity:this.#Nl,seed:this.#Fl}}applySettings(i){void 0!==i.frequency&&(this.frequency=i.frequency),void 0!==i.amplitude&&(this.amplitude=i.amplitude),void 0!==i.octaves&&(this.octaves=i.octaves),void 0!==i.persistence&&(this.persistence=i.persistence),void 0!==i.lacunarity&&(this.lacunarity=i.lacunarity),void 0!==i.seed&&(this.seed=i.seed)}},StorageBuffer:StorageBuffer,UniformBuffer:UniformBuffer,UniformType:UniformType,VORONOI_DISTANCE_TYPE:Da,VORONOI_OUTPUT_TYPE:Ua,VertexBuffer:VertexBuffer,VoronoiTexture:class extends ANoiseTexture{#Ul=Oa.frequency;#Vl=Oa.distanceScale;#kl=Oa.octaves;#Ol=Oa.persistence;#Nl=Oa.lacunarity;#Fl=Oa.seed;#$l=Oa.distanceType;#Hl=Oa.outputType;#zl=Oa.jitter;#ql=Oa.cellIdColorIntensity;constructor(i,m=1024,g=1024,x){super(i,m,g,{...x,mainLogic:x?.mainLogic||"let uv=vec2<f32>((base_uv.x + uniforms.time * (uniforms.animationX * uniforms.animationSpeed)),(base_uv.y + uniforms.time * (uniforms.animationY * uniforms.animationSpeed)));var finalColor:vec4<f32>;if (uniforms.outputType==5) {let colorNoise=getVoronoiColorNoise(uv,uniforms);finalColor=vec4<f32>(colorNoise,1.0);} else {let noise=getVoronoiNoise(uv,uniforms);finalColor=vec4<f32>(noise,noise,noise,1.0);}",uniformStruct:mergerNoiseUniformStruct("frequency:f32,distanceScale:f32,octaves:i32,persistence:f32,lacunarity:f32,seed:f32,distanceType:i32,outputType:i32,jitter:f32,cellIdColorIntensity:f32,",x?.uniformStruct),uniformDefaults:mergerNoiseUniformDefault(Oa,x?.uniformDefaults),helperFunctions:mergerNoiseHelperFunctions("fn hash22(p:vec2<f32>) -> vec2<f32> {\rvar p3=fract(vec3<f32>(p.xyx) * vec3<f32>(0.1031,0.1030,0.0973));\rp3 +=dot(p3,p3.yzx + 33.33);\rreturn fract((p3.xx + p3.yz) * p3.zy);\r\n}\r\n\r\nfn hash12(p:vec2<f32>) -> f32 {\rvar p3=fract(vec3<f32>(p.xyx) * 0.1031);\rp3 +=dot(p3,p3.yzx + 33.33);\rreturn fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nfn euclideanDistance(a:vec2<f32>,b:vec2<f32>) -> f32 {\rlet d=a - b;\rreturn sqrt(d.x * d.x + d.y * d.y);\r\n}\r\n\r\nfn manhattanDistance(a:vec2<f32>,b:vec2<f32>) -> f32 {\rlet d=abs(a - b);\rreturn d.x + d.y;\r\n}\r\n\r\nfn chebyshevDistance(a:vec2<f32>,b:vec2<f32>) -> f32 {\rlet d=abs(a - b);\rreturn max(d.x,d.y);\r\n}\r\n\r\nfn calculateDistance(a:vec2<f32>,b:vec2<f32>,distanceType:i32) -> f32 {\rswitch (distanceType) {\rcase 0:{ return euclideanDistance(a,b);}\rcase 1:{ return manhattanDistance(a,b);}\rcase 2:{ return chebyshevDistance(a,b);}\rdefault:{ return euclideanDistance(a,b);}\r}\r\n}\r\n\r\n\r\nfn cellIdToColor(cellId:f32,intensity:f32) -> vec3<f32> {\rlet h=cellId * 6.28318;\rlet s=0.7 + 0.3 * fract(cellId * 7.0);\rlet v=0.6 + 0.4 * fract(cellId * 13.0);\r\n\r\rlet c=v * s;\rlet x=c * (1.0 - abs(((h/1.047198) % 2.0) - 1.0));\rlet m=v - c;\r\n\rvar rgb:vec3<f32>;\rlet sector=i32(h/1.047198) % 6;\rswitch (sector) {\rcase 0:{ rgb=vec3<f32>(c,x,0.0);}\rcase 1:{ rgb=vec3<f32>(x,c,0.0);}\rcase 2:{ rgb=vec3<f32>(0.0,c,x);}\rcase 3:{ rgb=vec3<f32>(0.0,x,c);}\rcase 4:{ rgb=vec3<f32>(x,0.0,c);}\rdefault:{ rgb=vec3<f32>(c,0.0,x);}\r}\r\n\rreturn (rgb + m) * intensity;\r\n}\r\n\r\nstruct VoronoiResult {\rf1:f32,\rf2:f32,\rcellId:f32,\r\n}\r\n\r\nfn voronoiSingle(pos:vec2<f32>,frequency:f32,seed:f32,jitter:f32,distanceType:i32) -> VoronoiResult {\rlet scaledPos=pos * frequency;\rlet gridPos=floor(scaledPos);\rlet localPos=fract(scaledPos);\r\n\rvar minDist1=999.0;\rvar minDist2=999.0;\rvar closestCellId=0.0;\r\n\rfor (var y=-1;y <=1;y++) {\rfor (var x=-1;x <=1;x++) {\rlet neighborGrid=gridPos + vec2<f32>(f32(x),f32(y));\r\n\rlet randomOffset=hash22(neighborGrid + seed);\rlet jitteredOffset=mix(vec2<f32>(0.5),randomOffset,jitter);\rlet cellPoint=vec2<f32>(f32(x),f32(y)) + jitteredOffset;\r\n\rlet dist=calculateDistance(localPos,cellPoint,distanceType);\r\n\rif (dist < minDist1) {\rminDist2=minDist1;\rminDist1=dist;\r\rclosestCellId=hash12(neighborGrid + seed);\r} else if (dist < minDist2) {\rminDist2=dist;\r}\r}\r}\r\n\rreturn VoronoiResult(minDist1,minDist2,closestCellId);\r\n}\r\n\r\nfn getVoronoiNoise(uv:vec2<f32>,uniforms:Uniforms) -> f32 {\rvar total=0.0;\rvar frequency=uniforms.frequency;\rvar amplitude=1.0;\rvar maxValue=0.0;\r\n\rfor (var i=0;i < uniforms.octaves;i++) {\rlet voronoiResult=voronoiSingle(\ruv,\rfrequency,\runiforms.seed + f32(i) * 100.0,\runiforms.jitter,\runiforms.distanceType\r);\r\n\rlet F1=voronoiResult.f1 * uniforms.distanceScale;\rlet F2=voronoiResult.f2 * uniforms.distanceScale;\rlet cellId=voronoiResult.cellId;\r\n\rvar octaveValue:f32;\rswitch (uniforms.outputType) {\rcase 0:{ octaveValue=F1;}\rcase 1:{ octaveValue=F2;}\rcase 2:{ octaveValue=F2 - F1;}\rcase 3:{ octaveValue=(F1 + F2) * 0.5;}\rcase 4:{ octaveValue=cellId;} \rcase 5:{\r\rlet colorRGB=cellIdToColor(cellId,uniforms.cellIdColorIntensity);\roctaveValue=(colorRGB.r + colorRGB.g + colorRGB.b)/3.0;\r}\rdefault:{ octaveValue=F1;}\r}\r\n\rtotal +=octaveValue * amplitude;\rmaxValue +=amplitude;\r\n\rfrequency *=uniforms.lacunarity;\ramplitude *=uniforms.persistence;\r}\r\n\rreturn clamp(total/maxValue,0.0,1.0);\r\n}\r\n\r\n\r\nfn getVoronoiColorNoise(uv:vec2<f32>,uniforms:Uniforms) -> vec3<f32> {\rif (uniforms.outputType==5) { \rlet voronoiResult=voronoiSingle(\ruv,\runiforms.frequency,\runiforms.seed,\runiforms.jitter,\runiforms.distanceType\r);\rreturn cellIdToColor(voronoiResult.cellId,uniforms.cellIdColorIntensity);\r} else {\rlet grayValue=getVoronoiNoise(uv,uniforms);\rreturn vec3<f32>(grayValue,grayValue,grayValue);\r}\r\n}\r\n",x?.helperFunctions)})}get frequency(){return this.#Ul}set frequency(i){validatePositiveNumberRange(i),this.#Ul=i,this.updateUniform("frequency",i)}get distanceScale(){return this.#Vl}set distanceScale(i){validatePositiveNumberRange(i),this.#Vl=i,this.updateUniform("distanceScale",i)}get octaves(){return this.#kl}set octaves(i){validateUintRange(i,1,8),this.#kl=i,this.updateUniform("octaves",i)}get persistence(){return this.#Ol}set persistence(i){validatePositiveNumberRange(i,0,1),this.#Ol=i,this.updateUniform("persistence",i)}get lacunarity(){return this.#Nl}set lacunarity(i){validatePositiveNumberRange(i),this.#Nl=i,this.updateUniform("lacunarity",i)}get seed(){return this.#Fl}set seed(i){this.#Fl=i,this.updateUniform("seed",i)}get distanceType(){return this.#$l}set distanceType(i){Aa.includes(i)?(this.#$l=i,this.updateUniform("distanceType",i)):consoleAndThrowError(`Invalid value for distanceType. Received ${i}. Expected one of:${Aa.join(",")}`)}get outputType(){return this.#Hl}set outputType(i){ka.includes(i)?(this.#Hl=i,this.updateUniform("outputType",i)):consoleAndThrowError(`Invalid value for outputType. Received ${i}. Expected one of:${ka.join(",")}`)}get jitter(){return this.#zl}set jitter(i){(i<0||i>1)&&consoleAndThrowError(`Jitter must be between 0 and 1. Received:${i}`),validatePositiveNumberRange(i,0,1),this.#zl=i,this.updateUniform("jitter",i)}get cellIdColorIntensity(){return this.#ql}set cellIdColorIntensity(i){validatePositiveNumberRange(i),this.#ql=i,this.updateUniform("cellIdColorIntensity",i)}randomizeSeed(){this.seed=1e3*Math.random()}setEuclideanDistance(){this.distanceType=Da.EUCLIDEAN}setManhattanDistance(){this.distanceType=Da.MANHATTAN}setChebyshevDistance(){this.distanceType=Da.CHEBYSHEV}setF1Output(){this.outputType=Ua.F1}setF2Output(){this.outputType=Ua.F2}setCrackPattern(){this.outputType=Ua.F2_MINUS_F1}setSmoothBlend(){this.outputType=Ua.F1_PLUS_F2}setCellIdOutput(){this.outputType=Ua.CELL_ID}setCellIdColorOutput(){this.outputType=Ua.CELL_ID_COLOR}setCellularPattern(){this.outputType=Ua.F1,this.distanceType=Da.EUCLIDEAN,this.jitter=1}setStonePattern(){this.outputType=Ua.F2_MINUS_F1,this.distanceType=Da.EUCLIDEAN,this.jitter=.8}setOrganicPattern(){this.distanceType=Da.MANHATTAN,this.jitter=.6}setGridPattern(){this.jitter=0,this.distanceType=Da.EUCLIDEAN}setCrystalPattern(){this.outputType=Ua.F2_MINUS_F1,this.distanceType=Da.CHEBYSHEV,this.jitter=.9}setStainedGlassPattern(){this.outputType=Ua.CELL_ID_COLOR,this.distanceType=Da.EUCLIDEAN,this.jitter=.7,this.cellIdColorIntensity=.8}setMosaicPattern(){this.outputType=Ua.CELL_ID_COLOR,this.distanceType=Da.MANHATTAN,this.jitter=.3,this.cellIdColorIntensity=1}setBiomeMapPattern(){this.outputType=Ua.CELL_ID,this.distanceType=Da.EUCLIDEAN,this.jitter=.8,this.frequency=4}getSettings(){return{frequency:this.#Ul,distanceScale:this.#Vl,octaves:this.#kl,persistence:this.#Ol,lacunarity:this.#Nl,seed:this.#Fl,distanceType:this.#$l,outputType:this.#Hl,jitter:this.#zl,cellIdColorIntensity:this.#ql}}applySettings(i){void 0!==i.frequency&&(this.frequency=i.frequency),void 0!==i.distanceScale&&(this.distanceScale=i.distanceScale),void 0!==i.octaves&&(this.octaves=i.octaves),void 0!==i.persistence&&(this.persistence=i.persistence),void 0!==i.lacunarity&&(this.lacunarity=i.lacunarity),void 0!==i.seed&&(this.seed=i.seed),void 0!==i.distanceType&&(this.distanceType=i.distanceType),void 0!==i.outputType&&(this.outputType=i.outputType),void 0!==i.jitter&&(this.jitter=i.jitter),void 0!==i.cellIdColorIntensity&&(this.cellIdColorIntensity=i.cellIdColorIntensity)}getDistanceTypeName(){return{[Da.EUCLIDEAN]:"Euclidean",[Da.MANHATTAN]:"Manhattan",[Da.CHEBYSHEV]:"Chebyshev"}[this.#$l]||"Unknown"}getOutputTypeName(){return{[Ua.F1]:"F1",[Ua.F2]:"F2",[Ua.F2_MINUS_F1]:"F2-F1 (Crack)",[Ua.F1_PLUS_F2]:"F1+F2 (Blend)",[Ua.CELL_ID]:"Cell ID",[Ua.CELL_ID_COLOR]:"Cell ID Color"}[this.#Hl]||"Unknown"}},getUniformOffsetByRoundUp:(i,m)=>((i+m-1)/m|0)*m,loadAndCreateBitmapImage:loadAndCreateBitmapImage,parseIncludeWGSL:parseIncludeWGSL,parseWGSL:parseWGSL}),Fa=Object.freeze({__proto__:null,BlendState:BlendState,DepthStencilState:DepthStencilState,PrimitiveState:PrimitiveState}),Ga="\r\n\r\n@group(1) @binding(0)\r\nvar _sampler:sampler;\r\n\r\n@group(1) @binding(1)\r\nvar _texture:texture_2d<f32>;\r\n\r\n\r\n\r\n@fragment\r\nfn main(@location(0) fragUV:vec2<f32>) -> @location(0) vec4<f32> {\r\rvar diffuseColor:vec4<f32>=textureSample(_texture,_sampler,fragUV);\r\n\r\rdiffuseColor=vec4<f32>(diffuseColor.rgb,diffuseColor.a);\r\n\r\rreturn diffuseColor;\r\n}\r\n",Va="\r\n\r\nstruct VertexUniforms {\rmodelMatrix:mat4x4<f32>,\r\n};\r\n\r\n\r\n@group(0) @binding(0)\r\nvar<uniform> vertexUniforms:VertexUniforms;\r\n\r\n\r\n\r\n\r\nstruct VertexOutput {\r@builtin(position) Position:vec4<f32>,\r@location(0) fragUV:vec2<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main(@builtin(vertex_index) VertexIndex:u32) -> VertexOutput {\r\n\r\rvar pos=array<vec2<f32>,6>(\rvec2( 1.0, 1.0),\rvec2( 1.0,-1.0),\rvec2(-1.0,-1.0),\rvec2( 1.0, 1.0),\rvec2(-1.0,-1.0),\rvec2(-1.0, 1.0),\r);\r\n\r\rvar uv=array<vec2<f32>,6>(\rvec2(1.0,0.0),\rvec2(1.0,1.0),\rvec2(0.0,1.0),\rvec2(1.0,0.0),\rvec2(0.0,1.0),\rvec2(0.0,0.0),\r);\r\n\r\rvar output:VertexOutput;\r\n\r\routput.Position=vertexUniforms.modelMatrix * vec4<f32>(pos[VertexIndex],0.0,1.0);\routput.fragUV=uv[VertexIndex];\r\n\r\rreturn output;\r\n}\r\n";const $a=parseWGSL(Va),Ha=parseWGSL(Ga),za=$a.uniforms.vertexUniforms;class FinalRender{#Kl=[];#Wl=[];#Xl;#jl;#Yl;#Zl;#Jl;#Ql=[];#ce;#ec=[];#tc=[];#he;constructor(){}render(i,m){const{sizeManager:g,gpuDevice:x,antialiasingManager:_}=i,{changedMSAA:b,useMSAA:y}=_,{pixelRectObject:T}=g,{width:w,height:P}=T;if(0===w||0===P)return;const $=this.#rc(i),H=x.createCommandEncoder(),z=H.beginRenderPass($);z.setViewport(0,0,w,P,0,1),z.setScissorRect(0,0,w,P),this.#Xl&&!b||this.#nc(i),this.#ic(i,z,m.map(i=>{const m=i.colorAttachments[0];return m.postEffectView||m.pickingView||m.resolveTarget||m.view}),w,P,y),z.end(),x.queue.submit([H.finish()])}#ic(i,m,g,x,_,b){const{gpuDevice:y}=i;g.forEach((g,b)=>{const T=i.viewList[b],{x:w,y:P,width:$,height:H}=T.pixelRectObject,z=create$5();ye(z,0,1,0,1,-1e3,1e3),scale$5(z,z,[1/x,1/_,1]),translate$1(z,z,[$/2+w,_-H/2-P,0]),scale$5(z,z,[$/2,H/2,1]),this.#ac(i,b);const q=this.#Kl[b],W=this.#Wl[b];y.queue.writeBuffer(q.gpuBuffer,za.members.modelMatrix.uniformOffset,new za.members.modelMatrix.View(z));if(i.antialiasingManager.changedMSAA||!this.#ec[b]||this.#ec[b].width!==$||this.#ec[b].height!==H||this.#tc[b]!==g){const i={layout:this.#Zl,label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:this.#he.gpuSampler},{binding:1,resource:g}]};this.#Ql[b]=y.createBindGroup(i),this.#ec[b]={width:$||1,height:H||1},this.#tc[b]=g}m.setPipeline(this.#sc(i)),m.setBindGroup(0,W),m.setBindGroup(1,this.#Ql[b]),m.draw(6,1,0,0)})}#nc(i){const{resourceManager:m}=i;this.#Xl=m.createBindGroupLayout("FINAL_RENDER_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo($a,0)),this.#jl=m.createGPUShaderModule("VERTEX_MODULE_FINAL_RENDER",{code:Va}),this.#Yl={module:this.#jl,entryPoint:"main"},this.#Jl=m.createGPUShaderModule("FRAGMENT_MODULE_FINAL_RENDER",{code:Ga}),this.#Zl=m.createBindGroupLayout("FINAL_RENDER_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(Ha,1)),this.#he=new Sampler(i,{minFilter:"linear"})}#ac(i,m){const{gpuDevice:g}=i;if(!this.#Kl[m]){const x=new ArrayBuffer(za.arrayBufferByteLength),_=this.#Kl[m]=new UniformBuffer(i,x,`FinalRender_View(${m})_VertexUniform`),b={layout:this.#Xl,label:"VERTEX_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:{buffer:_.gpuBuffer,offset:0,size:_.size}}]};this.#Wl[m]=g.createBindGroup(b)}}#rc(i){const{backgroundColor:m,gpuContext:g}=i,x=m.rgbaNormal;return{colorAttachments:[{view:g.getCurrentTexture().createView({label:"finalRenderTextureView"}),clearValue:{r:x[0]*x[3],g:x[1]*x[3],b:x[2]*x[3],a:x[3]},loadOp:$n.CLEAR,storeOp:Hn.STORE}]}}#sc(i){if(!this.#ce||i.antialiasingManager.changedMSAA){const{gpuDevice:m}=i,g={label:"PIPELINE_DESCRIPTOR_FINAL_RENDER",layout:m.createPipelineLayout({bindGroupLayouts:[this.#Xl,this.#Zl]}),vertex:this.#Yl,fragment:{module:this.#Jl,entryPoint:"main",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:cn.ONE,dstFactor:cn.ONE_MINUS_SRC_ALPHA,operation:hn.ADD},alpha:{srcFactor:cn.ONE,dstFactor:cn.ONE_MINUS_SRC_ALPHA,operation:hn.ADD}}}]}};this.#ce=m.createRenderPipeline(g)}return this.#ce}}!function(i,m){void 0===m&&(m={});var g=m.insertAt;if("undefined"!=typeof document){var x=document.head||document.getElementsByTagName("head")[0],_=document.createElement("style");_.type="text/css","top"===g&&x.firstChild?x.insertBefore(_,x.firstChild):x.appendChild(_),_.styleSheet?_.styleSheet.cssText=i:_.appendChild(document.createTextNode(i))}}(".RedGPUDebugPanel{background:rgba(0,0,0,.8);bottom:0;color:#fff;font-size:11px;left:0;line-height:1;max-height:100%;min-width:250px;overflow-y:auto;position:fixed;transform:translateZ(0);will-change:transform;z-index:2}.RedGPUDebugPanel::-webkit-scrollbar{width:6px}.RedGPUDebugPanel::-webkit-scrollbar-track{background:#000}.RedGPUDebugPanel::-webkit-scrollbar-thumb{background:#333}.RedGPUDebugPanel::-webkit-scrollbar-thumb:hover{background:#444}.debug-group{line-height:1.4;padding:10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group{background:linear-gradient(90deg,hsla(0,0%,100%,.1),rgba(0,0,0,.01));border:1px solid hsla(0,0%,100%,.16);border-radius:6px;box-shadow:0 0 10px rgba(0,0,0,.16);line-height:1.4;margin:8px 0;padding:6px 10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group-title{color:#e3b096}.debug-item{align-items:center;color:#ccc;display:flex;font-weight:400;gap:10px;justify-content:space-between;transform:translateZ(0);width:100%;will-change:transform;b{color:#fdb48d;font-weight:700}}.boolean-true{background:green}.boolean-false,.boolean-true{border-radius:2px;line-height:1;margin:2px 0;padding:2px 4px}.boolean-false{background:red}.debug-folder{background:rgba(0,0,0,.5);border-bottom:1px solid hsla(0,0%,100%,.05);display:flex;flex-direction:column;width:100%}.debug-folder-title{align-items:center;background:linear-gradient(0deg,rgba(0,0,0,.95),hsla(0,0%,100%,.055));border-bottom:1px solid hsla(0,0%,100%,.025);border-top:1px solid hsla(0,0%,100%,.05);cursor:pointer;display:flex;font-size:12px;justify-content:space-between;line-height:1;padding:10px 8px;width:100%;b{color:#fdb48d;font-size:11px;font-weight:700}}.debug-item-title{color:#888}.debug-item-cache-key,.debug-item-title{font-weight:500;max-width:250px;overflow:hidden;text-overflow:ellipsis;text-shadow:1px 1px 0 rgba(0,0,0,.3)}.debug-item-cache-key{color:#fff;white-space:nowrap}.div-line{background:hsla(0,0%,100%,.06);border-bottom:1px solid transparent;height:1px;margin:10px 0;width:100%}.root-padding{padding:6px;width:100%}.color-box{border:1px solid hsla(0,0%,100%,.2);border-radius:4px;margin:2px;padding:3px}");const createDebugTitle=i=>`<div>${i}</div>`,makeColorDebug=(i,m)=>`\n<div class='debug-item'>\n\x3c!--\t<span class='debug-item-title'>${i}</span> --\x3e\n\t<span class='debug-item-title'></span> \n\t<div style="border:1px solid rgba(255,255,255,0.2);border-radius:4px;background:rgba(${m.rgba});padding:3px;margin:2px">${m.rgba}\n\t</div>\n</div>\n`,makeBooleanDebug=(i,m)=>`<span class="${m?"boolean-true":"boolean-false"}">${m?"true":"false"}</span>`,getDebugFormatValue=i=>"boolean"==typeof i?i.toString():"number"==typeof i?i.toLocaleString():i,updateDebugItemValue=(i,m,g,x,_="")=>{const b=i.querySelector(`.${m}`);if(!b)return;const y=`${getDebugFormatValue(g)}${_}`;b.innerHTML!==y&&(b.innerHTML=y,x&&(b.style.background=g?"green":"rgba(255,255,255,0.1)"))};let qa=class{dom;#oc;#uc=!1;constructor(i){this.#oc=i,this.dom=document.createElement("div"),this.dom.innerHTML=`<div class="debug-folder">\t<div class="debug-folder-title" style="display:flex;align-items:center;justify-content:space-between;cursor:pointer;">${createDebugTitle(`${i} Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)`)}<div class="onoff">${this.#uc?"close":"open"}</div></div><div class="item-container" style="display:none"></div></div>\n`;const m=this.dom.querySelector(".debug-folder"),g=this.dom.querySelector(".item-container");m.addEventListener("click",()=>{this.openYn=!this.openYn,g.style.display=this.#uc?"":"none"})}get openYn(){return this.#uc}set openYn(i){this.#uc=i,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}update(i,m){const{resourceManager:g}=m,x=g[`managed${this.#oc}State`],{table:_,videoMemory:b,length:y}=x;let T;switch(i.totalUsedVideoMemory+=b,updateDebugItemValue(this.dom,"totalCount",y),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(b)),this.#oc){case"VertexBuffer":if(T=ResourceStateVertexBuffer,T){const{dirtyList:i}=T;i.length&&(this.#lc(i),i.length=0)}break;case"IndexBuffer":if(T=ResourceStateIndexBuffer,T){const{dirtyList:i}=T;i.length&&(this.#lc(i),i.length=0)}break;case"UniformBuffer":T=ResourceStateUniformBuffer,this.#lc(Object.values(_));break;case"StorageBuffer":T=ResourceStateStorageBuffer,this.#lc(Object.values(_))}}#lc(i){const m=this.dom.querySelector(".item-container"),g=new Set,x=this.#oc,_=new Map;m.querySelectorAll(".debug-group").forEach(i=>{const m=i.className.split(" ")[1].replace(`${x}_`,"");g.add(m),_.set(m,i)}),i.map((i,b)=>{const{useNum:y,buffer:T}=i,{uuid:w,size:P,name:$}=T,H=`${x}_${w}`;let z=_.get(w);z?g.delete(w):(z=document.createElement("div"),z.className=`debug-group ${H}`,z.innerHTML=`<div class='debug-item'><div><div class='debug-item-title'><span style="white-space:nowrap">${b} <span class="name"></span></span></div><div style="font-size:10px">${w}</div></div><div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px"><span class='useNum' style="padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span><span style="white-space:nowrap"><b class="videoMemorySize"></b></span></div></div>`,m.appendChild(z)),updateDebugItemValue(z,"name",$),updateDebugItemValue(z,"useNum",y,!0),updateDebugItemValue(z,"videoMemorySize",formatBytes(P))});for(let i of g)_.get(i).remove()}};class DebugBufferList{debugStatisticsDomService;constructor(i){this.debugStatisticsDomService=new qa(i)}get dom(){return this.debugStatisticsDomService.dom}update(i,m){this.debugStatisticsDomService.update(i,m)}}class ADebugItem{debugStatisticsDomService;constructor(){}get dom(){return this.debugStatisticsDomService.dom}update(i,m,g){this.debugStatisticsDomService.update(i,m)}}class ADebugStatisticsDomService{dom;#uc=!1;constructor(){}get openYn(){return this.#uc}set openYn(i){this.#uc=i,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}init(i,m=!1){this.#uc=m,this.dom=document.createElement("div"),this.dom.innerHTML=`<div class="debug-folder">\t<div class="debug-folder-title">${i}<div class="onoff">${this.openYn?"close":"open"}</div></div><div class="item-container" style="display:${m?"":"none"}"></div></div>\n`;const g=this.dom.querySelector(".debug-folder-title"),x=this.dom.querySelector(".item-container");g.addEventListener("click",i=>{this.openYn=!this.openYn,x.style.display=this.openYn?"":"none"})}update(i,m){}}const Ka=["useMSAA","alphaMode","renderScale"];let Wa=class extends ADebugStatisticsDomService{constructor(){super(),this.init(`${createDebugTitle("RedGPUContext")}`,!0),this.#lc()}update(i,m){Ka.forEach(i=>this.#cc(m,i)),this.#hc(m)}#lc(){const i=this.dom.querySelector(".item-container"),m=['<div class="debug-group">',...Ka.map(i=>this.#fc(i)),this.#fc("width_height"),this.#fc("pixelRectArray"),this.#fc("backgroundColor"),"</div>"];i.innerHTML=m.join("")}#fc(i){return`<div class='debug-item'>${i}<span class='debug-item-title redGPUContext_${i}'/></div>`}#cc(i,m){const g=i[m];updateDebugItemValue(this.dom,`redGPUContext_${m}`,"useMSAA"===m?makeBooleanDebug(0,g):getDebugFormatValue(g))}#hc(i){const{sizeManager:m,width:g,height:x,backgroundColor:_}=i,{pixelRectArray:b}=m;updateDebugItemValue(this.dom,"redGPUContext_width_height",`${g},${x}`),updateDebugItemValue(this.dom,"redGPUContext_pixelRectArray",b),updateDebugItemValue(this.dom,"redGPUContext_backgroundColor",makeColorDebug("backgroundColor",_))}};class DebugRedGPUContext extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new Wa}}let Xa=class extends ADebugStatisticsDomService{#dc;constructor(i){super(),this.#dc=i,this.init(`${createDebugTitle((i?"CubeTexture":"BitmapTexture")+' Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)')}`)}update(i,m){const{resourceManager:g}=m,{managedBitmapTextureState:x,managedCubeTextureState:_}=g,{table:b,videoMemory:y,length:T}=this.#dc?_:x;i.totalUsedVideoMemory+=y;const w=Object.values(b);updateDebugItemValue(this.dom,"totalCount",T),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(y)),this.#lc(w)}getTargetSrc(i){if(i instanceof mn){const{src:m}=i;return m?m.startsWith("data:")?"base64 texture":m:"null"}{const{srcList:m}=i;return`${m[0]}...`}}getUpdatedTdom(i,m,g,x,_,b){return i||((i=document.createElement("div")).className=`debug-group ${g}`,i.innerHTML=`<div class='debug-item'><div><div class='debug-item-title'>${x} <span class="targetSrc">${_}</span></div> <div class='debug-item-cache-key'>cacheKey:<span class="cacheKey">Place holder for cacheKey</span></div><div>mipLevelCount:<span class="mipLevelCount"></span>/useMipmap:<span class="useMipmap"></span></div><div>width:<span class="width"></span>/height:<span class="height"></span></div></div><div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px"><span class='useNum' style="padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span><span><b class="videoMemorySize"></b></span></div></div><div style="font-size:10px">${b}</div>`,m.appendChild(i)),i}updateDebugItems(i,m,g,x,_,b,y,T,w){updateDebugItemValue(i,"mipLevelCount",m),updateDebugItemValue(i,"useMipmap",g),updateDebugItemValue(i,"width",x),updateDebugItemValue(i,"height",_),updateDebugItemValue(i,"useNum",b,!0),updateDebugItemValue(i,"cacheKey",y),updateDebugItemValue(i,"targetSrc",T),updateDebugItemValue(i,"videoMemorySize",formatBytes(w))}#lc(i){const m=this.dom.querySelector(".item-container"),g=new Set,x=this.#dc?"cube_texture":"bitmap_texture";m.querySelectorAll(".debug-group").forEach(i=>{const m=i.className.split(" ")[1].replace(`${x}_`,"");g.add(m)}),i.map((i,_)=>{const{useNum:b,cacheKey:y,texture:T}=i;let w=this.getTargetSrc(i);const{mipLevelCount:P,useMipmap:$,gpuTexture:H,uuid:z,videoMemorySize:q}=T,{width:W,height:ye}=H||{},Ge=`${x}_${T.uuid}`;let Ke=m.querySelector(`.${Ge}`);Ke=this.getUpdatedTdom(Ke,m,Ge,_,w,z),g.delete(T.uuid),this.updateDebugItems(Ke,P,$,W,ye,b,y,w,q)});for(let i of g)m.querySelector(`.${x}_${i}`).remove()}};class DebugTextureList extends ADebugItem{constructor(i=!1){super(),this.debugStatisticsDomService=new Xa(i)}}const ja=["totalNum3DGroups","totalNum3DObjects","totalNumInstances","totalNumDrawCalls","totalNumTriangles","totalNumPoints","totalUsedVideoMemory"];let Ya=class{dom;constructor(){this.dom=document.createElement("div"),this.#mc()}update(i){ja.forEach(m=>{const g=i[m],x="totalUsedVideoMemory"===m?`<b>${formatBytes(g)}</b>`:g;updateDebugItemValue(this.dom,m,x)})}#mc(){const i=this.#lc();this.dom.innerHTML=`<div class="debug-group">${createDebugTitle("Total State")}<div>${i}</div> </div>`}#lc(){return ja.map(i=>"totalUsedVideoMemory"===i?`<div class='debug-item'>${i}<span class='debug-item-title'/><b class="${i}"></b></div>`:`<div class='debug-item'>${i}<span class='debug-item-title ${i}'/></div>`).join("")}};class DebugTotalState extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new Ya}}const Za=["usedVideoMemory","viewRenderTime","num3DGroups","num3DObjects","numInstances","numDrawCalls","numTriangles","numPoints"],Ja={viewRenderTime:"ms"},Qa={camera:"camera.name",scene:"scene.name",useBackgroundColor:"scene.useBackgroundColor",backgroundColor:"scene.backgroundColor",x_y:"x,y",width_height:"width,height"};let es=class extends ADebugStatisticsDomService{#pc=0;constructor(){super(),this.init(`${createDebugTitle("ViewList")}`,!0)}update(i,m){const{viewList:g,numViews:x}=m;this.#pc!==x&&(this.#gc(g),this.#pc=x),g.forEach((m,g)=>{Za.forEach(x=>this.#cc(m,g,x,i)),this.#hc(m,g)})}#fc(i,m){return`<div class='debug-item'>${Qa[m]||m}<span class='debug-item-title view${i}_${m}'/></div>`}#gc(i){const m=this.dom.querySelector(".item-container"),g=i.map((i,m)=>{const{name:g}=i,x=Za.map(i=>this.#fc(m,i));return x.push('<div class="debug-sub-group">',this.#fc(m,"x_y"),this.#fc(m,"width_height"),this.#fc(m,"pixelRectArray"),this.#fc(m,"camera"),this.#fc(m,"scene"),this.#fc(m,"useBackgroundColor"),this.#fc(m,"backgroundColor"),"</div>"),`${createDebugTitle(`<div class="debug-sub-group-title">${g}</div>`)}${x.join("")}`});return m.innerHTML=`<div class="debug-group">${g.join('<div class="div-line"></div>')}</div>`}#cc(i,m,g,x){const{debugViewRenderState:_}=i,b=`total${g.charAt(0).toUpperCase()}${g.substring(1)}`,y=_[g],T="usedVideoMemory"===g?`<b>${formatBytes(y)}</b>`:y,w=Ja[g];x[b]+=y,updateDebugItemValue(this.dom,`view${m}_${g}`,T,!1,w)}#hc(i,m){const{debugViewRenderState:g,rawCamera:x,scene:_}=i,{backgroundColor:b,useBackgroundColor:y}=_,{viewportSize:T}=g,{pixelRectArray:w,x:P,y:$,width:H,height:z}=T;updateDebugItemValue(this.dom,`view${m}_x_y`,`${P},${$}`),updateDebugItemValue(this.dom,`view${m}_width_height`,`${H},${z}`),updateDebugItemValue(this.dom,`view${m}_pixelRectArray`,w),updateDebugItemValue(this.dom,`view${m}_useBackgroundColor`,makeBooleanDebug(0,y)),updateDebugItemValue(this.dom,`view${m}_backgroundColor`,makeColorDebug("backgroundColor",b)),updateDebugItemValue(this.dom,`view${m}_camera`,x.name),updateDebugItemValue(this.dom,`view${m}_scene`,_.name)}};class DebugViewList extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new es}}class DebugStatisticsDomService{dom;constructor(){this.dom=document.createElement("div"),this.dom.style.cssText="z-index:1;position:sticky;top:0;background:#000;border-bottom:1px solid rgba(255,255,255,0.06);box-shadow:0 10px 10px rgba(0,0,0,0.5)",this.#mc()}update(i,m,g){const x={elapsedSeconds:i,currentFps:m,averageFps:g};Object.entries(x).forEach(([i,m])=>this.#xc(i,m))}#mc(){this.dom.innerHTML='<div class="debug-group" ><div class=\'debug-item\'><span class=\'debug-item-title\'>Frame</span><span style="text-align:right"><div class="elapsedSeconds">elapsedSeconds</div><div class="currentFps">currentFps</div><div style="color:#fff" class="averageFps">averageFps</div></span></div></div>'}#xc(i,m){const g=this.dom.querySelector(`.${i}`);if(g){const i=m.toLocaleString();g.innerHTML!==i&&(g.innerHTML=i)}}}class Fps extends ADebugItem{#_c;#vc;#bc=0;#yc=0;constructor(){super(),this.debugStatisticsDomService=new DebugStatisticsDomService,this.#vc=performance.now()}update(i,m,g){this.#Tc(g);const x=this.#Sc(),{elapsedSeconds:_,currentFps:b,averageFps:y}=x;this.debugStatisticsDomService.update(`${_.toLocaleString()}ms`,`${b.toLocaleString()} fps`,`AVG:${y} fps`)}#Tc(i){this.#_c=i-this.#vc||16,this.#vc=i,this.#bc++}#Sc(){const i=1/(this.#_c/1e3),m=Math.round(i);this.#yc+=i;return{currentFps:m,averageFps:Math.round(this.#yc/this.#bc),elapsedSeconds:this.#_c}}}class DebugRender{fps;debugTotalState;debugViewList;debugRedGPUContext;debugBitmapTextureList;debugCubeTextureList;debugIndexBufferList;debugVertexBufferList;debugUniformBufferList;debugStorageBufferList;totalNum3DGroups;totalNum3DObjects;totalNumDrawCalls;totalNumInstances;totalNumTriangles;totalNumPoints;totalUsedVideoMemory;#wc;constructor(){this.fps=new Fps,this.debugTotalState=new DebugTotalState,this.debugRedGPUContext=new DebugRedGPUContext,this.debugViewList=new DebugViewList,this.debugBitmapTextureList=new DebugTextureList,this.debugCubeTextureList=new DebugTextureList(!0),this.debugIndexBufferList=new DebugBufferList("IndexBuffer"),this.debugVertexBufferList=new DebugBufferList("VertexBuffer"),this.debugUniformBufferList=new DebugBufferList("UniformBuffer"),this.debugStorageBufferList=new DebugBufferList("StorageBuffer"),this.#Mc()}render(i,m){i.useDebugPanel?(this.#Rc(),this.fps.update(this,i,m),this.debugRedGPUContext.update(this,i,m),this.debugViewList.update(this,i,m),this.debugBitmapTextureList.update(this,i,m),this.debugCubeTextureList.update(this,i,m),this.debugIndexBufferList.update(this,i),this.debugVertexBufferList.update(this,i),this.debugUniformBufferList.update(this,i),this.debugStorageBufferList.update(this,i),this.debugTotalState.update(this,i,m)):this.#Pc(),this.#Mc()}#Mc(){this.totalNum3DGroups=0,this.totalNum3DObjects=0,this.totalNumInstances=0,this.totalNumDrawCalls=0,this.totalNumTriangles=0,this.totalNumPoints=0,this.totalUsedVideoMemory=0}#Rc(){this.#wc||(this.#wc=document.createElement("div"),this.#wc.className="RedGPUDebugPanel",document.body.appendChild(this.#wc),[this.fps.debugStatisticsDomService,this.debugTotalState.debugStatisticsDomService,this.debugRedGPUContext.debugStatisticsDomService,this.debugViewList.debugStatisticsDomService,this.debugVertexBufferList.debugStatisticsDomService,this.debugIndexBufferList.debugStatisticsDomService,this.debugUniformBufferList.debugStatisticsDomService,this.debugStorageBufferList.debugStatisticsDomService,this.debugBitmapTextureList.debugStatisticsDomService,this.debugCubeTextureList.debugStatisticsDomService].forEach(i=>this.#wc.appendChild(i.dom)))}#Pc(){this.#wc&&(this.#wc.remove(),this.#wc=null)}}Object.freeze(DebugRender);const renderListForLayer=(i,m,g="pipeline")=>{let x=0;const _=i.length,{currentRenderPassEncoder:b}=m;for(;x<_;x++){const _=i[x];if(_.gpuRenderInfo){const i=_._geometry,x=_._material;i?m.num3DObjects++:m.num3DGroups++;const{gpuRenderInfo:y}=_,{vertexUniformBindGroup:T}=y;if(i&&y[g]){b.setPipeline(y[g]);const{gpuBuffer:w}=i.vertexBuffer,{fragmentUniformBindGroup:P}=x.gpuRenderInfo;if(m.prevVertexGpuBuffer!==w&&(b.setVertexBuffer(0,w),m.prevVertexGpuBuffer=w,_.particleBuffers&&(_.particleBuffers.forEach((i,m)=>{b.setVertexBuffer(m+1,i)}),m.prevVertexGpuBuffer=null)),b.setBindGroup(1,T),m.prevFragmentUniformBindGroup!==P&&(b.setBindGroup(2,P),m.prevFragmentUniformBindGroup=P),m.numDrawCalls++,i.indexBuffer){const{indexBuffer:g}=i,{indexNum:x,triangleCount:y,gpuBuffer:T}=g;b.setIndexBuffer(T,"uint32"),_.particleBuffers?b.drawIndexed(x,_.particleNum,0,0,0):b.drawIndexed(x,1,0,0,0),m.numTriangles+=y,m.numPoints+=x}else{const{vertexBuffer:g}=i,{vertexCount:x,triangleCount:_}=g;b.draw(x,1,0,0),m.numTriangles+=_,m.numPoints+=x}}}}m.prevVertexGpuBuffer=null,m.prevFragmentUniformBindGroup=null,m.prevVertexGpuBuffer=null},renderList=(i,m)=>{let g=0;const x=i.length;for(;g<x;g++)i[g].render(m);m.prevVertexGpuBuffer=null,m.prevFragmentUniformBindGroup=null,m.prevVertexGpuBuffer=null};class Renderer{#Cc;#Ic;#Ec=new DebugRender;constructor(){}renderFrame(i,m){this.#Ic||(this.#Ic=new FinalRender);const g=[];{let x=0;const _=i.viewList.length;for(;x<_;x++){const _=i.viewList[x];g.push(this.renderView(_,m))}}this.#Ic.render(i,g),i.antialiasingManager.changedMSAA=!1}start(i,m){cancelAnimationFrame(i.currentRequestAnimationFrame);const HD_render=g=>{m?.(g),this.renderFrame(i,g),this.#Ec.render(i,g),i.currentRequestAnimationFrame=requestAnimationFrame(HD_render)};i.currentRequestAnimationFrame=requestAnimationFrame(HD_render)}stop(i){cancelAnimationFrame(i.currentRequestAnimationFrame)}renderView(i,m){const{redGPUContext:g,camera:x,scene:_,pickingManager:b,pixelRectObject:y,axis:T,grid:w,debugViewRenderState:P}=i,{antialiasingManager:$}=g,{useMSAA:H}=$,{shadowManager:z}=_,{directionalShadowManager:q}=z,{colorAttachment:W,depthStencilAttachment:ye}=this.#Lc(i),Ge={colorAttachments:[W],depthStencilAttachment:ye};x.update?.(i,m);const Ke=g.gpuDevice.createCommandEncoder();if(i.debugViewRenderState.reset(null,m),y.width&&y.height){if(q.shadowDepthTextureView){const m={colorAttachments:[],depthStencilAttachment:{view:q.shadowDepthTextureView,depthClearValue:1,depthLoadOp:$n.CLEAR,depthStoreOp:Hn.STORE}},g=Ke.beginRenderPass(m);this.#Bc(i,g,!0,!1),((i,m)=>{const{debugViewRenderState:g,scene:x}=i;g.currentRenderPassEncoder=m;const{shadowManager:_}=x,{directionalShadowManager:b}=_,{castingList:y}=b;renderListForLayer(y,g,"shadowPipeline")})(i,g),g.end(),q.resetCastingList()}{const m=Ke.beginRenderPass(Ge);this.#Bc(i,m,!1,!0),((i,m)=>{const{debugViewRenderState:g,skybox:x,scene:_}=i;g.currentRenderPassEncoder=m;const{instanceMeshLayer:b}=g,{children:y}=_;x&&x.render(g),renderList(y,g),renderList(b,g)})(i,m),T&&T.render(P),w&&w.render(P),((i,m)=>{const{debugViewRenderState:g,rawCamera:x}=i;g.currentRenderPassEncoder=m;const{alphaLayer:_,transparentLayer:b,particleLayer:y}=g;renderListForLayer(_,g);const{x:T,y:w,z:P}=x;sortTransparentObjects({x:T,y:w,z:P},b),renderListForLayer(b,g),renderListForLayer(y,g)})(i,m),m.end()}if(i.debugViewRenderState.render2PathLayer.length){const{mipmapGenerator:m}=g.resourceManager;let x=i.viewRenderTextureManager.renderPath1ResultTexture,_=H?i.viewRenderTextureManager.colorResolveTexture:i.viewRenderTextureManager.colorTexture;_||(H?console.error("MSAA가 활성화되어 있지만 colorResolveTexture가 정의되지 않았습니다"):console.error("colorTexture가 정의되지 않았습니다")),x||console.error("renderPath1ResultTexture가 정의되지 않았습니다"),Ke.copyTextureToTexture({texture:_},{texture:x},{width:i.pixelRectObject.width,height:i.pixelRectObject.height,depthOrArrayLayers:1}),m.generateMipmap(x,i.viewRenderTextureManager.renderPath1ResultTextureDescriptor);const b=Ke.beginRenderPass({colorAttachments:[{...W,loadOp:"load"}],depthStencilAttachment:{...ye,depthLoadOp:$n.LOAD}});let y=i.viewRenderTextureManager.renderPath1ResultTextureView;this.#Bc(i,b,!1,!0,y),((i,m)=>{const{debugViewRenderState:g}=i;g.currentRenderPassEncoder=m;const{render2PathLayer:x}=g;renderListForLayer(x,g)})(i,b),b.end()}if(Ge.colorAttachments[0].postEffectView=i.postEffectManager.render(),b){b.checkTexture(i);const m={colorAttachments:[{view:b.pickingGPUTextureView,clearValue:{r:0,g:0,b:0,a:0},loadOp:$n.CLEAR,storeOp:Hn.STORE}],depthStencilAttachment:{view:b.pickingDepthGPUTextureView,depthClearValue:1,depthLoadOp:$n.CLEAR,depthStoreOp:Hn.STORE}},g=Ke.beginRenderPass(m);this.#Bc(i,g,!1,!1),((i,m)=>{const{debugViewRenderState:g,pickingManager:x}=i;g.currentRenderPassEncoder=m;const{castingList:_}=x;renderListForLayer(_,g,"pickingPipeline")})(i,g),g.end()}}return g.gpuDevice.queue.submit([Ke.finish()]),i.debugViewRenderState.viewRenderTime=performance.now()-i.debugViewRenderState.startTime,b.checkEvents(i,m),Ge}#Lc(i){const{scene:m,redGPUContext:g,viewRenderTextureManager:x}=i,{depthTextureView:_,colorTextureView:b,colorResolveTextureView:y}=x,{useBackgroundColor:T,backgroundColor:w}=m,{antialiasingManager:P}=g,{useMSAA:$}=P,H=w.rgbaNormal,z={view:b,clearValue:T?{r:H[0]*H[3],g:H[1]*H[3],b:H[2]*H[3],a:H[3]}:{r:0,g:0,b:0,a:0},loadOp:$n.CLEAR,storeOp:Hn.STORE};$&&(z.resolveTarget=y);return{colorAttachment:z,depthStencilAttachment:{view:_,depthClearValue:1,depthLoadOp:$n.CLEAR,depthStoreOp:Hn.STORE}}}#Bc(i,m,g=!1,x=!0,_=null){const{inverseProjectionMatrix:b,pixelRectObject:y,projectionMatrix:T,rawCamera:w,redGPUContext:P,scene:$}=i,{gpuDevice:H}=P,{modelMatrix:z,position:q}=w,W=i.systemUniform_Vertex_StructInfo,ye=i.systemUniform_Vertex_UniformBuffer.gpuBuffer,{shadowManager:Ge,lightManager:Ke}=$,{directionalShadowManager:Xe}=Ge,je=w instanceof Camera2D;if(g){const i=Xe.shadowDepthTextureSize,g=Xe.shadowDepthTextureSize;m.setViewport(0,0,i,g,0,1),m.setScissorRect(0,0,i,g)}else{const{width:i,height:g}=y;this.#Cc&&this.#Cc.width===i&&this.#Cc.height===g||(m.setViewport(0,0,i,g,0,1),m.setScissorRect(0,0,i,g),this.#Cc={width:i,height:g})}Ke.updateViewSystemUniforms(i),Xe.updateViewSystemUniforms(P),i.update(i,g,x,_),m.setBindGroup(0,i.systemUniform_Vertex_UniformBindGroup),[{key:"projectionMatrix",value:T},{key:"projectionCameraMatrix",value:multiply$5(ts,T,z)},{key:"inverseProjectionMatrix",value:b},{key:"resolution",value:[i.pixelRectObject.width,i.pixelRectObject.height]}].forEach(({key:i,value:m})=>{H.queue.writeBuffer(ye,W.members[i].uniformOffset,new W.members[i].View(m))}),[{key:"cameraMatrix",value:z},{key:"cameraPosition",value:q},{key:"nearClipping",value:[je?0:w.nearClipping]},{key:"farClipping",value:[je?0:w.farClipping]}].forEach(({key:i,value:m})=>{H.queue.writeBuffer(ye,W.members.camera.members[i].uniformOffset,new W.members.camera.members[i].View(m))})}}let ts=create$5();var rs=Object.freeze({__proto__:null,isHexColor:isHexColor,isUint:isUint,validateNumber:validateNumber,validateNumberRange:validateNumberRange,validatePositiveNumberRange:validatePositiveNumberRange,validateRedGPUContext:validateRedGPUContext,validateUintRange:validateUintRange});class MeshInfo_OBJ{name;groupName;materialKey;index;position;resultPosition;resultNormal;resultUV;resultInterleave;use;childrenInfo;ableUV;ableNormal;ableLight;mesh;constructor(i,m){this.name=i,this.groupName=m,this.index=[],this.position=[],this.resultPosition=[],this.resultNormal=[],this.resultUV=[],this.resultInterleave=[],this.use=!0,this.childrenInfo={}}createVertexBuffer(i,m){let g={};return this.resultPosition.length&&(g.aVertexPosition=InterleaveType.float32x3),this.resultNormal.length&&(g.aVertexNormal=InterleaveType.float32x3),this.resultUV.length&&(g.aTexcoord=InterleaveType.float32x2),new VertexBuffer(i,new Float32Array(this.resultInterleave.length?this.resultInterleave:this.resultPosition),new InterleavedStruct(g,`InterleavedStruct_${m}}`),void 0,`VertexBuffer_${m}`)}createBufferIndex(i,m){if(this.index.length)return new IndexBuffer(i,this.index,void 0,`IndexBuffer_${m}`)}createColorMaterial(i){return this.resultUV.length&&this.resultNormal.length||this.resultNormal.length?new ColorMaterial(i,"#00ff00"):new ColorMaterial(i,"#0000ff")}}Object.freeze(MeshInfo_OBJ);class TotalPointInfo_OBJ{position=[];normal=[];uv=[];points=[];normalPoints=[];uvPoints=[];constructor(){}}Object.freeze(TotalPointInfo_OBJ);class OBJMTLLoader{complete;parseData;#Dc;#Uc;#Ac;constructor(i,m,g){this.#Dc=getFilePath(m),this.#Uc=getFileName(m),this.#Ac=m,this.#kc(m,g)}get path(){return this.#Dc}get fileName(){return this.#Uc}get url(){return this.#Ac}#kc(i,m){fetch(i,{method:"GET",headers:{"Content-Type":"application/x-www-form-urlencoded;charset=UTF-8"}}).then(i=>{if(!i.ok)throw new Error(`HTTP 오류! 상태값:${i.status}`);return i.text()}).then(i=>{this.complete=!0,this.parseData=function(i,m){let g;const x={},_={single:["newmtl","Ns","Ni","d","illum"],multi:["Ka","Kd","Ks"],maps:["map_Kd","map_Ns","map_bump"]};return(m=m.replace(/^\#[\s\S]+?\n/g,"")).split("\n").forEach(m=>{for(const b in _)for(const y of _[b])if(new RegExp(`^(${y} )`).test(m))switch(b){case"single":if("newmtl"===y){const i=m.replace("newmtl ","").trim();g={name:i},x[i]=g}else g[y]=+m.replace(`${y} `,"").trim();break;case"multi":g[y]=m.replace(`${y} `,"").split(" ");break;case"maps":g[y]=i.path+m.replace(`${y} `,"").trim()}}),x}(this,i),m?.(this.parseData)}).catch(i=>{this.complete=!0,this.parseData={},m?.(this.parseData)})}}Object.freeze(OBJMTLLoader);const ns=/^o/,is=/v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/,as=/f\s+(([\d]{1,}[\s]?){3,})+/,ss=/f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,os=/f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,us=/f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/;let ls,cs;function processMaterialLibrary(i,m,g,x,_){_=new OBJMTLLoader(g,`${m.path}${i.split(" ")[1]}`,i=>{m.mtlLoader=i,m.modelParsingComplete&&(((i,m,g)=>{let x,_,b,y;for(x in y={},m){let T,w;b=m[x];const{use:P,materialKey:$,mesh:H}=b,{ableLight:z,ableNormal:q}=b,{resultInterleave:W}=b;if(P&&W.length){let m,x,b;_=g.parseData[$],_&&(_.map_Kd?(y[_.map_Kd]?w=y[_.map_Kd]:(w=new BitmapTexture(i,_.map_Kd),y[_.map_Kd]=w),T=new BitmapMaterial(i,w)):_.Kd&&(m=255*_.Kd[0],x=255*_.Kd[1],b=255*_.Kd[2],T=new ColorMaterial(i,convertRgbToHex(m,x,b))),T&&(_.map_Ns&&(y[_.map_Ns]?w=y[_.map_Ns]:(w=new BitmapTexture(i,_.map_Ns),y[_.map_Ns]=w),T.specularTexture=w),_.map_bump&&(y[_.map_bump]?w=y[_.map_bump]:(w=new BitmapTexture(i,_.map_bump),y[_.map_bump]=w),T.normalTexture=w),void 0!==_.Ns&&(T.shininess=_.Ns),H.material=T))}}})(g,x,_),m.callback&&m.callback(m.result))}),m.mtlLoader=_}function processMaterialUsage(i,m,g){m[g].materialKey=i.split(" ").slice(1).join("").trim()}function processGroup(i,m,g,x){const _=i.split(" ").slice(1).join("").trim();m[g].use=!1;const b=new MeshInfo_OBJ(_,g);b.groupName=g,b.materialKey=_.replace(`${g}_`,""),b.position=ls.position,x[_]=ls=b,m[g].childrenInfo[_]=ls}function processNewObject(i,m,g){const x=i.split(" ").slice(1).join("").trim(),_=new MeshInfo_OBJ(x,x);_.groupName=x,_.materialKey=x,m[x]=ls=_,g[x]=ls,cs=x}function processVertexNormals(i,m,g){const x=i.split(" ");m.push(+x[1],+x[2],+x[3]),g[g.length]=[+x[1],+x[2],+x[3]]}function processTextureCoordinates(i,m,g){const x=i.split(" ");m.push(+x[1],1-x[2]),g[g.length]=[+x[1],1-x[2]]}function processVertex(i,m,g){const x=i.split(" ");m.push(+x[1],+x[2],+x[3]),ls.position.push(+x[1],+x[2],+x[3]),g[g.length]=[+x[1],+x[2],+x[3]]}function processFaceVertexNormal(i,m,g,x,_){const b=3*(m.length+g.length);i.split(" ").slice(1,4).forEach(i=>{const[m,,g]=i.split("/").map(i=>Number(i)-1),y=x[m],T=_[g],{index:w,resultInterleave:P}=ls,{resultPosition:$,resultNormal:H,resultUV:z}=ls;w.push(P.length/b),$.push(...y),H.push(...T),P.push(...y,...T)})}function processFaceVertexTextureNormal(i,m,g,x,_,b,y){let T=i.split(" ").slice(1,5);if(4===T.length){let i=T[3];T[3]=T[0],T[4]=T[2],T[5]=i}T.forEach(i=>{const[T,w,P]=i.split("/").map(Number).map(i=>i-1),$=_[T],H=y[w],z=b[P],q=(m.length?3:0)+(g.length?3:0)+(x.length?2:0),{index:W,resultInterleave:ye}=ls,{resultPosition:Ge,resultNormal:Ke,resultUV:Xe}=ls;W.push(ye.length/q),m.length&&(Ge.push(...$),ye.push(...$)),g.length&&(Ke.push(...z),ye.push(...z)),x.length&&(Xe.push(...H),ye.push(...H))})}function processFaceVertexTexture(i,m,g,x,_){i.split(" ").slice(1,4).forEach(i=>{const[b,y]=i.split("/").map(Number).map(i=>i-1),T=x[b];let w;0!==_.length&&(w=_[y]);const P=(m.length?3:0)+(g.length?2:0);ls.index.push(ls.resultInterleave.length/P),m.length&&(ls.resultPosition.push(...T),ls.resultInterleave.push(...T)),g.length&&(ls.resultUV.push(...w),ls.resultInterleave.push(...w))})}function processFaceVertex(i,m){let g=i.split(" ");ls.resultInterleave=ls.resultPosition=ls.position,ls.index.push(+g[1]-1,+g[2]-1,+g[3]-1),ls.index.push(+g[1]-1,+g[3]-1,+g[4]-1)}const parserMesh_OBJ=(i,m,g)=>{for(let x in g){const _=g[x];let b;if(_.use){const m=_.createVertexBuffer(i,x),g=_.createBufferIndex(i,x),y=_.createColorMaterial(i);b=new Mesh(i,new Geometry(i,m,g),y),_.ableUV=Boolean(_.resultUV.length),_.ableNormal=Boolean(_.resultNormal.length),_.ableLight=_.ableUV&&_.ableNormal}else b=new Mesh(i);b.name=x,_.mesh=b,m.addChild(b),parserMesh_OBJ(i,b,_.childrenInfo)}},parserOBJ=(i,m,g)=>{const x=((i,m,g)=>{let x,_;const b=new TotalPointInfo_OBJ,{points:y,normalPoints:T,uvPoints:w}=b,{position:P,normal:$,uv:H}=b;let z,q;_={},x={};const W=g.length;for(z=0;z<W;z++)if(ns.test(g[z])){q=!0;break}if(!q){const i="objModel"+createUUID();_[i]=ls=new MeshInfo_OBJ(i,i),x[i]=ls,cs=i}const ye=g.length;for(let b=0;b<ye;b++){const z=g[b];z.startsWith("mtllib ")?processMaterialLibrary(z,m,i,x,void 0):z.startsWith("usemtl ")?processMaterialUsage(z,x,cs):z.startsWith("g ")?processGroup(z,_,cs,x):z.startsWith("o ")?processNewObject(z,_,x):z.startsWith("vn ")?processVertexNormals(z,$,T):z.startsWith("vt ")?processTextureCoordinates(z,H,w):is.test(z)?processVertex(z,P,y):us.test(z)?processFaceVertexNormal(z,P,$,y,T):os.test(z)?processFaceVertexTextureNormal(z,P,$,H,y,T,w):ss.test(z)?processFaceVertexTexture(z,P,H,y,w):as.test(z)&&processFaceVertex(z)}return{info:x,infoHierarchy:_}})(i,m,(g=g.replace(/^\#[\s\S]+?\n/g,"")).split("\n")),_=x.infoHierarchy;return parserMesh_OBJ(i,m.resultMesh,_),{...m,...x,parseInfoMaterial:m.mtlLoader}};class OBJLoader{modelParsingComplete=!1;resultMesh;result;callback;mtlLoader;#Dc;#Uc;#Ac;constructor(i,m,g){validateRedGPUContext(i),m&&(fetch(m).then(i=>i.text()).then(m=>{this.result=parserOBJ(i,this,m),this.modelParsingComplete=!0,this.resultMesh=m,g&&(this.mtlLoader?this.mtlLoader.complete&&g(this.result):g(this.result))}).catch(i=>console.error("Error:",i)),this.#Dc=getFilePath(m),this.#Uc=getFileName(m),this.#Ac=m,this.mtlLoader=null,this.callback=g,this.resultMesh=new Mesh(i),this.resultMesh.name="instanceOfOBJLoader_"+createUUID(),this.result=null)}get path(){return this.#Dc}get fileName(){return this.#Uc}get url(){return this.#Ac}}Object.freeze(OBJLoader);class AMultiPassPostEffect extends ASinglePassPostEffect{#Oc=[];constructor(i,m){super(i),this.#Oc.push(...m)}get passList(){return this.#Oc}clear(){this.#Oc.forEach(i=>i.clear())}render(i,m,g,x){let _;return this.#Oc.forEach((b,y)=>{y&&(x=_),_=b.render(i,m,g,x)}),_}}Object.freeze(AMultiPassPostEffect);class BrightnessContrast extends ASinglePassPostEffect{#Nc=0;#Fc=0;constructor(i){super(i);this.init(i,"POST_EFFECT_BRIGHTNESS_CONTRAST",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad(sourceTexture,index,);let brightness_value:f32=uniforms.brightness/255.0;let contrast_value:f32=uniforms.contrast/255.0;var tempColor:vec3<f32>;if ( contrast_value > 0.0 ) {tempColor=( color.rgb - 0.5 )/( 1.0 - contrast_value ) + 0.5;}else {tempColor=( color.rgb - 0.5 ) * ( 1.0 + contrast_value ) + 0.5;}color=vec4<f32>(tempColor + brightness_value,color.a);textureStore(outputTexture,index,color );","struct Uniforms {brightness:f32,contrast:f32};"))}get brightness(){return this.#Nc}set brightness(i){validateNumberRange(i,-150,150),this.#Nc=i,this.updateUniform("brightness",i)}get contrast(){return this.#Fc}set contrast(i){validateNumberRange(i,-50,100),this.#Fc=i,this.updateUniform("contrast",i)}}Object.freeze(BrightnessContrast);class ColorBalance extends ASinglePassPostEffect{#Gc=0;#Vc=0;#$c=0;#Hc=0;#zc=0;#qc=0;#Kc=0;#Wc=0;#Xc=0;#jc=!0;constructor(i){super(i);this.init(i,"POST_EFFECT_COLOR_BALANCE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad( sourceTexture,index,);let original_luminance=0.299 * color.r + 0.587 * color.g + 0.114 * color.b;let shadow_weight=1.0 - smoothstep(0.0,0.5,original_luminance);let highlight_weight=smoothstep(0.5,1.0,original_luminance); let midtone_weight=1.0 - shadow_weight - highlight_weight;let cyan_red=shadow_weight * uniforms.shadowCyanRed + midtone_weight * uniforms.midtoneCyanRed + highlight_weight * uniforms.highlightCyanRed;let magenta_green=shadow_weight * uniforms.shadowMagentaGreen + midtone_weight * uniforms.midtoneMagentaGreen + highlight_weight * uniforms.highlightMagentaGreen;let yellow_blue=shadow_weight * uniforms.shadowYellowBlue + midtone_weight * uniforms.midtoneYellowBlue + highlight_weight * uniforms.highlightYellowBlue;color.r +=cyan_red * 0.01; color.g +=magenta_green * 0.01;color.b +=yellow_blue * 0.01; let adjusted_luminance=0.299 * color.r + 0.587 * color.g + 0.114 * color.b;if (uniforms.preserveLuminosity==1 && adjusted_luminance > 0.0) {let ratio=original_luminance/adjusted_luminance;color=color * ratio;}textureStore(outputTexture,index,color );","struct Uniforms {shadowCyanRed:f32,shadowMagentaGreen:f32,shadowYellowBlue:f32,midtoneCyanRed:f32,midtoneMagentaGreen:f32,midtoneYellowBlue:f32,highlightCyanRed:f32,highlightMagentaGreen:f32,highlightYellowBlue:f32,preserveLuminosity:u32};"))}get shadowCyanRed(){return this.#Gc}set shadowCyanRed(i){validateNumberRange(i,-100,100),this.#Gc=i,this.updateUniform("shadowCyanRed",i)}get shadowMagentaGreen(){return this.#Vc}set shadowMagentaGreen(i){validateNumberRange(i,-100,100),this.#Vc=i,this.updateUniform("shadowMagentaGreen",i)}get shadowYellowBlue(){return this.#$c}set shadowYellowBlue(i){validateNumberRange(i,-100,100),this.#$c=i,this.updateUniform("shadowYellowBlue",i)}get midtoneCyanRed(){return this.#Hc}set midtoneCyanRed(i){validateNumberRange(i,-100,100),this.#Hc=i,this.updateUniform("midtoneCyanRed",i)}get midtoneMagentaGreen(){return this.#zc}set midtoneMagentaGreen(i){validateNumberRange(i,-100,100),this.#zc=i,this.updateUniform("midtoneMagentaGreen",i)}get midtoneYellowBlue(){return this.#qc}set midtoneYellowBlue(i){validateNumberRange(i,-100,100),this.#qc=i,this.updateUniform("midtoneYellowBlue",i)}get highlightCyanRed(){return this.#Kc}set highlightCyanRed(i){validateNumberRange(i,-100,100),this.#Kc=i,this.updateUniform("highlightCyanRed",i)}get highlightMagentaGreen(){return this.#Wc}set highlightMagentaGreen(i){validateNumberRange(i,-100,100),this.#Wc=i,this.updateUniform("highlightMagentaGreen",i)}get highlightYellowBlue(){return this.#Xc}set highlightYellowBlue(i){validateNumberRange(i,-100,100),this.#Xc=i,this.updateUniform("highlightYellowBlue",i)}get preserveLuminosity(){return this.#jc}set preserveLuminosity(i){this.#jc=i,this.updateUniform("preserveLuminosity",i)}}Object.freeze(ColorBalance);class ColorTemperatureTint extends ASinglePassPostEffect{#Yc=6500;#Zc=0;#Jc=100;constructor(i){super(i);this.init(i,"POST_EFFECT_COLOR_TEMPERATURE_TINT",createBasicPostEffectCode(this,"\n\t let index=vec2<u32>(global_id.xy);\n\t let dimensions:vec2<u32>=textureDimensions(sourceTexture);\n\t let dimW=f32(dimensions.x);\n\t let dimH=f32(dimensions.y);\n\t let uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\n\t var color:vec4<f32>=textureLoad(sourceTexture,index);\n\t \n\t let temp=uniforms.temperature;\n\t var tempRGB:vec3<f32>;\n\t \n\t \n\t if (temp <=6600.0) {\n\t tempRGB.r=1.0;\n\t } else {\n\t let t=temp - 6600.0;\n\t tempRGB.r=clamp(1.292936 * pow(t,-0.1332047),0.0,1.0);\n\t }\n\t \n\t \n\t if (temp <=6600.0) {\n\t let t=temp;\n\t tempRGB.g=clamp(0.39008157 * log(t) - 0.63184144,0.0,1.0);\n\t } else {\n\t let t=temp - 6600.0;\n\t tempRGB.g=clamp(1.292936 * pow(t,-0.1332047),0.0,1.0);\n\t }\n\t \n\t \n\t if (temp >=6600.0) {\n\t tempRGB.b=1.0;\n\t } else if (temp <=1900.0) {\n\t tempRGB.b=0.0;\n\t } else {\n\t let t=temp - 1000.0;\n\t tempRGB.b=clamp(0.543206789 * log(t) - 1.19625408,0.0,1.0);\n\t }\n\t \n\t \n\t let neutralTemp:vec3<f32>=vec3<f32>(1.0,1.0,1.0);\n\t let tempAdjust:vec3<f32>=tempRGB/neutralTemp;\n\t \n\t \n\t let tintValue=uniforms.tint * 0.01;\n\t var tintRGB:vec3<f32>;\n\t if (tintValue >=0.0) {\n\t \n\t tintRGB=vec3<f32>(1.0 - tintValue * 0.2,1.0,1.0 - tintValue * 0.2);\n\t } else {\n\t \n\t let mag=-tintValue;\n\t tintRGB=vec3<f32>(1.0,1.0 - mag * 0.2,1.0);\n\t }\n\t \n\t let colorAdjust=tempAdjust * tintRGB;\n\t \n\t let strength=uniforms.strength * 0.01;\n\t let finalAdjust=mix(vec3<f32>(1.0,1.0,1.0),colorAdjust,strength);\n\t \n\t color=vec4<f32>(color.rgb * finalAdjust,color.a);\n\t \n\t color=vec4<f32>(clamp(color.rgb,vec3<f32>(0.0),vec3<f32>(1.0)),color.a);\n\t \n\t textureStore(outputTexture,index,color);","\n\t struct Uniforms {\n\t temperature:f32,\n\t tint:f32,\n\t strength:f32\n\t };")),this.strength=this.#Jc,this.tint=this.#Zc,this.temperature=this.#Yc}get temperature(){return this.#Yc}set temperature(i){validateNumberRange(i,1e3,2e4),this.#Yc=i,this.updateUniform("temperature",i)}get tint(){return this.#Zc}set tint(i){validateNumberRange(i,-100,100),this.#Zc=i,this.updateUniform("tint",i)}get strength(){return this.#Jc}set strength(i){validateNumberRange(i,0,100),this.#Jc=i,this.updateUniform("strength",i)}setWarmTone(){this.temperature=3200,this.tint=-10}setCoolTone(){this.temperature=8e3,this.tint=10}setNeutral(){this.temperature=6500,this.tint=0}setCandleLight(){this.temperature=1900,this.tint=-5}setDaylight(){this.temperature=5600,this.tint=0}setCloudyDay(){this.temperature=7500,this.tint=5}setNeonLight(){this.temperature=9e3,this.tint=15}}Object.freeze(ColorTemperatureTint);class Grayscale extends ASinglePassPostEffect{constructor(i){super(i);this.init(i,"POST_EFFECT_GRAYSCALE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad( sourceTexture,index,);let gray=(color.r + color.g + color.b)/3.0;/* 주석테스트 */textureStore(outputTexture,index,vec4<f32>( gray,gray,gray,1.0) );",""))}}Object.freeze(Grayscale);class HueSaturation extends ASinglePassPostEffect{#Qc=0;#eh=0;constructor(i){super(i);this.init(i,"POST_EFFECT_HUE_SATURATION",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad( sourceTexture,index,);let hue_value:f32=uniforms.hue/180.0;let saturation_value:f32=uniforms.saturation/100.0;let angle:f32=hue_value * 3.1415926535897932384626433832795;let s:f32=sin(angle);let c:f32=cos(angle);var weights:vec3<f32>=(vec3<f32>(2.0 * c,-sqrt(3.0) * s - c,sqrt(3.0) * s - c) + 1.0)/3.0;let len:f32=length(color.rgb);color=vec4<f32>(vec3<f32>(dot(color.rgb,weights.xyz),dot(color.rgb,weights.zxy),dot(color.rgb,weights.yzx)),color.a);let average:f32=(color.r + color.g + color.b)/3.0;if (saturation_value > 0.0) {color=vec4<f32>(color.rgb + (average - color.rgb) * (1.0 - 1.0/(1.001 - saturation_value)),color.a);} else {color=vec4<f32>(color.rgb + (average - color.rgb) * (-saturation_value),color.a);}textureStore(outputTexture,index,color );","struct Uniforms {hue:f32,saturation:f32};"))}get hue(){return this.#Qc}set hue(i){validateNumberRange(i,-180,180),this.#Qc=i,this.updateUniform("hue",i)}get saturation(){return this.#eh}set saturation(i){validateNumberRange(i,-100,100),this.#eh=i,this.updateUniform("saturation",i)}}Object.freeze(HueSaturation);class Invert extends ASinglePassPostEffect{constructor(i){super(i);this.init(i,"POST_EFFECT_INVERT",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad( sourceTexture,index,);color.r=1.0 - color.r;color.g=1.0 - color.g;color.b=1.0 - color.b;textureStore(outputTexture,index,color );",""))}}Object.freeze(Invert);class Threshold extends ASinglePassPostEffect{#th=128;constructor(i){super(i);this.init(i,"POST_EFFECT_THRESHOLD",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);var color:vec4<f32>=textureLoad( sourceTexture,index,);let threshold_value:f32=uniforms.threshold/255.0;var v=0.0;if( 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b >=threshold_value) {v=1.0;}color=vec4<f32>(v,v,v,color.a);textureStore(outputTexture,index,color );","struct Uniforms {threshold:f32};")),this.threshold=this.#th}get threshold(){return this.#th}set threshold(i){validateNumberRange(i,1,255),this.#th=i,this.updateUniform("threshold",i)}}Object.freeze(Threshold);class Vibrance extends ASinglePassPostEffect{#rh=0;#eh=0;constructor(i){super(i);this.init(i,"POST_EFFECT_VIBRANCE",createBasicPostEffectCode(this,"\n\t let index=vec2<u32>(global_id.xy);\n\t let dimensions:vec2<u32>=textureDimensions(sourceTexture);\n\t let dimW=f32(dimensions.x);\n\t let dimH=f32(dimensions.y);\n\t let uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\n\t var color:vec4<f32>=textureLoad(sourceTexture,index);\n\t \n\t let originalColor=color;\n\t let luminance=0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n\t \n\t if (uniforms.saturation !=0.0) {\n\t let saturationFactor=1.0 + uniforms.saturation * 0.01;\n\t color=vec4<f32>(\n\t mix(luminance,color.r,saturationFactor),\n\t mix(luminance,color.g,saturationFactor),\n\t mix(luminance,color.b,saturationFactor),\n\t color.a\n\t );\n\t }\n\t \n\t if (uniforms.vibrance !=0.0) {\n\t \n\t let maxComponent=max(max(color.r,color.g),color.b);\n\t let minComponent=min(min(color.r,color.g),color.b);\n\t let currentSaturation=maxComponent - minComponent;\n\t \n\t \n\t let protectionFactor=1.0/(1.0 + exp(6.0 * (currentSaturation - 0.6)));\n\t \n\t \n\t var skinToneProtection=1.0;\n\t if (color.r > color.g && color.g > color.b) {\n\t let skinToneAmount=(color.r - color.b)/max(color.r,0.001);\n\t skinToneProtection=1.0 - smoothstep(0.3,0.8,skinToneAmount) * 0.7;\n\t }\n\t \n\t \n\t let finalProtection=protectionFactor * skinToneProtection;\n\t \n\t \n\t let vibranceStrength=uniforms.vibrance * 0.01 * finalProtection;\n\t let vibranceFactor=1.0 + vibranceStrength;\n\t \n\t \n\t color=vec4<f32>(\n\t mix(luminance,color.r,vibranceFactor),\n\t mix(luminance,color.g,vibranceFactor),\n\t mix(luminance,color.b,vibranceFactor),\n\t color.a\n\t );\n\t }\n\t \n\t \n\t color=clamp(color,vec4<f32>(0.0),vec4<f32>(1.0));\n\t \n\t textureStore(outputTexture,index,color);","\n\t struct Uniforms {\n\t vibrance:f32,\n\t saturation:f32\n\t };"))}get vibrance(){return this.#rh}set vibrance(i){validateNumberRange(i,-100,100),this.#rh=i,this.updateUniform("vibrance",i)}get saturation(){return this.#eh}set saturation(i){validateNumberRange(i,-100,100),this.#eh=i,this.updateUniform("saturation",i)}}Object.freeze(Vibrance);const hs=[0,0,0,0,0,1,0,0,0,0,0,0],fs=[0,-1,0,0,-1,5,-1,0,0,-1,0,0],ds=[1,1,1,0,1,1,1,0,1,1,1,0],ms=[0,1,0,0,1,-4,1,0,0,1,0,0],ps=[-2,-1,0,0,-1,1,1,0,0,1,2,0];class Convolution extends ASinglePassPostEffect{static NORMAL=hs;static SHARPEN=fs;static BLUR=ds;static EDGE=ms;static EMBOSE=ps;#nh=ds;constructor(i){super(i);this.init(i,"POST_EFFECT_CONVOLUTION",createBasicPostEffectCode(this,"let index=vec2<i32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let perPX=\tvec2<f32>(1.0/dimW,1.0/dimH);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=vec4<f32>(0.0);let kernelWeight_value:f32=uniforms.kernelWeight;let kernel_value:mat3x3<f32>=uniforms.kernel;color +=textureLoad(sourceTexture,index + vec2<i32>(-1,-1)) * kernel_value[0][0] ;color +=textureLoad(sourceTexture,index + vec2<i32>(0,-1)) * kernel_value[0][1];color +=textureLoad(sourceTexture,index + vec2<i32>(1,-1)) * kernel_value[0][2];color +=textureLoad(sourceTexture,index + vec2<i32>(-1,0)) * kernel_value[1][0];color +=textureLoad(sourceTexture,index + vec2<i32>(0,0)) * kernel_value[1][1];color +=textureLoad(sourceTexture,index + vec2<i32>(1,0)) * kernel_value[1][2];color +=textureLoad(sourceTexture,index + vec2<i32>(-1,1)) * kernel_value[2][0];color +=textureLoad(sourceTexture,index + vec2<i32>(0,1)) * kernel_value[2][1];color +=textureLoad(sourceTexture,index + vec2<i32>(1,1)) * kernel_value[2][2];textureStore(outputTexture,index,vec4<f32>((color/kernelWeight_value).rgb,1.0) );","struct Uniforms {kernelWeight:f32,kernel:mat3x3<f32>};")),this.kernel=this.#nh}get kernel(){return this.#nh}set kernel(i){this.#nh=i;let m=0;for(const i in this.#nh)m+=this.#nh[i];this.updateUniform("kernelWeight",m),this.updateUniform("kernel",i)}}Object.freeze(Convolution);class Blur extends AMultiPassPostEffect{#ih;constructor(i){super(i,[new Convolution(i)]),this.#ih=this.passList[0],this.#ih.kernel=Convolution.BLUR}render(i,m,g,x){return this.#ih.render(i,m,g,x)}}Object.freeze(Blur);class BlurX extends ASinglePassPostEffect{#K=32;constructor(i){super(i);this.init(i,"POST_EFFECT_BLUR_X",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let size_value:f32=uniforms.size;var sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);var offset=random(global_id,0.0);var total=0.0;let loopSize=10.0;for (var t=-loopSize;t <=loopSize;t=t + 1.0) {var percent=(t + offset - 0.5)/loopSize;var weight=1.0 - abs(percent);var ix=clamp((f32(global_id.x) + f32(size_value * percent)),0.0,dimW - 1.0);let delta=vec2<i32>(i32(ix),i32(global_id.y));sum +=textureLoad(sourceTexture,delta).xyzw * weight;total +=weight;}sum/=total;textureStore(outputTexture,vec2<i32>(global_id.xy),sum);","struct Uniforms {size:f32,};fn random(id:vec3<u32>,delta:f32) -> f32 {let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362);let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16));return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);}")),this.size=this.#K}get size(){return this.#K}set size(i){validateNumberRange(i),this.#K=i,this.updateUniform("size",i)}}Object.freeze(BlurX);class BlurY extends ASinglePassPostEffect{#K=32;constructor(i){super(i);this.init(i,"POST_EFFECT_BLUR_Y",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);let dimensions=textureDimensions(sourceTexture);let dimH=f32(dimensions.y);let size_value:f32=uniforms.size;var sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);var offset=random(global_id,0.0);var total=0.0;let loopSize=10.0;for (var t=-loopSize;t <=loopSize;t=t + 1.0) {var percent=(t + offset - 0.5)/loopSize;var weight=1.0 - abs(percent);var iy=clamp((f32(global_id.y) + f32(size_value * percent)),0.0,dimH - 1.0);let delta=vec2<i32>(i32(global_id.x),i32(iy));sum +=textureLoad(sourceTexture,delta).xyzw * weight;total +=weight;}sum/=total;textureStore(outputTexture,vec2<i32>(global_id.xy),sum);","struct Uniforms {size:f32,};fn random(id:vec3<u32>,delta:f32) -> f32 {let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362);let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16));return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);}")),this.size=this.#K}get size(){return this.#K}set size(i){validateNumberRange(i),this.#K=i,this.updateUniform("size",i)}}Object.freeze(BlurY);class DirectionalBlur extends ASinglePassPostEffect{#ah=15;#sh=0;constructor(i){super(i);this.init(i,"POST_EFFECT_DIRECTIONAL_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let direction=vec2<f32>(uniforms.directionX,uniforms.directionY);let dirLength=length(direction);let normalizedDir=select(vec2<f32>(0.0),direction/dirLength,dirLength > 0.0);let dir=normalizedDir * uniforms.amount;const loopSize=30.0;let offset=random(global_id,0.0);let global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));var sum=vec4<f32>(0.0,0.0,0.0,0.0);var total=0.0;for (var t=-loopSize;t <=loopSize;t=t + 1.0) {var percent=1.0 - (t + offset - 0.5)/loopSize;var weight=3.0 * (percent - percent * percent);let deltaPercent=dir * percent;let delta=vec2<i32>(i32(clamp(global_id_vec.x + deltaPercent.x,0.0,dimW - 1.0)),i32(clamp(global_id_vec.y + deltaPercent.y,0.0,dimH - 1.0)));sum +=textureLoad(sourceTexture,delta).xyzw * weight;total +=weight;}textureStore(outputTexture,vec2<i32>(global_id.xy),sum/total);","\n\t struct Uniforms {\n\t amount:f32,\n\t directionX:f32,\n\t directionY:f32\n\t };\n\t fn random(id:vec3<u32>,delta:f32) -> f32 {\n\t let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362);\n\t let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16));\n\t return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n\t }")),this.amount=this.#ah,this.angle=this.#sh}get angle(){return this.#sh}set angle(i){validateNumber(i),this.#sh=i%360,this.#oh()}get amount(){return this.#ah}set amount(i){validateNumberRange(i,0),this.#ah=i,this.updateUniform("amount",i)}#oh(){const i=this.#sh*Math.PI/180,m=Math.cos(i),g=Math.sin(i);this.updateUniform("directionX",m),this.updateUniform("directionY",g)}}Object.freeze(DirectionalBlur);class GaussianBlur extends AMultiPassPostEffect{#K=32;constructor(i){super(i,[new BlurX(i),new BlurY(i)])}get size(){return this.#K}set size(i){this.#K=i,this.passList.forEach(m=>m.size=i)}}Object.freeze(GaussianBlur);class RadialBlur extends ASinglePassPostEffect{#ah=50;#Qr=0;#en=0;#uh=16;constructor(i){super(i);this.init(i,"POST_EFFECT_RADIAL_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);let global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));let toPixel=global_id_vec - center;let distance=length(toPixel);let angle=atan2(toPixel.y,toPixel.x);let maxDist=min(dimW,dimH) * 0.5;let normalizedDistance=distance/maxDist;let rotationAngle=uniforms.amount * normalizedDistance * 0.001;let sampleCount=i32(uniforms.sampleCount);var sum=vec4<f32>(0.0,0.0,0.0,0.0);var totalWeight=0.0;for (var i=0;i < sampleCount;i=i + 1) {let t=f32(i)/f32(sampleCount - 1);let sampleAngle=angle + (t - 0.5) * rotationAngle;let samplePos=center + vec2<f32>(cos(sampleAngle) * distance,sin(sampleAngle) * distance);var weight=1.0 - abs(t - 0.5) * 1.5;weight=max(weight,0.1);let sampleCoord=vec2<i32>(i32(clamp(samplePos.x,0.0,dimW - 1.0)),i32(clamp(samplePos.y,0.0,dimH - 1.0)));sum +=textureLoad(sourceTexture,sampleCoord).xyzw * weight;totalWeight +=weight;}let centerFalloff=smoothstep(0.0,maxDist * 0.2,distance);let originalColor=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).xyzw;let blurredColor=sum/totalWeight;let finalColor=mix(originalColor,blurredColor,centerFalloff);textureStore(outputTexture,vec2<i32>(global_id.xy),finalColor);","struct Uniforms {amount:f32,centerX:f32,centerY:f32,sampleCount:f32};")),this.amount=this.#ah,this.sampleCount=this.#uh}get centerX(){return this.#Qr}set centerX(i){validateNumber(i),this.#Qr=i,this.updateUniform("centerX",i)}get centerY(){return this.#en}set centerY(i){validateNumber(i),this.#en=i,this.updateUniform("centerY",i)}get amount(){return this.#ah}set amount(i){validateNumberRange(i,0),this.#ah=i,this.updateUniform("amount",i)}get sampleCount(){return this.#uh}set sampleCount(i){validateNumberRange(i,4),this.#uh=i,this.updateUniform("sampleCount",i)}}Object.freeze(RadialBlur);class ZoomBlur extends ASinglePassPostEffect{#ah=128;#Qr=0;#en=0;constructor(i){super(i);this.init(i,"POST_EFFECT_ZOOM_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let dimensionsVec=vec2<f32>(dimW,dimH);let amount=uniforms.amount/min(dimW,dimH);const loopSize=30.0;let offset=random(global_id,0.0);let center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);let global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));let dir=(center - global_id_vec) * amount;var sum=vec4<f32>(0.0,0.0,0.0,0.0);var total=0.0;for (var t=-loopSize;t <=loopSize;t=t + 1.0) {var percent=1.0 - (t + offset - 0.5)/loopSize;var weight=3.0 * (percent - percent * percent);let deltaPercent=dir * percent;let delta=vec2<i32>(i32(clamp(global_id_vec.x + deltaPercent.x,0.0,dimW - 1.0)),i32(clamp(global_id_vec.y + deltaPercent.y,0.0,dimH - 1.0)));sum +=textureLoad(sourceTexture,delta).xyzw * weight;total +=weight;}textureStore(outputTexture,vec2<i32>(global_id.xy),sum/total);","struct Uniforms {amount:f32,centerX:f32,centerY:f32};fn random(id:vec3<u32>,delta:f32) -> f32 {let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362);let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16));return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);}")),this.amount=this.#ah}get centerX(){return this.#Qr}set centerX(i){validateNumber(i),this.#Qr=i,this.updateUniform("centerX",i)}get centerY(){return this.#en}set centerY(i){validateNumber(i),this.#en=i,this.updateUniform("centerY",i)}get amount(){return this.#ah}set amount(i){validateNumberRange(i,0),this.#ah=i,this.updateUniform("amount",i)}}Object.freeze(ZoomBlur);const gs={filmGrainIntensity:.02,filmGrainResponse:.9,filmGrainScale:2.5,coloredGrain:.3,grainSaturation:.4},xs={filmGrainIntensity:.05,filmGrainResponse:.8,filmGrainScale:3,coloredGrain:.5,grainSaturation:.6},_s={filmGrainIntensity:.12,filmGrainResponse:.6,filmGrainScale:4,coloredGrain:.7,grainSaturation:.8},vs={filmGrainIntensity:.08,filmGrainResponse:.7,filmGrainScale:5,coloredGrain:.9,grainSaturation:1};class FilmGrain extends ASinglePassPostEffect{static SUBTLE=gs;static MEDIUM=xs;static HEAVY=_s;static VINTAGE=vs;#lh=_s.filmGrainIntensity;#ch=_s.filmGrainResponse;#hh=_s.filmGrainScale;#fh=_s.coloredGrain;#dh=_s.grainSaturation;#Il=0;#mh=1;constructor(i){super(i),this.#mh=window?.devicePixelRatio||1;this.init(i,"POST_EFFECT_FILM_GRAIN",createBasicPostEffectCode(this,"\n\t let index=vec2<i32>(global_id.xy);\n\t let dimensions:vec2<u32>=textureDimensions(sourceTexture);\n\t let dimW=f32(dimensions.x);\n\t let dimH=f32(dimensions.y);\n\t let uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\n\t \n\t let originalColor=textureLoad(sourceTexture,index);\n\t \n\t let filmGrainIntensity_value:f32=uniforms.filmGrainIntensity;\n\t let filmGrainResponse_value:f32=uniforms.filmGrainResponse;\n\t let filmGrainScale_value:f32=uniforms.filmGrainScale;\n\t let coloredGrain_value:f32=uniforms.coloredGrain;\n\t let grainSaturation_value:f32=uniforms.grainSaturation;\n\t let time_value:f32=uniforms.time;\n\t let devicePixelRatio_value:f32=uniforms.devicePixelRatio;\n\t \n\t if (filmGrainIntensity_value <=0.0) {\n\t textureStore(outputTexture,index,originalColor);\n\t return;\n\t }\n\t \n\t let baseScale=max(filmGrainScale_value,0.1);\n\t let scaledUV=uv * vec2<f32>(dimW,dimH) * devicePixelRatio_value/baseScale;\n\t \n\t let timeOffset=vec2<f32>(\n\t fract(time_value * 0.0317) * 100.0,\n\t fract(time_value * 0.0271) * 100.0\n\t );\n\t let grainCoord=scaledUV + timeOffset;\n\t \n\t let sampleOffset=1.0/baseScale;\n\t let noiseR=(filmGrainNoise(grainCoord) + \n\t filmGrainNoise(grainCoord + vec2<f32>(sampleOffset,0.0)) +\n\t filmGrainNoise(grainCoord + vec2<f32>(0.0,sampleOffset)))/3.0;\n\t let noiseG=filmGrainNoise(grainCoord + vec2<f32>(127.1,311.7));\n\t let noiseB=filmGrainNoise(grainCoord + vec2<f32>(269.5,183.3));\n\t \n\t let monoGrain=(noiseR + noiseG + noiseB)/3.0;\n\t let colorGrain=vec3<f32>(noiseR,noiseG,noiseB);\n\t \n\t var grainColor=mix(vec3<f32>(monoGrain),colorGrain,coloredGrain_value);\n\t \n\t let grainLuminance=dot(grainColor,vec3<f32>(0.299,0.587,0.114));\n\t grainColor=mix(vec3<f32>(grainLuminance),grainColor,grainSaturation_value);\n\t \n\t let luminance=dot(originalColor.rgb,vec3<f32>(0.299,0.587,0.114));\n\t let luminanceWeight=pow(max(luminance,0.01),filmGrainResponse_value);\n\t \n\t let grainIntensity=filmGrainIntensity_value * luminanceWeight;\n\t let grain=grainColor * grainIntensity;\n\t \n\t let finalColor=originalColor.rgb + grain;\n\t \n\t let outputColor=vec4<f32>(clamp(finalColor,vec3<f32>(0.0),vec3<f32>(1.0)),originalColor.a);\n\t \n\t textureStore(outputTexture,index,outputColor);","struct Uniforms {filmGrainIntensity:f32,filmGrainResponse:f32,filmGrainScale:f32,coloredGrain:f32,grainSaturation:f32,time:f32,devicePixelRatio:f32};fn filmGrainNoise(coord:vec2<f32>) -> f32 {let p=floor(coord);let f=fract(coord);let u=f * f * f * (f * (f * 6.0 - 15.0) + 10.0);let a=hash(p);let b=hash(p + vec2<f32>(1.0,0.0));let c=hash(p + vec2<f32>(0.0,1.0));let d=hash(p + vec2<f32>(1.0,1.0));let noise=mix(mix(a,b,u.x),mix(c,d,u.x),u.y);return (noise - 0.5) * 2.0;}fn hash(p:vec2<f32>) -> f32 {var p3=fract(vec3<f32>(p.xyx) * 0.1031);p3 +=dot(p3,p3.yzx + 33.33);return fract((p3.x + p3.y) * p3.z);}")),this.#ph()}get filmGrainIntensity(){return this.#lh}set filmGrainIntensity(i){this.#lh=Math.max(0,Math.min(1,i)),this.updateUniform("filmGrainIntensity",this.#lh)}get filmGrainResponse(){return this.#ch}set filmGrainResponse(i){this.#ch=Math.max(0,Math.min(2,i)),this.updateUniform("filmGrainResponse",this.#ch)}get filmGrainScale(){return this.#hh}set filmGrainScale(i){this.#hh=Math.max(.1,Math.min(20,i)),this.updateUniform("filmGrainScale",this.#hh)}get coloredGrain(){return this.#fh}set coloredGrain(i){this.#fh=Math.max(0,Math.min(1,i)),this.updateUniform("coloredGrain",this.#fh)}get grainSaturation(){return this.#dh}set grainSaturation(i){this.#dh=Math.max(0,Math.min(2,i)),this.updateUniform("grainSaturation",this.#dh)}applyPreset(i){this.#lh=i.filmGrainIntensity,this.#ch=i.filmGrainResponse,this.#hh=i.filmGrainScale,this.#fh=i.coloredGrain,this.#dh=i.grainSaturation,this.#ph()}update(i){this.#Il+=i,this.updateUniform("time",this.#Il)}#ph(){this.updateUniform("filmGrainIntensity",this.#lh),this.updateUniform("filmGrainResponse",this.#ch),this.updateUniform("filmGrainScale",this.#hh),this.updateUniform("coloredGrain",this.#fh),this.updateUniform("grainSaturation",this.#dh),this.updateUniform("time",this.#Il),this.updateUniform("devicePixelRatio",this.#mh)}}Object.freeze(FilmGrain);class ChromaticAberration extends ASinglePassPostEffect{#Jc=.015;#Qr=.5;#en=.5;#gh=1;constructor(i){super(i);this.init(i,"POST_EFFECT_CHROMATIC_ABERRATION",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=vec2<f32>(f32(global_id.x),f32(global_id.y))/vec2<f32>(dimW,dimH);let center=vec2<f32>(uniforms.centerX,uniforms.centerY);let offset=uv - center;let distance=length(offset);let distortion=uniforms.strength * pow(distance,uniforms.falloff);let redOffset=uv + offset * distortion * vec2<f32>(-1.0,-1.0);let greenOffset=uv;let blueOffset=uv + offset * distortion * vec2<f32>(1.0,1.0);var finalColor=vec3<f32>(0.0);if (redOffset.x >=0.0 && redOffset.x <=1.0 && redOffset.y >=0.0 && redOffset.y <=1.0) {let redCoord=vec2<i32>(i32(clamp(redOffset.x * dimW,0.0,dimW - 1.0)),i32(clamp(redOffset.y * dimH,0.0,dimH - 1.0)));finalColor.r=textureLoad(sourceTexture,redCoord).r;}let greenCoord=vec2<i32>(i32(clamp(greenOffset.x * dimW,0.0,dimW - 1.0)),i32(clamp(greenOffset.y * dimH,0.0,dimH - 1.0)));finalColor.g=textureLoad(sourceTexture,greenCoord).g;if (blueOffset.x >=0.0 && blueOffset.x <=1.0 && blueOffset.y >=0.0 && blueOffset.y <=1.0) {let blueCoord=vec2<i32>(i32(clamp(blueOffset.x * dimW,0.0,dimW - 1.0)),i32(clamp(blueOffset.y * dimH,0.0,dimH - 1.0)));finalColor.b=textureLoad(sourceTexture,blueCoord).b;}let originalAlpha=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).a;textureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(finalColor,originalAlpha));","struct Uniforms {strength:f32,centerX:f32,centerY:f32,falloff:f32};")),this.strength=this.#Jc,this.centerX=this.#Qr,this.centerY=this.#en,this.falloff=this.#gh}get strength(){return this.#Jc}set strength(i){validateNumberRange(i,0),this.#Jc=i,this.updateUniform("strength",i)}get centerX(){return this.#Qr}set centerX(i){validateNumberRange(i,0,1),this.#Qr=i,this.updateUniform("centerX",i)}get centerY(){return this.#en}set centerY(i){validateNumberRange(i,0,1),this.#en=i,this.updateUniform("centerY",i)}get falloff(){return this.#gh}set falloff(i){validateNumberRange(i,0,5),this.#gh=i,this.updateUniform("falloff",i)}}Object.freeze(ChromaticAberration);class DOFCoC extends ASinglePassPostEffect{#xh=15;#_h=1.4;#vh=32;#bh=.1;#yh=1e3;constructor(i){super(i),this.useDepthTexture=!0;const m=createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);let coord=vec2<i32>(global_id.xy);let originalColor=textureLoad(sourceTexture,coord).xyzw;let depth=textureLoad(depthTexture,coord,0);let linearDepth=linearizeDepth(depth);let coc=calculateCoC(linearDepth);\n/* CoC를 0~1 범위로 인코딩해서 저장 */let encodedCoC=encodeCoC(coc);textureStore(outputTexture,coord,vec4<f32>(originalColor.rgb,encodedCoC));","struct Uniforms {focusDistance:f32,aperture:f32,maxCoC:f32,nearPlane:f32,farPlane:f32,};fn linearizeDepth(depth:f32) -> f32 {let z=depth * 2.0 - 1.0;return (2.0 * uniforms.nearPlane * uniforms.farPlane)/(uniforms.farPlane + uniforms.nearPlane - z * (uniforms.farPlane - uniforms.nearPlane));}\n/* CoC 값을 0~1 범위로 인코딩 */fn encodeCoC(coc:f32) -> f32 {return (coc + 1.0) * 0.5;}fn calculateCoC(linearDepth:f32) -> f32 {let subjectDistance=linearDepth;let focalLength=50.0;let focusRange=uniforms.focusDistance * 0.15; let transitionRange=uniforms.focusDistance * 0.35;let distanceFromFocus=abs(subjectDistance - uniforms.focusDistance);if (distanceFromFocus < focusRange) {let focusFactor=smoothstep(0.0,focusRange,distanceFromFocus);return mix(0.0,0.02,focusFactor);/* 완전히 0이 아닌 미세한 값 */}var rawCoC:f32;var signedCoC:f32;if (subjectDistance < uniforms.focusDistance) {\n/* Near field 처리 */let nearDistance=uniforms.focusDistance - subjectDistance;let nearFactor=nearDistance/uniforms.focusDistance;rawCoC=(uniforms.aperture * focalLength * nearDistance)/(subjectDistance * (uniforms.focusDistance - focalLength));\n/* Near 필드 강화 (하지만 부드럽게) */rawCoC=rawCoC * (1.0 + nearFactor * 1.5);/* 2.0 → 1.5로 완화 */signedCoC=-(rawCoC/uniforms.maxCoC);\n/* 🎯 부드러운 강화 적용 */let absCoC=abs(signedCoC);if (absCoC > 0.05) {\n/* 급격한 증폭 대신 부드러운 곡선 사용 */signedCoC=-min(1.0,absCoC * smoothstep(0.05,0.3,absCoC) * 1.5);}\n/* 🎯 전환 영역에서 추가 부드러움 */if (distanceFromFocus < transitionRange) {let transitionFactor=smoothstep(focusRange,transitionRange,distanceFromFocus);signedCoC=mix(0.0,signedCoC,transitionFactor);}return clamp(signedCoC,-1.0,0.0);} else {\n/* Far field 처리 */let farDistance=subjectDistance - uniforms.focusDistance;rawCoC=(uniforms.aperture * focalLength * farDistance)/(subjectDistance * (uniforms.focusDistance + focalLength));rawCoC=rawCoC * (1.0 + farDistance * 0.08);/* 0.1 → 0.08로 완화 */signedCoC=rawCoC/uniforms.maxCoC;let absCoC=abs(signedCoC);if (absCoC > 0.1) {signedCoC=min(1.0,absCoC * smoothstep(0.1,0.5,absCoC) * 1.2);}if (distanceFromFocus < transitionRange) {let transitionFactor=smoothstep(focusRange,transitionRange,distanceFromFocus);signedCoC=mix(0.0,signedCoC,transitionFactor);}return clamp(signedCoC,0.0,1.0);}}");this.init(i,"POST_EFFECT_DOF_COC",m),this.focusDistance=this.#xh,this.aperture=this.#_h,this.maxCoC=this.#vh,this.nearPlane=this.#bh,this.farPlane=this.#yh}get focusDistance(){return this.#xh}set focusDistance(i){validateNumberRange(i),this.#xh=i,this.updateUniform("focusDistance",i)}get aperture(){return this.#_h}set aperture(i){validateNumberRange(i),this.#_h=i,this.updateUniform("aperture",i)}get maxCoC(){return this.#vh}set maxCoC(i){validateNumberRange(i),this.#vh=i,this.updateUniform("maxCoC",i)}get nearPlane(){return this.#bh}set nearPlane(i){validateNumberRange(i),this.#bh=i,this.updateUniform("nearPlane",i)}get farPlane(){return this.#yh}set farPlane(i){validateNumberRange(i),this.#yh=i,this.updateUniform("farPlane",i)}}Object.freeze(DOFCoC);class DOFUnified extends ASinglePassPostEffect{#Th=16;#Sh=24;#wh=1;#Mh=1;constructor(i){super(i);const{WORK_SIZE_X:m,WORK_SIZE_Y:g,WORK_SIZE_Z:x}=this,_=`struct Uniforms {nearBlurSize:f32,farBlurSize:f32,nearStrength:f32,farStrength:f32,};@group(0) @binding(0) var sourceTexture:texture_storage_2d<rgba8unorm,read>;@group(0) @binding(1) var cocTexture:texture_storage_2d<rgba8unorm,read>;@group(1) @binding(0) var outputTexture:texture_storage_2d<rgba8unorm,write>;@group(1) @binding(1) var<uniform> uniforms:Uniforms;/* CoC 디코딩 함수 */fn decodeCoC(encoded:f32) -> f32 {/* 0~1 범위를 -1~1 범위로 복원 */return encoded * 2.0 - 1.0;}@compute @workgroup_size(${m},${g},${x})fn main (@builtin(global_invocation_id) global_id:vec3<u32>) {let index=vec2<u32>(global_id.xy);let dimensions:vec2<u32>=textureDimensions(sourceTexture);if (index.x >=dimensions.x || index.y >=dimensions.y) {return;}let originalColor=textureLoad(sourceTexture,index).rgb;let encodedCoC=textureLoad(cocTexture,index).a;/* CoC 값 디코딩 */let cocValue=decodeCoC(encodedCoC);/* CoC 임계값 체크 */if (abs(cocValue) < 0.005) {textureStore(outputTexture,index,vec4<f32>(originalColor,1.0));return;}var finalColor=originalColor;/* Near blur 처리 (CoC < 0) */if (cocValue < 0.0) {let nearBlur=calculateBlur(index,abs(cocValue),uniforms.nearBlurSize,true);/* Near strength 블렌딩 개선 - 더 강한 효과 */let nearBlend=saturate(pow(abs(cocValue) * uniforms.nearStrength,0.7));finalColor=mix(originalColor,nearBlur,nearBlend);}/* Far blur 처리 (CoC > 0) */else if (cocValue > 0.0) {let farBlur=calculateBlur(index,cocValue,uniforms.farBlurSize,false);let rawBlend=cocValue * uniforms.farStrength;let farBlend=saturate(smoothstep(0.0,0.8,rawBlend));finalColor=mix(originalColor,farBlur,farBlend);}textureStore(outputTexture,index,vec4<f32>(finalColor,1.0));}fn calculateBlur(center:vec2<u32>,intensity:f32,maxBlurSize:f32,isNear:bool) -> vec3<f32> {let dimensions:vec2<u32>=textureDimensions(sourceTexture);let blurRadius=intensity * maxBlurSize;/* 최소 블러 반경 조정 */if (blurRadius < 0.3) {return textureLoad(sourceTexture,center).rgb;}var sum:vec3<f32>=vec3<f32>(0.0);var totalWeight=0.0;let maxRadius=min(blurRadius,maxBlurSize);/* Near blur에 더 많은 샘플 적용 */let samples=select(8,16,isNear);/* near=16,far=8 */let angleStep=6.28318530718/f32(samples);let originalColor=textureLoad(sourceTexture,center).rgb;/* Near blur에 더 강한 중앙 가중치 */let centerWeight=select(0.4,0.2,isNear);/* near=0.2,far=0.4 */sum +=originalColor * centerWeight;totalWeight +=centerWeight;/* 방사형 샘플링 */for (var i=0;i < samples;i=i + 1) {for (var r=1.0;r <=maxRadius;r=r + 1.0) {let angle=f32(i) * angleStep;let offset=vec2<f32>(cos(angle) * r,sin(angle) * r);let samplePos=vec2<i32>(clamp(i32(f32(center.x) + offset.x),0,i32(dimensions.x) - 1),clamp(i32(f32(center.y) + offset.y),0,i32(dimensions.y) - 1));let sampleColor=textureLoad(sourceTexture,vec2<u32>(samplePos)).rgb;let sampleEncodedCoC=textureLoad(cocTexture,vec2<u32>(samplePos)).a;let sampleCoC=decodeCoC(sampleEncodedCoC);/* 디코딩 추가 *//* 가우시안 가중치 */var weight=exp(-r * r/(maxRadius * maxRadius * 0.5));/* CoC 기반 가중치 조정 */if (isNear) {/* Near blur:더 강한 조건으로 가중치 증가 */if (sampleCoC < 0.0 && abs(sampleCoC) >=intensity * 0.5) {weight *=1.5;}} else {/* Far blur:기존 조건 유지 */if (sampleCoC > 0.0 && sampleCoC >=intensity * 0.7) {weight *=1.2;}}sum +=sampleColor * weight;totalWeight +=weight;}}/* 추가 근거리 샘플링 (near blur만) */if (isNear && maxRadius > 2.0) {let additionalSamples=8;let innerRadius=maxRadius * 0.3;let innerAngleStep=6.28318530718/f32(additionalSamples);for (var i=0;i < additionalSamples;i=i + 1) {let angle=f32(i) * innerAngleStep + 0.5;/* 약간의 오프셋 */let offset=vec2<f32>(cos(angle) * innerRadius,sin(angle) * innerRadius);let samplePos=vec2<i32>(clamp(i32(f32(center.x) + offset.x),0,i32(dimensions.x) - 1),clamp(i32(f32(center.y) + offset.y),0,i32(dimensions.y) - 1));let sampleColor=textureLoad(sourceTexture,vec2<u32>(samplePos)).rgb;let weight=0.8;sum +=sampleColor * weight;totalWeight +=weight;}}if (totalWeight > 0.0) {return sum/totalWeight;} else {return originalColor;}}`;this.init(i,"POST_EFFECT_DOF_UNIFIED",{msaa:_,nonMsaa:_}),this.nearBlurSize=this.#Th,this.farBlurSize=this.#Sh,this.nearStrength=this.#wh,this.farStrength=this.#Mh}get nearBlurSize(){return this.#Th}set nearBlurSize(i){validateNumberRange(i),this.#Th=i,this.updateUniform("nearBlurSize",i)}get farBlurSize(){return this.#Sh}set farBlurSize(i){validateNumberRange(i),this.#Sh=i,this.updateUniform("farBlurSize",i)}get nearStrength(){return this.#wh}set nearStrength(i){validateNumberRange(i),this.#wh=i,this.updateUniform("nearStrength",i)}get farStrength(){return this.#Mh}set farStrength(i){validateNumberRange(i),this.#Mh=i,this.updateUniform("farStrength",i)}render(i,m,g,x,_){return super.render(i,m,g,x,_)}}Object.freeze(DOFUnified);class DOF extends AMultiPassPostEffect{#Rh;#Ph;#xh=15;#_h=2.8;#vh=25;#bh=.1;#yh=1e3;#Th=15;#Sh=15;#wh=1;#Mh=1;constructor(i){super(i,[new DOFCoC(i),new DOFUnified(i)]),this.#Rh=this.passList[0],this.#Ph=this.passList[1],this.#Rh.focusDistance=this.#xh,this.#Rh.aperture=this.#_h,this.#Rh.maxCoC=this.#vh,this.#Rh.nearPlane=this.#bh,this.#Rh.farPlane=this.#yh,this.#Ph.nearBlurSize=this.#Th,this.#Ph.farBlurSize=this.#Sh,this.#Ph.nearStrength=this.#wh,this.#Ph.farStrength=this.#Mh}get focusDistance(){return this.#xh}set focusDistance(i){this.#xh=i,this.#Rh.focusDistance=i}get aperture(){return this.#_h}set aperture(i){this.#_h=i,this.#Rh.aperture=i}get maxCoC(){return this.#vh}set maxCoC(i){this.#vh=i,this.#Rh.maxCoC=i}get nearPlane(){return this.#bh}set nearPlane(i){this.#bh=i,this.#Rh.nearPlane=i}get farPlane(){return this.#yh}set farPlane(i){this.#yh=i,this.#Rh.farPlane=i}get nearBlurSize(){return this.#Th}set nearBlurSize(i){this.#Th=i,this.#Ph.nearBlurSize=i}get farBlurSize(){return this.#Sh}set farBlurSize(i){this.#Sh=i,this.#Ph.farBlurSize=i}get nearStrength(){return this.#wh}set nearStrength(i){this.#wh=i,this.#Ph.nearStrength=i}get farStrength(){return this.#Mh}set farStrength(i){this.#Mh=i,this.#Ph.farStrength=i}setGameDefault(){this.focusDistance=15,this.aperture=2.8,this.maxCoC=25,this.nearBlurSize=15,this.farBlurSize=15,this.nearStrength=1,this.farStrength=1}setCinematic(){this.focusDistance=20,this.aperture=1.4,this.maxCoC=40,this.nearBlurSize=25,this.farBlurSize=30,this.nearStrength=1.2,this.farStrength=1.3}setPortrait(){this.focusDistance=8,this.aperture=1.8,this.maxCoC=35,this.nearBlurSize=12,this.farBlurSize=25,this.nearStrength=.8,this.farStrength=1.4}setLandscape(){this.focusDistance=50,this.aperture=8,this.maxCoC=20,this.nearBlurSize=20,this.farBlurSize=10,this.nearStrength=1.1,this.farStrength=.6}setMacro(){this.focusDistance=2,this.aperture=1,this.maxCoC=50,this.nearBlurSize=30,this.farBlurSize=35,this.nearStrength=1.5,this.farStrength=1.6}setSports(){this.focusDistance=25,this.aperture=4,this.maxCoC=18,this.nearBlurSize=10,this.farBlurSize=12,this.nearStrength=.8,this.farStrength=.9}setNightMode(){this.focusDistance=12,this.aperture=2,this.maxCoC=30,this.nearBlurSize=18,this.farBlurSize=20,this.nearStrength=1.1,this.farStrength=1.2}render(i,m,g,x){const _=this.#Rh.render(i,m,g,x);return this.#Ph.render(i,m,g,x,_)}}Object.freeze(DOF);class LensDistortion extends ASinglePassPostEffect{#Ch=.1;#Ih=0;#Qr=0;#en=0;constructor(i){super(i);this.init(i,"POST_EFFECT_LENS_DISTORTION",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);let global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));let uv=global_id_vec/vec2<f32>(dimW,dimH);let uvCenter=center/vec2<f32>(dimW,dimH);let offset=uv - uvCenter;let distance=length(offset);let barrelFactor=1.0 + uniforms.barrelStrength * distance * distance;let pincushionFactor=1.0 - uniforms.pincushionStrength * distance * distance;let distortionFactor=barrelFactor * pincushionFactor;let distortedUV=uvCenter + offset * distortionFactor;\nif (distortedUV.x < 0.0 || distortedUV.x > 1.0 || distortedUV.y < 0.0 || distortedUV.y > 1.0) {textureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(0.0,0.0,0.0,1.0));} else {let sampleCoord=vec2<i32>(i32(clamp(distortedUV.x * dimW,0.0,dimW - 1.0)),i32(clamp(distortedUV.y * dimH,0.0,dimH - 1.0)));let sampledColor=textureLoad(sourceTexture,sampleCoord).xyzw;textureStore(outputTexture,vec2<i32>(global_id.xy),sampledColor);}","struct Uniforms {barrelStrength:f32,pincushionStrength:f32,centerX:f32,centerY:f32};")),this.barrelStrength=this.#Ch,this.pincushionStrength=this.#Ih,this.centerX=this.#Qr,this.centerY=this.#en}get barrelStrength(){return this.#Ch}set barrelStrength(i){validateNumberRange(i,0),this.#Ch=i,this.updateUniform("barrelStrength",i)}get pincushionStrength(){return this.#Ih}set pincushionStrength(i){validateNumberRange(i,0),this.#Ih=i,this.updateUniform("pincushionStrength",i)}get centerX(){return this.#Qr}set centerX(i){validateNumber(i),this.#Qr=i,this.updateUniform("centerX",i)}get centerY(){return this.#en}set centerY(i){validateNumber(i),this.#en=i,this.updateUniform("centerY",i)}}Object.freeze(LensDistortion);class Vignetting extends ASinglePassPostEffect{#Eh=.2;#K=.5;constructor(i){super(i);this.init(i,"POST_EFFECT_VIGNETTING",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let index=vec2<u32>(global_id.xy);let uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);let smoothness=uniforms.smoothness;let size=uniforms.size;var color:vec4<f32>=textureLoad(sourceTexture,index);var diff=size - distance(uv,vec2<f32>(0.5));let vignette=smoothstep(-smoothness,smoothness,diff);color.r *=vignette;color.g *=vignette;color.b *=vignette;textureStore(outputTexture,index,color);","struct Uniforms {smoothness:f32,size:f32,};")),this.smoothness=this.#Eh,this.size=this.#K}get size(){return this.#K}set size(i){validateNumberRange(i,0),this.#K=i,this.updateUniform("size",i)}get smoothness(){return this.#Eh}set smoothness(i){validateNumberRange(i,0,1),this.#Eh=i,this.updateUniform("smoothness",i)}}Object.freeze(Vignetting);class OldBloomBlend extends ASinglePassPostEffect{#Lh=1;#ol=1;constructor(i){super(i);const{WORK_SIZE_X:m,WORK_SIZE_Y:g,WORK_SIZE_Z:x}=this,_=`struct Uniforms {bloomStrength:f32,exposure:f32};@group(0) @binding(0) var sourceTexture0:texture_storage_2d<rgba8unorm,read>;@group(0) @binding(1) var sourceTexture1:texture_storage_2d<rgba8unorm,read>;@group(1) @binding(0) var outputTexture:texture_storage_2d<rgba8unorm,write>;@group(1) @binding(1) var<uniform> uniforms:Uniforms;@compute @workgroup_size(${m},${g},${x})fn main (@builtin(global_invocation_id) global_id:vec3<u32>,){let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture0);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var diffuse:vec4<f32>=textureLoad(sourceTexture0,index,);var blur:vec4<f32>=textureLoad(sourceTexture1,index,);let finalColor=vec4<f32>((diffuse.rgb + blur.rgb * uniforms.bloomStrength ) * uniforms.exposure,diffuse.a);textureStore(outputTexture,index,finalColor );};`;this.init(i,"POST_EFFECT_OLD_BLOOM",{msaa:_,nonMsaa:_}),this.exposure=this.#ol,this.bloomStrength=this.#Lh}get bloomStrength(){return this.#Lh}set bloomStrength(i){this.#Lh=i,this.updateUniform("bloomStrength",i)}get exposure(){return this.#ol}set exposure(i){this.#ol=i,this.updateUniform("exposure",i)}render(i,m,g,x,_){return super.render(i,m,g,x,_)}}Object.freeze(OldBloomBlend);class OldBloom extends AMultiPassPostEffect{#Bh;#Dh;#Uh;#th=156;#Ah=32;#ol=1;#Lh=1.2;constructor(i){super(i,[new Threshold(i),new GaussianBlur(i),new OldBloomBlend(i)]),this.#Bh=this.passList[0],this.#Dh=this.passList[1],this.#Uh=this.passList[2],this.#Bh.threshold=this.#th,this.#Dh.size=this.#Ah,this.#Uh.exposure=this.#ol,this.#Uh.bloomStrength=this.#Lh}get threshold(){return this.#th}set threshold(i){this.#th=i,this.#Bh.threshold=i}get gaussianBlurSize(){return this.#Ah}set gaussianBlurSize(i){this.#Ah=i,this.#Dh.size=i}get exposure(){return this.#ol}set exposure(i){this.#ol=i,this.#Uh.exposure=i}get bloomStrength(){return this.#Lh}set bloomStrength(i){this.#Lh=i,this.#Uh.bloomStrength=i}render(i,m,g,x){const _=this.#Bh.render(i,m,g,x),b=this.#Dh.render(i,m,g,_);return this.#Uh.render(i,m,g,x,b)}}Object.freeze(OldBloom);class Sharpen extends AMultiPassPostEffect{#ih;constructor(i){super(i,[new Convolution(i)]),this.#ih=this.passList[0],this.#ih.kernel=Convolution.SHARPEN}render(i,m,g,x){return this.#ih.render(i,m,g,x)}}Object.freeze(Sharpen);var bs=Object.freeze({__proto__:null,AMultiPassPostEffect:AMultiPassPostEffect,ASinglePassPostEffect:ASinglePassPostEffect,Blur:Blur,BlurX:BlurX,BlurY:BlurY,BrightnessContrast:BrightnessContrast,ChromaticAberration:ChromaticAberration,ColorBalance:ColorBalance,ColorTemperatureTint:ColorTemperatureTint,Convolution:Convolution,DOF:DOF,DirectionalBlur:DirectionalBlur,FilmGrain:FilmGrain,GaussianBlur:GaussianBlur,Grayscale:Grayscale,HueSaturation:HueSaturation,Invert:Invert,LensDistortion:LensDistortion,OldBloom:OldBloom,PostEffectManager:PostEffectManager,RadialBlur:RadialBlur,Sharpen:Sharpen,Threshold:Threshold,Vibrance:Vibrance,Vignetting:Vignetting,ZoomBlur:ZoomBlur}),ys=Object.freeze({__proto__:null,PICKING_EVENT_TYPE:Mi,PickingEvent:PickingEvent,PickingManager:PickingManager});const init=async(i,m,g,x,_="premultiplied",b={powerPreference:"high-performance",forceFallbackAdapter:!1})=>{const{gpu:y}=navigator,errorHandler=(i,m)=>{const x=generateErrorMessage(i,m);console.error("\n============\n",x,"\n============\n"),g?.(x)},validateAndRequestDevice=async m=>{const g=[];m.features.has("texture-compression-astc")&&g.push("texture-compression-astc");const x={requiredFeatures:g};try{const g=await m.requestDevice(x);validateAndInitializeContext(i,m,g)}catch(i){errorHandler(null,`Failed to request device. Adapter was ${m},error message is ${i.message}`)}},validateAndInitializeContext=(i,b,y)=>{const T=i.getContext("webgpu");if(T)try{const g=new RedGPUContext(i,b,y,T,_);m(g),y.addEventListener("uncapturederror",i=>{console.warn("TODO A WebGPU error was not captured:",i),console.warn(i.error?.message),window.cancelAnimationFrame(g.currentRequestAnimationFrame)}),y.lost.then(i=>{console.warn(i),console.warn(`Device lost occurred:${i.message}`),"destroyed"===i.reason&&x?.(i)})}catch(i){g(errorHandler(i,""))}else errorHandler(new Error(`Failed to get context from canvas:${i.id||i}`),"Failed to get webgpu initialize from canvas")},initializeWebGPU=async()=>{m instanceof Function?i instanceof HTMLCanvasElement?await(async i=>{i||errorHandler(null,"Cannot find navigator.gpu");try{const m=await i.requestAdapter(b);await validateAndRequestDevice(m)}catch(m){errorHandler(m,`Failed to request adapter or validate device with target GPU:${i},error message is ${m.message}`)}})(y):errorHandler(null,`Expected HTMLCanvasElement,but received:${i}`):errorHandler(null,`Expected onWebGPUInitialized,but received:${m}`)};try{await initializeWebGPU()}catch(i){errorHandler(i,`Unexpected error occurred during WebGPU initialization:${i.message}`)}},generateErrorMessage=(i,m)=>{let g=m;return i instanceof Error?(g=i.message??m,"string"==typeof i.stack&&(g+=`\nStack Trace:${i.stack}`)):console.warn("generateErrorMessage function expected an Error instance,but got:",i),g};class TextureLoaderData{src;texture;loadEnd;loadSuccess;srcInfo;idx;constructor(i,m,g){this.src=i,this.texture=null,this.loadEnd=!1,this.loadSuccess=!1,this.srcInfo=m,this.idx=g}}class TextureLoader{textures=[];#kh=0;#_;#Oh;#Nh;#Fh;constructor(i,m=[],g,x){this.#_=i,this.#Oh=m,this.#Nh=g,this.#Fh=x,this.#Oh.length?this.#Oh.forEach((i,m)=>this.#Gh(i,m)):this.#Vh()}getTextureByIndex(i){if(this.textures[i])return this.textures[i].texture}#Gh(i,m){let g,x,_=BitmapTexture;x=i.hasOwnProperty("src")?i.src:i,x instanceof Array&&(_=CubeTexture),g=new TextureLoaderData(x,i,m);const onLoadHandler=()=>{g.loadSuccess=!0,g.loadEnd=!0,this.#$h()},onErrorHandler=()=>{g.loadSuccess=!1,g.loadEnd=!0,this.#$h()};g.texture=_===BitmapTexture?new _(this.#_,i,!0,onLoadHandler,onErrorHandler,i.format,!1):new _(this.#_,i,!0,onLoadHandler,onErrorHandler,i.format),this.textures.push(g)}#$h(){this.#kh++,this.#Fh&&this.#Fh.call(this,{totalNum:this.#Oh.length,loaded:this.#kh}),this.#kh===this.#Oh.length&&this.#Vh()}#Vh(){requestAnimationFrame(()=>{this.#Nh&&this.#Nh.call(this,this)})}}const arrayBufferLoader=(i,m,g)=>{fetch(i).then(i=>{if(!i.ok)throw new Error(`Network response was not ok ${i.statusText}`);return i.arrayBuffer()}).then(i=>{m&&m(i)}).catch(i=>{})},Ts={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};Object.freeze(Ts);class AccessorInfo_GLTF{accessor;bufferView;bufferGlTfId;buffer;bufferURIDataView;componentType;componentType_BYTES_PER_ELEMENT;getMethod;accessorBufferOffset;bufferViewOffset;bufferViewByteStride;startIndex;constructor(i,m,g){switch(this.accessor=m.accessors[g],this.bufferView=m.bufferViews[this.accessor.bufferView],this.bufferGlTfId=this.bufferView.buffer,this.buffer=m.buffers[this.bufferGlTfId],this.bufferURIDataView=null,this.buffer.uri&&(this.bufferURIDataView=i.parsingResult.uris.buffers[this.bufferGlTfId]),this.componentType=Ts[this.accessor.componentType],this.componentType_BYTES_PER_ELEMENT=this.componentType.BYTES_PER_ELEMENT,this.componentType){case Float32Array:this.getMethod="getFloat32";break;case Uint32Array:this.getMethod="getUint32";break;case Uint16Array:this.getMethod="getUint16";break;case Int16Array:this.getMethod="getInt16";break;case Uint8Array:this.getMethod="getUint8";break;case Int8Array:this.getMethod="getInt8";break;default:consoleAndThrowError("파싱할수없는 타입",this.componentType)}this.accessorBufferOffset=this.accessor.byteOffset||0,this.bufferViewOffset=this.bufferView.byteOffset||0,this.bufferViewByteStride=this.bufferView.byteStride||0,this.startIndex=(this.bufferViewOffset+this.accessorBufferOffset)/this.componentType_BYTES_PER_ELEMENT}}class AnimationData_GLTF{gltfLoader;scenesData;accessorGlTfId;dataList;constructor(i,m,g){this.gltfLoader=i,this.scenesData=m,this.accessorGlTfId=g;const x=new AccessorInfo_GLTF(this.gltfLoader,this.scenesData,this.accessorGlTfId),{accessor:_,startIndex:b,componentType_BYTES_PER_ELEMENT:y,bufferURIDataView:T,getMethod:w}=x,{type:P,count:$}=_;let H=b,z=1;switch(P){case"SCALAR":z=1;break;case"VEC4":z=4;break;case"VEC3":z=3}this.dataList=[];let q=0;for(;q<$*z;H++,q++)this.dataList[q]=T[w](H*y,!0)}}class AniTrack_GLTF{key;timeAnimationInfo;aniDataAnimationInfo;interpolation;animationTargetMesh;weightMeshes;constructor(i,m,g,x,_,b){this.key=i,this.timeAnimationInfo=m,this.aniDataAnimationInfo=g,this.interpolation=x,this.animationTargetMesh=_,this.weightMeshes=b}}const parseAnimations=(i,m)=>new Promise(async g=>{m.animations||(m.animations=[]);const{parsingResult:x}=i,{animations:_}=x,{animations:b}=m;if(b.length){const g=b.map(async g=>{const{samplers:x,channels:b}=g,y=[];y.minTime=1e7,y.maxTime=-1,y.name=g.name,_.push(y),await Promise.all(b.map(async g=>((i,m,g,x,_)=>{let b,y;const{nodes:T,meshes:w}=_,P=[],{sampler:$,target:H}=g,z=x[$],{node:q,path:W}=H,ye=T[q];if("mesh"in ye){b=ye.Mesh;const{primitives:i}=w[ye.mesh];let m=i.length;for(;m--;)P.push(i[m].Mesh)}else{let m;if(!i.parsingResult.groups[q])return;m=i.parsingResult.groups[q],b=m}if("scale"!=W&&"rotation"!=W&&"translation"!=W&&"weights"!=W||(y=new AniTrack_GLTF(W,new AnimationData_GLTF(i,_,z.input),new AnimationData_GLTF(i,_,z.output),z.interpolation,b,P),m.push(y)),y){const{timeAnimationInfo:i}=y,{dataList:g}=i;m.minTime>g[0]&&(m.minTime=g[0]),m.maxTime<g[g.length-1]&&(m.maxTime=g[g.length-1])}})(i,y,g,x,m)))});await Promise.all(g),_.length&&_.forEach(m=>i.playAnimation(m))}g()});let Ss=new Float32Array(16),ws=new Float32Array(16);class ParsedSkinInfo_GLTF{joints;inverseBindMatrices;skeletonMesh;isInverseBindMatrixUpdated=!1;vertexStorageInfo;vertexStorageBuffer;#Hh;#zh;constructor(){this.joints=[],this.inverseBindMatrices=null,this.skeletonMesh=null}update(i,m){const g=this.#qh(m.modelMatrix),x=this.#Kh(this.joints,g);this.#Wh(i,m.animationInfo.skinInfo,x)}#qh(i){return this.#Hh=this.#Hh||new Float32Array(i.length),this.#Hh.set(i),invert$2(this.#Hh,this.#Hh),this.#Hh}#Kh(i,m){const g=16*i.length;this.#zh&&this.#zh.length==g||(this.#zh=new Float32Array(g));for(let g=0;g<i.length;g++){const x=multiply$5(Ss,m,i[g].modelMatrix),_=multiply$5(ws,x,this.inverseBindMatrices[g]);this.#zh.set(_,16*g)}return this.#zh}#Wh(i,m,g){const{vertexStorageBuffer:x,vertexStorageInfo:_}=m,{gpuBuffer:b}=x,{jointMatrix:y}=_.members;i.gpuDevice.queue.writeBuffer(b,y.uniformOffset,g)}}const parseJoint_GLTF=(i,m,g,x)=>{const _=g[x].Mesh;_?(m.joints.push(_),_.depthCompare=Qn.NEVER):requestAnimationFrame(function(){parseJoint_GLTF(i,m,g,x)})},parseAttributeInfo_GLTF=function(i,m,g,x,_,b,y,T,w,P,$){const{accessor:H,startIndex:z,getMethod:q,bufferViewByteStride:W,bufferURIDataView:ye,componentType_BYTES_PER_ELEMENT:Ge}=m,{type:Ke,count:Xe}=H;let je=0;const Ye=W/Ge;let Ze,Je=z;switch(Ke){case"VEC4":if(W)for(Ze=Je+Xe*(W/Ge);Je<Ze;Je++)je%Ye<4&&("WEIGHTS_0"==i?T.push(ye[q](Je*Ge,!0)):"JOINTS_0"==i?w.push(ye[q](Je*Ge,!0)):"COLOR_0"==i?P.push(ye[q](Je*Ge,!0)):"TANGENT"==i?$.push(ye[q](Je*Ge,!0)):consoleAndThrowError("VEC4에서 현재 지원하고 있지 않는 키",i)),je++;else for(Ze=Je+4*Xe;Je<Ze;Je++)"WEIGHTS_0"==i?T.push(ye[q](Je*Ge,!0)):"JOINTS_0"==i?w.push(ye[q](Je*Ge,!0)):"COLOR_0"==i?P.push(ye[q](Je*Ge,!0)):"TANGENT"==i?$.push(ye[q](Je*Ge,!0)):consoleAndThrowError("VEC4에서 현재 지원하고 있지 않는 키",i),je++;break;case"VEC3":if(W)for(Ze=Je+Xe*(W/Ge);Je<Ze;Je++)je%Ye<3&&("NORMAL"==i?y.push(ye[q](Je*Ge,!0)):"POSITION"==i?g.push(ye[q](Je*Ge,!0)):"COLOR_0"==i?(P.push(ye[q](Je*Ge,!0)),je%Ye==2&&P.push(1)):"TANGENT"==i?$.push(ye[q](Je*Ge,!0)):consoleAndThrowError("VEC3에서 현재 지원하고 있지 않는 키",i)),je++;else for(Ze=Je+3*Xe;Je<Ze;Je++)"NORMAL"==i?y.push(ye[q](Je*Ge,!0)):"POSITION"==i?g.push(ye[q](Je*Ge,!0)):"COLOR_0"==i?(P.push(ye[q](Je*Ge,!0)),je%3==2&&P.push(1)):"TANGENT"==i?$.push(ye[q](Je*Ge,!0)):consoleAndThrowError("VEC3에서 현재 지원하고 있지 않는 키",i),je++;break;case"VEC2":if(W)for(Ze=Je+Xe*(W/Ge);Je<Ze;Je++)je%Ye<2&&("TEXCOORD_0"==i?x.push(ye[q](Je*Ge,!0)):"TEXCOORD_1"==i?_.push(ye[q](Je*Ge,!0)):"TEXCOORD_2"==i?b.push(ye[q](Je*Ge,!0)):consoleAndThrowError("VEC2에서 현재 지원하고 있지 않는 키",i)),je++;else for(Ze=Je+2*Xe;Je<Ze;Je++)"TEXCOORD_0"==i?x.push(ye[q](Je*Ge,!0)):"TEXCOORD_1"==i?_.push(ye[q](Je*Ge,!0)):"TEXCOORD_2"==i?b.push(ye[q](Je*Ge,!0)):consoleAndThrowError("VEC2에서 현재 지원하고 있지 않는 키",i),je++}},parseSparse_GLTF=(i,m,g,x,_)=>{const b=g.sparse;if(!b)return;const{values:y,indices:T,count:w}=b,P=x.bufferViews,$=P[y.bufferView],H=$.buffer,z=x.buffers,q=z[H],W=[],ye=[],Ge=P[T.bufferView],Ke=Ge.buffer,Xe=z[Ke];let je;q.uri&&(je=i.parsingResult.uris.buffers[H]);const Ye=Ts[g.componentType],{BYTES_PER_ELEMENT:Ze}=Ye;let Je;switch(Ye){case Float32Array:Je="getFloat32";break;case Uint32Array:Je="getUint32";break;case Uint16Array:Je="getUint16";break;case Int16Array:Je="getInt16";break;case Uint8Array:Je="getUint8";break;case Int8Array:Je="getInt8"}const Qe=g.byteOffset||0;let et,at,ht=(($.byteOffset||0)+Qe)/Ze;switch(g.type){case"VEC3":for(et=ht+Ze*w/Ze*3;ht<et;ht++){const i=je[Je](ht*Ze,!0);"NORMAL"==m||"POSITION"==m&&W.push(i)}break;case"VEC2":for(et=ht+Ze*w/Ze*2;ht<et;ht++)"TEXCOORD_0"==m&&ye.push(je[Je](ht*Ze,!0))}Xe.uri&&(at=i.parsingResult.uris.buffers[Ke]);const ft=Ts[T.componentType],gt=ft.BYTES_PER_ELEMENT,xt=ft===Uint16Array?"getUint16":"getUint8",vt=T.byteOffset||0;let bt=((Ge.byteOffset||0)+vt)/gt;const yt=bt+gt*w/gt;let Tt=0;for(;bt<yt;bt++){const i=at[xt](bt*gt,!0);_[3*i]=W[3*Tt],_[3*i+1]=W[3*Tt+1],_[3*i+2]=W[3*Tt+2],Tt++}};class MorphInfoData_GLTF{vertices=[];verticesColor_0=[];normals=[];uvs=[];uvs1=[];uvs2=[];jointWeights=[];joints=[];tangents=[];interleaveData;constructor(i=[],m=[],g=[],x=[],_=[],b=[],y=[],T=[],w=[]){this.vertices=i,this.verticesColor_0=m,this.normals=g,this.uvs=x,this.uvs1=_,this.uvs2=_,this.jointWeights=y,this.joints=T,this.tangents=w}}class MorphInfo_GLTF{morphInfoDataList=[];weights;cacheData={};origin;constructor(i,m,g,x){g.targets&&(this.morphInfoDataList=g.targets.map(g=>{const x=new MorphInfoData_GLTF;for(let _ in g){const{vertices:b,verticesColor_0:y,normals:T,uvs:w,uvs1:P,uvs2:$,jointWeights:H,joints:z,tangents:q}=x,W=g[_],ye=new AccessorInfo_GLTF(i,m,W),{accessor:Ge}=ye;parseAttributeInfo_GLTF(_,ye,b,w,P,$,T,H,z,y,q),Ge.sparse&&parseSparse_GLTF(i,_,Ge,m,b)}return x})),this.weights=x||[],this.origin=null}}const parseMaterialTexture=(i,m,g,x,_)=>{const{redGPUContext:b,gltfData:y}=i,{textureRawList:T}=i.parsingResult,w=g.index,P=y.textures[w],$=P.extensions?.EXT_texture_webp?.source||P.source,H=getURL(i,y,$);if(H){const w=P.sampler,z=getSamplerInfo(i,y,w),{parsedURI:q,cacheKey:W}=H,ye=`${x}SourceGlTfId_${$}`;if(T[ye]?(T[ye].materialList.push(m),T[ye].samplerList.push(new Sampler(b,z))):T[ye]={src:q,cacheKey:W,targetTextureKey:x,targetSamplerKey:`${x}Sampler`,materialList:[m],samplerList:[new Sampler(b,z)],format:_||navigator.gpu.getPreferredCanvasFormat()},m[`${x}_texCoord_index`]=g.texCoord||0,"extensions"in g){const{extensions:i}=g,{KHR_texture_transform:_}=i;_&&((i,m,g)=>{i[`${m}_KHR_texture_transform_offset`]=g.offset||[0,0],i[`${m}_KHR_texture_transform_scale`]=g.scale||[1,1],i[`${m}_KHR_texture_transform_rotation`]=g.rotation||0,i[`use_${m}_KHR_texture_transform`]=!0})(m,x,_)}}},getURL=function(i,m,g){if(!m.images[g])return null;const{uri:x}=m.images[g];let _;const b=`${i.url}_${g}`;return _=x.indexOf("blob:http")>-1?x:(x.indexOf(";base64,")>-1?"":i.filePath)+x,{parsedURI:_,cacheKey:b}},getSamplerInfo=function(i,m,g){const x={magFilter:On.LINEAR,minFilter:On.LINEAR,mipmapFilter:On.LINEAR,addressModeU:An.REPEAT,addressModeV:An.REPEAT,addressModeW:An.REPEAT},_={33071:An.CLAMP_TO_EDGE,33648:An.MIRRORED_REPEAT,10497:An.REPEAT},b={9728:On.NEAREST,9729:On.LINEAR},y={9728:On.NEAREST,9729:On.LINEAR};if(m.samplers){let i=m.samplers[g];i&&("magFilter"in i&&(x.magFilter=b[i.magFilter]||On.LINEAR),"minFilter"in i&&(x.minFilter=y[i.minFilter]||On.LINEAR),"wrapS"in i&&(x.addressModeU=_[i.wrapS]),"wrapT"in i&&(x.addressModeV=_[i.wrapT]))}return x.string=JSON.stringify(x),x},parseMaterialInfo_GLTF=(i,m,g)=>{const{redGPUContext:x}=i;let _,b=!1,y="OPAQUE",T=.5;if("material"in g){_=new PBRMaterial(x);const w=g.material,P=m.materials[w];b=!!P.doubleSided,y=P.alphaMode??y,T=P.alphaCutoff??T;const{pbrMetallicRoughness:$,normalTexture:H,emissiveTexture:z,occlusionTexture:q}=P;if(_.emissiveFactor=P.emissiveFactor||[0,0,0],$){const{metallicRoughnessTexture:m,baseColorTexture:g}=$;let x,b;_.baseColorFactor=$.baseColorFactor||[1,1,1,1],"metallicFactor"in $&&(x=$.metallicFactor),"roughnessFactor"in $&&(b=$.roughnessFactor),_.metallicFactor=null!=x?x:1,_.roughnessFactor=null!=b?b:1,g&&parseMaterialTexture(i,_,g,"baseColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),m&&parseMaterialTexture(i,_,m,"metallicRoughnessTexture")}if(H){parseMaterialTexture(i,_,H,"normalTexture");const{scale:m}=H;_.normalScale=null!=m?m:1}if(z&&parseMaterialTexture(i,_,z,"emissiveTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),q&&(parseMaterialTexture(i,_,q,"occlusionTexture"),_.occlusionStrength=P.occlusionTexture.strength||1),"extensions"in P){const{extensions:m}=P,{KHR_materials_clearcoat:g,KHR_materials_emissive_strength:x,KHR_materials_transmission:b,KHR_materials_diffuse_transmission:T,KHR_materials_volume:w,KHR_materials_unlit:$,KHR_materials_ior:H,KHR_materials_sheen:z,KHR_materials_specular:q,KHR_materials_dispersion:W,KHR_materials_anisotropy:ye,KHR_materials_iridescence:Ge}=m;if(Ge&&((i,m,g)=>{i.useKHR_materials_iridescence=!0,i.KHR_iridescenceFactor=m.iridescenceFactor||0,i.KHR_iridescenceIor=m.iridescenceIor||1.3,i.KHR_iridescenceThicknessMinimum=m.iridescenceThicknessMinimum||100,i.KHR_iridescenceThicknessMaximum=m.iridescenceThicknessMaximum||400,i.transparent=!0;{const{iridescenceTexture:x,iridescenceThicknessTexture:_}=m;x&&parseMaterialTexture(g,i,x,"KHR_iridescenceTexture"),_&&parseMaterialTexture(g,i,_,"KHR_iridescenceThicknessTexture")}})(_,Ge,i),ye&&((i,m,g)=>{i.useKHR_materials_anisotropy=!0,i.KHR_anisotropyStrength=m.anisotropyStrength||0,i.KHR_anisotropyRotation=m.anisotropyRotation||0;const{anisotropyTexture:x}=m;x&&parseMaterialTexture(g,i,x,"KHR_anisotropyTexture")})(_,ye,i),g&&((i,m,g)=>{i.KHR_clearcoatFactor=m.clearcoatFactor||0,i.KHR_clearcoatRoughnessFactor=m.clearcoatRoughnessFactor||0,i.useKHR_materials_clearcoat=!0;const{clearcoatTexture:x,clearcoatNormalTexture:_,clearcoatRoughnessTexture:b}=m;x&&parseMaterialTexture(g,i,x,"KHR_clearcoatTexture"),_&&parseMaterialTexture(g,i,_,"KHR_clearcoatNormalTexture"),b&&parseMaterialTexture(g,i,b,"KHR_clearcoatRoughnessTexture")})(_,g,i),x){const{emissiveStrength:i}=x;_.emissiveStrength=null!=i?i:1}if(b&&(((i,m,g)=>{i.useKHR_materials_transmission=!0,i.KHR_transmissionFactor=m.transmissionFactor||0,i.use2PathRender=!0;{const x=m.transmissionTexture;x&&parseMaterialTexture(g,i,x,"KHR_transmissionTexture")}})(_,b,i),_.transparent="BLEND"===y),T&&((i,m,g)=>{i.useKHR_materials_diffuse_transmission=!0,i.KHR_diffuseTransmissionFactor=m.diffuseTransmissionFactor||0,i.KHR_diffuseTransmissionColorFactor=m.diffuseTransmissionColorFactor||[1,1,1],i.transparent=!0;{const x=m.diffuseTransmissionTexture;x&&parseMaterialTexture(g,i,x,"KHR_diffuseTransmissionTexture");const _=m.diffuseTransmissionColorTexture;_&&parseMaterialTexture(g,i,_,"KHR_diffuseTransmissionColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`)}})(_,T,i),w&&(((i,m,g)=>{i.useKHR_materials_volume=!0,i.KHR_thicknessFactor=m.thicknessFactor||1,i.KHR_attenuationDistance=m.attenuationDistance||1,i.KHR_attenuationColor=m.attenuationColor||[1,1,1],i.use2PathRender=!0,i.transparent=!0;{const x=m.thicknessTexture;x&&parseMaterialTexture(g,i,x,"KHR_thicknessTexture")}})(_,w,i),y="BLEND"),$&&(_.useKHR_materials_unlit=!0),H){const{ior:i}=H;_.KHR_materials_ior=null!=i?i:1.5,_.use2PathRender=!0,_.transparent=!0}if(W){const{dispersion:i}=W;_.KHR_dispersion=i||0,_.use2PathRender=!0,_.transparent=!0}z&&((i,m,g)=>{i.KHR_sheenColorFactor=m.sheenColorFactor||[0,0,0],i.KHR_sheenRoughnessFactor=m.sheenRoughnessFactor||0,i.useKHR_materials_sheen=!0;const{sheenColorTexture:x,sheenRoughnessTexture:_}=m;x&&parseMaterialTexture(g,i,x,"KHR_sheenColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),_&&parseMaterialTexture(g,i,_,"KHR_sheenRoughnessTexture")})(_,z,i),q&&((i,m,g)=>{i.useKHR_materials_specular=!0,i.KHR_specularFactor=m.specularFactor??1,i.KHR_specularColorFactor=m.specularColorFactor||[1,1,1];const{specularTexture:x,specularColorTexture:_}=m;x&&parseMaterialTexture(g,i,x,"KHR_specularTexture"),_&&parseMaterialTexture(g,i,_,"KHR_specularColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`)})(_,q,i)}}else _=new PBRMaterial(x);Object.hasOwn(g.attributes,"COLOR_0")&&(_.useVertexColor=!0),_.doubleSided=b,_.cutOff=T;const{blendColorState:w,blendAlphaState:P}=_;switch(y){case"BLEND":_.alphaBlend=2,w.srcFactor=cn.SRC_ALPHA,w.dstFactor=cn.ONE_MINUS_SRC_ALPHA,P.srcFactor=cn.SRC_ALPHA,P.dstFactor=cn.ONE_MINUS_SRC_ALPHA,_.transparent=!0;break;case"MASK":_.alphaBlend=1,_.useCutOff=!0,w.srcFactor=cn.ONE,w.dstFactor=cn.ZERO,P.srcFactor=cn.ONE,P.dstFactor=cn.ZERO;break;default:w.srcFactor=cn.ONE,w.dstFactor=cn.ZERO,P.srcFactor=cn.ONE,P.dstFactor=cn.ZERO,_.alphaBlend=0}return _},parseIndicesInfo_GLTF=(i,m)=>{const{accessor:g,startIndex:x,getMethod:_,bufferURIDataView:b,componentType_BYTES_PER_ELEMENT:y}=i,{type:T,count:w}=g;let P,$=x;if("SCALAR"===T)for(P=$+w;$<P;$++)m.push(b[_]($*y,!0))},parseInterleaveData_GLTF=(i,m,g,x,_,b,y,T,w,P)=>{let $,H,z,q,W,ye,Ge,Ke,Xe,je=0,Ye=m.length/3,Ze=0;const Je=m.length,Qe=x.length,et=b.length,at=y.length,ht=g.length,ft=T.length,gt=w.length,xt=P.length;for($=z=ye=0,H=q=Ge=1,W=Ke=2,Xe=3;je<Ye;je++)Je&&(i[Ze++]=m[z],i[Ze++]=m[q],i[Ze++]=m[W]),Qe?(i[Ze++]=x[z],i[Ze++]=x[q],i[Ze++]=x[W]):(i[Ze++]=0,i[Ze++]=0,i[Ze++]=0),_.length||_.push(0,0),_.length&&(i[Ze++]=_[$],i[Ze++]=_[H]),at?(i[Ze++]=y[$],i[Ze++]=y[H]):et?(i[Ze++]=b[$],i[Ze++]=b[H]):_.length&&(i[Ze++]=_[$],i[Ze++]=_[H]),ht?(i[Ze++]=g[ye],i[Ze++]=g[Ge],i[Ze++]=g[Ke],i[Ze++]=g[Xe]):(i[Ze++]=0,i[Ze++]=0,i[Ze++]=0,i[Ze++]=0),ft?(i[Ze++]=T[ye],i[Ze++]=T[Ge],i[Ze++]=T[Ke],i[Ze++]=T[Xe]):(i[Ze++]=0,i[Ze++]=0,i[Ze++]=0,i[Ze++]=0),gt?(i[Ze++]=w[ye],i[Ze++]=w[Ge],i[Ze++]=w[Ke],i[Ze++]=w[Xe]):(i[Ze++]=0,i[Ze++]=0,i[Ze++]=0,i[Ze++]=0),xt?(i[Ze++]=P[ye],i[Ze++]=P[Ge],i[Ze++]=P[Ke],i[Ze++]=P[Xe]):(i[Ze++]=0,i[Ze++]=0,i[Ze++]=0,i[Ze++]=0),$+=2,H+=2,z+=3,q+=3,W+=3,ye+=4,Ge+=4,Ke+=4,Xe+=4},Ms=180/Math.PI,setMeshRotation=(i,m)=>{m.setRotation(-i[0]*Ms,-i[1]*Ms,-i[2]*Ms)},parseTRSAndMATRIX_GLTF=(i,m)=>{const{matrix:g,rotation:x,translation:_,scale:b}=m;let y,T;if("matrix"in m){y=create$5(),T=create$4(),mat4ToEuler(g,T),setMeshRotation(T,i),i.setPosition(g[12],g[13],g[14]);const m=fromValues$4(1,1,1);getScaling(m,g),i.setScale(m[0],m[1],m[2])}"rotation"in m&&(y=create$5(),T=create$4(),quaternionToRotationMat4(x,y),mat4ToEuler(y,T),setMeshRotation(T,i)),"translation"in m&&i.setPosition(_[0],_[1],_[2]),"scale"in m&&(i.setScale(b[0],b[1],b[2]),(b[0]<0||b[1]<0||b[2]<0)&&(i.primitiveState.frontFace=ii.CW))},parseChildrenAndSkin=(i,m,g,x,_)=>{if("children"in x){const _=x.children,b=_.length;for(let x=0;x<b;x++)parseNode_GLTF(i,m,_[x],g)}"skin"in x&&((i,m,g,x)=>{const _=new ParsedSkinInfo_GLTF,b=[],{nodes:y}=m,{joints:T,skeleton:w}=g;{let m=0;const g=T.length;for(;m<g;m++){const g=T[m];parseJoint_GLTF(i,_,y,g)}}w&&(_.skeletonMesh=y[w].Mesh);const P=g.inverseBindMatrices,$=new AccessorInfo_GLTF(i,m,P),{startIndex:H,accessor:z,componentType_BYTES_PER_ELEMENT:q,bufferViewByteStride:W,bufferURIDataView:ye,getMethod:Ge}=$,{type:Ke,count:Xe}=z;let je=0;const Ye=W/q;let Ze,Je=H;if("MAT4"===Ke)if(W)for(Ze=Je+Xe*(W/q);Je<Ze;Je++)je%Ye<16&&b.push(ye[Ge](Je*q,!0)),je++;else for(Ze=Je+16*Xe;Je<Ze;Je++)b.push(ye[Ge](Je*q,!0)),je++;_.inverseBindMatrices=[];for(let i=0;i<T.length;i++)_.inverseBindMatrices.push(new Float32Array([b[16*i],b[16*i+1],b[16*i+2],b[16*i+3],b[16*i+4],b[16*i+5],b[16*i+6],b[16*i+7],b[16*i+8],b[16*i+9],b[16*i+10],b[16*i+11],b[16*i+12],b[16*i+13],b[16*i+14],b[16*i+15]]));x.animationInfo.skinInfo=_,x.material.useSkin=!!x.animationInfo.skinInfo})(i,m,_[x.skin],g)},parseNode_GLTF=(i,m,g,x)=>{const{redGPUContext:_,parsingResult:b}=i,{nodes:y,meshes:T,skins:w}=m,{groups:P,cameras:$}=b,H=y[g];if("mesh"in H){const g=function(i,m,g){const{redGPUContext:x}=i;let _;g.name&&(_=g.name);const b=[],{primitives:y}=g;let T=0;const w=y.length;for(;T<w;T++){const w=y[T];let P,$,H,z=[],q=[],W=[],ye=[],Ge=[],Ke=[],Xe=[],je=[],Ye=[],Ze=[];const{attributes:Je}=w;if(Je)for(const g in Je){const x=Je[g],_=new AccessorInfo_GLTF(i,m,x);parseAttributeInfo_GLTF(g,_,q,ye,Ge,Ke,Xe,je,Ye,W,Ze),_.accessor.sparse&&parseSparse_GLTF(i,g,_.accessor,m,q)}if("indices"in w){let g=w.indices,x=new AccessorInfo_GLTF(i,m,g);parseIndicesInfo_GLTF(x,z)}$=parseMaterialInfo_GLTF(i,m,w),$ instanceof PBRMaterial&&i.parsingResult.materials.push($);let Qe,et=!1;if("mode"in w)switch(w.mode){case 0:H=yr.POINT_LIST;break;case 1:case 2:H=yr.LINE_LIST;break;case 3:H=yr.LINE_STRIP,et=!0;break;case 4:case 6:H=yr.TRIANGLE_LIST;break;case 5:H=yr.TRIANGLE_STRIP,et=!0}W.length&&($.useVertexColor_0=!0),Ze.length&&($.useVertexTangent=!0),Qe=Xe.length?Xe:calculateNormals(q,z);let at,ht=[];parseInterleaveData_GLTF(ht,q,W,Qe,ye,Ge,Ke,je,Ye,Ze);let ft={};if(q.length&&(ft.aVertexPosition=InterleaveType.float32x3),Qe.length&&(ft.aVertexNormal=InterleaveType.float32x3),ye.length&&(ft.aTexcoord=InterleaveType.float32x2),(Ke.length||Ge.length||ye.length)&&(ft.aTexcoord1=InterleaveType.float32x2),ft.aVertexColor_0=InterleaveType.float32x4,ft.aVertexWeight=InterleaveType.float32x4,ft.aVertexJoint=InterleaveType.float32x4,ft.aVertexTangent=InterleaveType.float32x4,at=new Geometry(x,new VertexBuffer(x,ht,new InterleavedStruct(ft)),!et&&z.length?new IndexBuffer(x,new Uint32Array(z)):null),$||consoleAndThrowError("재질을 파싱할수없는경우 ",w),P=new Mesh(x,at,$),_&&(P.name=_,i.parsingOption))for(let m in i.parsingOption)_.toLowerCase().indexOf(m)>-1&&i.parsingOption[m](P);P.primitiveState.topology=H||yr.TRIANGLE_LIST,P.material.doubleSided&&(P.primitiveState.cullMode=ni.NONE),P.material.use2PathRender&&(P.primitiveState.cullMode=ni.NONE,P.depthStencilState.depthCompare=Qn.LESS),2===P.material.alphaBlend&&(P.depthStencilState.depthCompare=Qn.LESS);{let x=new MorphInfo_GLTF(i,m,w,g.weights),_=0,b=x.morphInfoDataList;const y=b.length;for(;_<y;){const i=b[_],m=i.normals.length?i.normals:calculateNormals(i.vertices,z),g=[];parseInterleaveData_GLTF(g,i.vertices,i.verticesColor_0,m,i.uvs,i.uvs1,i.uvs2,i.jointWeights,i.joints,i.tangents),i.interleaveData=g,_++}P.animationInfo.morphInfo=x,P.animationInfo.morphInfo.origin=new Float32Array(ht)}let gt=P.geometry.vertexBuffer.data;P.gpuRenderInfo||P.initGPURenderInfos();let xt=0;for(const i in ft)xt+=ft[i].numElements;{const i=P.animationInfo.morphInfo.morphInfoDataList;let m=0;const g=i.length,x=gt.length;for(;m<g;){const g=i[m].vertices;let _=0,b=x/xt,y=null==P.animationInfo.morphInfo.weights[m]?.5:P.animationInfo.morphInfo.weights[m];for(;_<b;)gt[_*xt]+=g[3*_]*y,gt[_*xt+1]+=g[3*_+1]*y,gt[_*xt+2]+=g[3*_+2]*y,_++;m++}}P.geometry.vertexBuffer.updateAllData(gt),P.animationInfo.morphInfo.origin=new Float32Array(gt),w.Mesh=P,b.push(P)}return b}(i,m,T[H.mesh]),_=g.length;for(let b=0;b<_;b++){let _=g[b];x.addChild(H.Mesh=_),parseTRSAndMATRIX_GLTF(_,H),parseChildrenAndSkin(i,m,_,H,w)}}else{let b;P[g]?(b=P[g],H.Mesh=b):(b=new Mesh(_),x.addChild(b),H.Mesh=b,b.name=H.name,P[g]=b),parseTRSAndMATRIX_GLTF(b,H),parseChildrenAndSkin(i,m,b,H,w)}},parseGLTF=(i,m,g)=>{(i=>{const m=i?.asset;m||consoleAndThrowError("GLTFLoader - asset must be defined"),m.version||consoleAndThrowError("GLTFLoader - asset version must be defined");const g=parseFloat(m.version);isNaN(g)&&consoleAndThrowError("GLTFLoader - asset version must be a numerical value"),g<2&&consoleAndThrowError("GLTFLoader - asset version must be 2.0 or higher")})(m),((i,m,g)=>{const{parsingResult:x}=i,{uris:_}=x,b="buffers",y=_[b],T=m.buffers,w=T.length;let P=0;T.forEach((m,x)=>{var _;function checkLoadingStatus(){P===w&&g&&g()}m._redURIkey=b,m._redURIIndex=x,m.uri instanceof ArrayBuffer?(_=new DataView(m.uri),P++,y[x]=_,checkLoadingStatus()):function(m){const g=m.startsWith("data:")?m:i.filePath+m;arrayBufferLoader(g,function(i){P++,y[x]=new DataView(i),checkLoadingStatus()})}(m.uri)})})(i,m,()=>{((i,m,g)=>{const{scenes:x}=m;x[0].nodes.forEach(g=>{parseNode_GLTF(i,m,g,i.resultMesh)}),g?.()})(i,m,()=>{((i,m)=>{const{cameras:g}=m;g&&g.forEach(function(m){let g=new PerspectiveCamera;"orthographic"==m.type||(g.fieldOfView=180*m.perspective.yfieldOfView/Math.PI,g.farClipping=m.perspective.zfar,g.nearClipping=m.perspective.znear),i.parsingResult.cameras.push(g)})})(i,m),new TextureLoader(i.redGPUContext,Object.values(i.parsingResult.textureRawList),x=>{x.textures.forEach(i=>{const{targetTextureKey:m,targetSamplerKey:g,samplerList:x}=i.srcInfo;i.srcInfo.materialList.forEach((_,b)=>{_[m]=i.texture,x[b]&&(_[g]=x[b])})}),parseAnimations(i,m).then(i=>{g&&g()})})})})},parseFileGLB=async(i,m)=>{const g=i.filePath+i.fileName;await(async(i,m,g=()=>{})=>{try{const g=await fetch(i);m(await g.arrayBuffer())}catch(i){g(i)}})(g,async g=>{const{content:x,binaryChunk:_}=parseBuffer(g);if(null===x)throw new Error("JSON content not found");const b=JSON.parse(x);processImagesIfExist(b,_),b.buffers[0].uri=_,i.gltfData=b,parseGLTF(i,b,m)},i=>{})},parseBuffer=i=>{let m=null,g=null;const x=new DataView(i,12),_=x.byteLength;for(let b=0;b<_;){const _=x.getUint32(b,!0);b+=4;const y=x.getUint32(b,!0);switch(b+=4,y){case 1313821514:const x=new Uint8Array(i,12+b,_);m=convertUint8ArrayToString(x);break;case 5130562:const y=12+b;g=i.slice(y,y+_)}b+=_}return{content:m,binaryChunk:g}},processImagesIfExist=(i,m)=>{const{images:g,bufferViews:x}=i,_=["image/png","image/jpeg","image/gif","image/webp"];if(g)for(let i=0;i<g.length;i++){const b=g[i],{mimeType:y,bufferView:T}=b;if(_.includes(y)){const i=x[T].byteOffset||0,g=m.slice(i,i+x[T].byteLength),_=new Blob([new Uint8Array(g)],{type:y});b.uri=URL.createObjectURL(_)}}},convertUint8ArrayToString=i=>{let m="";for(let g of i)m+=String.fromCharCode(g);return m};class GLTFLoader{parsingResult;resultMesh;parsingOption;activeAnimations=[];#_;#Xh;#Uc;#Ac;#jh;#Yh;#ne;#ie;#Zh;constructor(i,m,g,x){validateRedGPUContext(i),this.#_=i,this.#Ac=m,this.#Xh=getFilePath(m),this.#Uc=getFileName(m),this.#jh=getFileExtension(m),this.#ne=g,this.#ie=x,this.parsingResult={groups:[],materials:[],uris:{buffers:[]},textures:{},textureRawList:[],cameras:[],animations:[]},this.resultMesh=new Mesh(this.#_),this.resultMesh.gltfLoaderInfo=this,this.resultMesh.animationInfo.animationsList=this.parsingResult.animations,this.#Jh()}get redGPUContext(){return this.#_}get filePath(){return this.#Xh}get gltfData(){return this.#Yh}set gltfData(i){this.#Yh=i}get fileName(){return this.#Uc}get url(){return this.#Ac}stopAnimation(){const{activeAnimations:i}=this;let m=i.indexOf(this.#Zh);m>-1&&i.splice(m,1)}playAnimation(i){const{activeAnimations:m}=this;m.push(this.#Zh=new PlayAnimationInfo(performance.now(),i))}async#Jh(){try{"glb"===this.#jh?await parseFileGLB(this,()=>this.#ne(this)):"gltf"===this.#jh?await(async(i,m)=>{const g=await fetch(i.url);i.gltfData=await g.json(),parseGLTF(i,i.gltfData,m)})(this,()=>this.#ne(this)):consoleAndThrowError("Unknown file extension:"+this.#jh)}catch(i){this.#ie?.(i)}}}Object.freeze(GLTFLoader);class PlayAnimationInfo{startTime;targetAniTrackList;constructor(i,m){this.startTime=i,this.targetAniTrackList=m}}export{Si as Camera,ColorRGB,ColorRGBA,Ra as Display,FinalRender,GLTFLoader,An as GPU_ADDRESS_MODE,cn as GPU_BLEND_FACTOR,hn as GPU_BLEND_OPERATION,Qn as GPU_COMPARE_FUNCTION,ni as GPU_CULL_MODE,kn as GPU_FILTER_MODE,ii as GPU_FRONT_FACE,ai as GPU_INDEX_FORMAT,$n as GPU_LOAD_OP,On as GPU_MIPMAP_FILTER_MODE,yr as GPU_PRIMITIVE_TOPOLOGY,Hn as GPU_STORE_OP,Geometry,Pa as Light,Ii as Material,OBJLoader,OBJMTLLoader,ys as Picking,bs as PostEffect,Ca as Primitive,RedGPUContext,RedGPUContextDetector,RedGPUContextSizeManager,RedGPUContextViewContainer,Fa as RenderState,Renderer,Na as Resource,rs as RuntimeChecker,sn as SystemCode,Ln as Util,pr as glMatrix,init};